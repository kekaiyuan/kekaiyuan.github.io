---
layout: post
title: Java Spring MVC 02——使用
categories: SpringMVC
description: some word here
keywords: keyword1, keyword2
---

# 02SpringMVC的使用

# SpringMVC 对请求的处理

## 参数处理
在 servlet 中，我们通过 `request.getParameter()` 获取请求中的参数。<br>
但是在 Spring MVC 中并没有 `request` 参数，此时如何处理？

### 获取参数 @RequestParam
当请求中的参数和方法形参**同名**时，可以**直接获取**参数。

```java
@Controller
public class RequestController {
    @RequestMapping("/request")
    public void request(String name){
        System.out.println(name);
    }
}
```
请求
```
http://localhost:8080/request?name=zhangsan
```
此时请求和方法中的参数名都是 username，可以**直接获取**。

但如果不同名，例如此时请求是这样的
```
http://localhost:8080/request?username=zhangsan
```
那么方法将获取不到 `username=zhangsan`。<br>
此时需要使用 `@RequestParam` 注解来获取参数


----------

```java
@RequestMapping("/request")
public void request(@RequestParam( "username") String name){
	System.out.println(name);
}
```
请求
```
http://localhost:8080/request?username=zhangsan
```
结果
```
zhangsan
```

请注意将 `@RequestParam` 与 `@PathVariable` 分开。
- `@RequestParam` <br>
	读取 `?` 后的参数
- `@PathVariable` <br>
	读取路径作为参数

#### @RequestParam 的属性
##### value
表示要获取的参数值
```java
@RequestMapping("/request")
public void request(@RequestParam( value = "username") String name){
	System.out.println(name);
}
```

##### required
表示该参数是否是**必须**的，**默认是**。

当方法这样时
```java
@RequestMapping("/request")
public void request(@RequestParam( value = "username") String name){
	System.out.println(name);
}
```
默认 `required = true` ，即请求必须带有 `username`

如果请求是这样的
```
http://localhost:8080/request
```
报错 400

所以如果 `request = false`，将允许请求中不携带该参数
```java
@RequestParam(value = "username", required = true)
```

##### defaultValue
设置参数的默认值

```java
@RequestParam(value = "username", defaultValue = "lisi")
```
如果请求中没有 `username` ，则默认其 `username = lisi`

所以，当有 `defaultValue` 时，`required = true` **自动失效**。<br>
因为请求中**一定**会有 `username`。

### 获取请求头 @RequestHeader
#### 图图图图图图图图图图图图图图图图图
获取整个请求头
```java
@Controller
public class RequestController {

	...
	
    @RequestMapping("/requestHeader")
    public void requestHeader(@RequestHeader HttpHeaders headers) {
        System.out.println(headers);
        return "success";
    }

}
```

获取一部分请求头
```java
@Controller
public class RequestController {

	...
	
    @RequestMapping("/requestHeader")
	public void requestHeader(@RequestHeader("Accept") String accept) {
        System.out.println(accept);
    }

}
```

`@RequestHeader` 同样拥有以下属性值，其效果等同于 `@RequestParam` 中的属性值
- `value`
- `required`
- `defaultValue`

### 获取 cookie @CookieValue
读取一部分 Cookie
```java
@Controller
public class RequestController {

	...
	
    @RequestMapping("/cookie")
    public void cookie(@CookieValue("JSESSIONID") String id){
        System.out.println(id);
    }
}
```

读取全部 Cookie，通过 `@RequestHeader` 读取
```java
@RequestHeader("Cookie") String cookie
```

`@CookieValue` 同样拥有以下属性值，其效果等同于 `@RequestParam` 中的属性值
- `value`
- `required`
- `defaultValue`


# Spring MVC 传输对象
使用 Spring MVC 传输对象非常方便。

User 类
```java
public class User {
    private Integer id;
    private String name;
    private Integer age;
    private Date date;
    private Address address;

	//省略无参构造器和 setter/getter 方法
}
```

Address 类
```java
package com.mashibing.bean;

public class Address {
    private String province;
    private String city;
    private String town;

	//省略无参构造器和 setter/getter 方法	
}
```

user.jsp<br>
把该 jsp 直接放置于 web 目录以直接访问
```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<%
    pageContext.setAttribute("ctp",request.getContextPath());
%>
<body>
<form action="${ctp}/testUser" method="post">
    编号：<input type="text" name="id"><br>
    姓名：<input type="text" name="name"><br>
    年龄：<input type="text" name="age"><br>
    性别：<input type="text" name="gender"><br>
    省份：<input type="text" name="address.province"><br>
    城市：<input type="text" name="address.city"><br>
    区域：<input type="text" name="address.town"><br>
    <input type="submit" value="提交"><br>
</form>
</body>
</html>
```

UserController2
```java
@Controller
public class UserController2 {

    @RequestMapping("/testUser")
    public void testUser(User user){
        System.out.println(user);
    }

}
```

测试<br>
图图图图图图

结果
```
User{id=1, name='kky', age=24, gender='鐢�', address=Address{province='浜戝崡', city='澶х悊', town='涓嬪叧'}}
```

有乱码问题，下文解决。

Spring MVC 会帮我们自动封装对象，十分方便。<br>
与 Spring 同理，在表单中的 `编号：<input type="text" name="id">` 中的 `id` 匹配的是<br>
User 类中的 `getId()`方法和 `setId()` 方法，并不是 `private Integer id;` 中的 `id`。


## 解决乱码问题

未解决：Windows

在前后端交互时经常会发生中文乱码问题，如何解决？

GET请求：在server.xml文件中，添加URIEncoding=“UTF-8”

POST请求：编写过滤器进行实现

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!--配置DispatcherServlet-->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!--
        关联springmvc的配置文件：
        此配置文件的属性可以不添加，但是需要在WEB-INF的目录下创建 前端控制器名称-servlet.xml文件
        -->

        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc-servlet.xml</param-value>
        </init-param>
    </servlet>
    <!--匹配servlet的请求，
    /：标识匹配所有请求，但是不会jsp页面
    /*：拦截所有请求，拦截jsp页面

     但是需要注意的是，当配置成index.html的时候，会发现请求不到
     原因在于，tomcat下也有一个web.xml文件，所有的项目下web.xml文件都需要继承此web.xml
     在服务器的web.xml文件中有一个DefaultServlet用来处理静态资源，但是url-pattern是/
     而我们在自己的配置文件中如果添加了url-pattern=/会覆盖父类中的url-pattern，此时在请求的时候
     DispatcherServlet会去controller中做匹配，找不到则直接报404
     而在服务器的web.xml文件中包含了一个JspServlet的处理，所以不过拦截jsp请求
    -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    <filter>
        <filter-name>characterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <!--解决post请求乱码-->
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
        <!--解决响应乱码-->
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>characterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

</web-app>
```

**注意：如果配置了多个过滤器，那么字符编码过滤器一定要在最前面，否则失效。**

# Spring MVC对原生 API 的支持
在 Spring MVC 中是可以使用原生 servlet 对象的，只需要在参数中给出好了。

例如，这是从 [菜鸟教程](https://www.runoob.com/servlet/servlet-first-example.html) 中找的 servlet 教程
```java
// 导入必需的 java 库
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

// 扩展 HttpServlet 类
public class HelloWorld extends HttpServlet {
 
  private String message;

  public void init() throws ServletException
  {
      // 执行必需的初始化
      message = "Hello World";
  }

  public void doGet(HttpServletRequest request,
                    HttpServletResponse response)
            throws ServletException, IOException
  {
      // 设置响应内容类型
      response.setContentType("text/html");

      // 实际的逻辑是在这里
      PrintWriter out = response.getWriter();
      out.println("<h1>" + message + "</h1>");
  }
  
  public void destroy()
  {
      // 什么也不做
  }
}
```
可以看到，其中有两个重要的参数：
- `HttpServletRequest request`<br>
	封装请求
- `HttpServletResponse response`<br>
	封装回应

根据 `request` 中的内容，在 `response` 中填写要返回的内容，这就是 servlet 。

那么在 Spring MVC 中，同样支持 `HttpServletRequest request` 和 `HttpServletResponse response`。<br>
**直接写入方法参数列表即可**。

```java
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

@Controller
public class UserController2 {

    @RequestMapping("api")
    public String servletAPI(HttpServletRequest request, HttpServletResponse response, HttpSession session){
        request.setAttribute("request","request");
        session.setAttribute("session","session");
        return "success";
    }
}
```

然后前端页面直接读取这些信息
```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
request:${requestScope.get("request")}
session:${sessionScope.get("session")}
</body>
</html>
```

那么，Spring MVC 到底支持哪些原生的 servlet 对象呢？
- HttpServletRequest
- HttpServletResponse
- HttpSession
- Locale<br>
	设置区域信息，国际化操作使用
- InputStream
- OutputStream
- Reader
- Writer

# 传输数据到页面
## 使用 Map, Model, ModelMap
`return 要返回的页面`
```java
@Controller
@SessionAttributes(types = String.class)
public class OutputController {

    @RequestMapping("/output")
    public String output(Map<String,String> map){
        map.put("msg","hello,output");
        return "success";
    }

    @RequestMapping("/output2")
    public String output2(Model model){
        model.addAttribute("msg","hello,output2");
        return "success";
    }

    @RequestMapping("/output3")
    public String output3(ModelMap modelMap){
        modelMap.addAttribute("msg","hello,output3");
        return "success";
    }

}
```

前端如何调用？
```jsp
${msg}
```

这三者的效果是一模一样的，而且作用域都是 `request` 。

因为这三者是同一个类：<br>
```java
org.springframework.validation.support.BindingAwareModelMap
```

#### tttttttttttttttttttttt
![](image\BindingAwareModelMap.png)

并且其数据都是放在 `ModelAndView` 中的。

## 使用 ModelAndView
`serViewName(要返回的页面名称)`
```java
@Controller
public class OutputController {

    @RequestMapping("mv")
    public ModelAndView mv(){
        ModelAndView mv = new ModelAndView();
        mv.setViewName("output");
        mv.addObject("msg","hello.modelAndView");
        return mv;
    }
}
```

使用 ModelAndView 时，返回的数据同样是放在 request 作用域中。


##  使用 session
当使用 Map, Model, ModelMap, ModelAndView 传输数据时，数据都是放入 request 作用域的。<br>
如果此时添加 `@SessionAttribute` ，那么会将数据在 session 中**也保存一份**。

此注解有两个参数
- `value`<br>
	表示要添加哪些数据到 session 中
- `type`<br>
	设置数据的类型<br>
	一般情况下不使用，因为会将很多数据都设置到 session 中，导致 session 异常。

```java
@Controller
@SessionAttributes(value = "msg")
public class OutputController {

    @RequestMapping("output1")
    public String output1(Model model){
        model.addAttribute("msg","hello,Springmvc");
        System.out.println(model.getClass());
        return "sucess";
    }
}
```

# 使用 @ModelAttribute 来获取请求中的数据
`@ModelAttribute` 注解用于将方法的参数或者方法的返回值绑定到指定的模型属性上，并返回给 web 视图。

介绍一下业务场景。<br>
在某网站，用户可以查看自己的个人信息，此时我们会从数据库中读取该用户的数据并显示到网页上。<br>
用户可以修改**部分**信息，但不能修改**所有**信息，例如其 id 就不能修改。

这些不允许修改的属性**不应该被提交**，因为没有意义，只是在浪费资源。<br>
但是如果不提交，form 表单提交的数据就会出现**空白**。<br>
如何解决？

此时就有了这样的设计：
1. 执行查询操作时，把从数据库获取的对象保存下来。
2. 用户提交表单时，根据其内容修改之前保存的对象。
3. 把这个对象再存回数据库。

对比之前的设计：
1. 执行查询操作时，**创建一个新对象**，保存数据。
2. 把这个对象传到前端。
3. 用户提交表单时，**再创建一个新对象**，保存数据。
4. 把这个对象存回数据库。

原来需要创建两个对象，现在只需要创建一个对象。


----------


实体类 User
```java
public class User {
    private Integer id;
    private String name;
    private String password;
    private Integer age;

    //省略构造方法，所有属性的 getter/setter 方法和 toString 方法
}
```

UserController
```java
@Controller
@SessionAttributes("user")
public class UserController {

    @RequestMapping("/update")
    public String update(@ModelAttribute("user") User user) {
        System.out.println(user);
        return "success";
    }

    @ModelAttribute
    public void testModelAttribute(Model model) {
        User user = new User();
        user.setId(1);
        user.setName("李四");
        user.setAge(11);
        user.setPassword("1234");
        model.addAttribute("user", user);
    }
	
	@RequestMapping("/user")
    public String testUser(Model model) {
        testModelAttribute(model);
        return "update";
    }
	
}
```

update.jsp
```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<%
    pageContext.setAttribute("ctp", request.getContextPath());
%>
<body>
<form action="${ctp}/update">
    id:<input type="text" value="${sessionScope.user.id}" readonly="true"><br>
    name:<input type="text" value="${requestScope.user.name}" name="name"><br>
    <input type="submit" value="更新"><br>
</form>
</body>
</html>
```

测试
![](\images\posts\java\framework\spring-mvc\02)

点击更新，结果
```java
User{id=1, name='zhangsan', password='1234', age=11}
```

可以看到，前端页面并没有 `password` 和 `age` 属性。<br>
如果不使用 `@ModelAttribute`，那么后端收到的将是
```java
User{id=1, name='zhangsan', password=null, age=null}
```
因为前端提交表单时，将重新**新建**一个对象，所以没有提交的属性值就是 `null`。

而如果使用了 `@ModelAttribute` ，整个流程使用的是一个对象。
1. 该对象传输到前端，进行数据改写。
2. 再将该对象传输到后端进行数据处理。

**注意：**
1. 使用 `@ModelAttribute` 时，对象存在在 **session** 中。
2. 使用时可以省略 `@SessionAttribute` 和方法**参数中**的 `@ModelAttribute`，但是不推荐。
3. 请尽量将使用该对象的地方**同名**，否则 Spring MVC 将自动把类名首字母小写进行匹配，匹配不到时会报错。

`@ModelAttribute` 除了将对象添加到 `Model` 之外，还可以直接返回。

注意：ModelAttribute除了可以使用设置值到model中之外，还可以利用返回值。

```java
	...

    @ModelAttribute("user")
    public User testModelAttribute() {
        System.out.println("testModelAttribute---------------+");
        User user = new User();
        user.setId(1);
        user.setName("zhangsan");
        user.setAge(11);
        user.setPassword("1234");
        return user;
    }

	...
```

# 转发和重定向
## 使用 forward 实现页面转发
在 Spring MVC 中，我们可以使用视图处理器将**逻辑**视图转换成**实际**视图。

springmvc.xml
```xml
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
	<property name="suffix" value=".jsp"></property>
	<property name="prefix" value="/WEB-INF/page/"></property>
</bean>
```

```java
@Controller
public class ForWardController {

    @RequestMapping("/success")
    public String forward(){
        System.out.println("forward");
        return "success";
    }

}
```
此时当接收到 `/success` 请求时，将跳转到 `/WEB-INF/page/success.jsp`。

而如果使用 `forward` ，则不会触发视图处理器，直接跳转到我们指定的**实际视图**去。

```java
@Controller
public class ForWardController {

    @RequestMapping("/forward")
    public String forward(){
        System.out.println("forward");
        return "forward:/index.jsp";
    }

}
```
此时将跳转到 `/index.jsp` 中，这个在视图处理器是无法实现的，因为 `/index.jsp` 不在 `/WEB-INF/page` 目录中。

`forward` 除了跳转到指定页面，也可以跳转到其他请求中。
```java
@Controller
public class ForWardController {

    @RequestMapping("/forward")
    public String forward(){
        System.out.println("forward");
        return "forward:/index.jsp";
    }

    @RequestMapping("/forward2")
    public String forward2(){
        System.out.println("forward2");
        return "forward:/forward";
    }
}
```
此时 `/forward2` 请求将跳转到 `/forward` 请求，最终跳转到 `/index.jsp` 页面中。

## 使用 redirect 来实现重定向
`redirect` 使用方法和 `forward` 很像。<br>
同样不会经过视图处理器。

```java
@Controller
public class RedirectController {

    @RequestMapping("/redirect")
    public String redirect(){
        System.out.println("redirect");
        return "redirect:/index.jsp";
    }

    @RequestMapping("/redirect2")
    public String redirect2(){
        System.out.println("redirect2");
        return "redirect:/redirect";
    }
}
```

## 转发和重定向的区别

| **区别**         | **转发 forward()**  | **重定向 sendRedirect()** |
| ---------------- | ------------------ | ------------------------ |
|| <div width="200" src="\images\posts\java\framework\spring-mvc\02\转发.png" | ![](\images\posts\java\framework\spring-mvc\02\重定向.png) |  
| **根目录**       | 包含项目访问地址<br>`localhost:8080/项目地址/`   | 不包含项目访问地址`localhost:8080/`         |
| **地址栏** | 不会发生变化<br>访问前：`./forward`<br>访问后：`./forward`       | 会发生变化<br>访问前：`./redirect`<br>访问后：`./index.jsp`               |
| **哪里跳转**     | 服务器端进行的跳转 | 浏览器端进行的跳转       |
| **请求次数** | 1 次 | 2 次<br>第 1 次是人为的<br>第 2 次是自动的 |
| **请求域中数据** | 不会丢失           | 会丢失，因为是不同的请求  |


##### 10、静态资源的访问

当页面中包含静态资源的时候我们能够正确的获取到吗？

hello.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %><%    pageContext.setAttribute("ctx",request.getContextPath());%><html><head>    <title>Title</title></head><body>hello springmvc<img src="${ctx}/images/timg.jpg"></body></html>
```

此时大家发现我们请求的图片根本访问不到，根据查看发现路径是没有问题的，那么为什么会找不到静态资源呢？

![image-20200312233843775](image\静态资源.png)

大家发现此时是找不到对应的mapping映射的，此时是因为DispatcherServlet会拦截所有的请求，而此时我们没有对应图片的请求处理方法，所以此时报错了，想要解决的话非常简单，只需要添加一个配置即可

```
<!--此配置表示  我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理静态资源可以访问，但是动态请求无法访问--><mvc:default-servlet-handler/>
```

但是加上此配置之后，大家又发现此时除了静态资源无法访问之外，我们正常的请求也无法获取了，因此还需要再添加另外的配置：

```
<!--保证静态资源和动态请求都能够访问--><mvc:annotation-driven></mvc:annotation-driven>
```

### （2）自定义视图解析器

我们在之前的操作中已经用了SpringMVC中提供的视图解析器，那么如果我们需要实现自己的视图解析器该如何操作呢？

![image-20200312211420457](image\视图解析器.png)

![image-20200312211552245](image\视图对象.png)

MyViewController.java

```java
package com.mashibing.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class MyViewController {

    @RequestMapping("/myview")
    public String myView(Model model){
        model.addAttribute("msb","马士兵");
        return "msb:/index";
    }
}
```

MyViewResolver.java

```java
package com.mashibing.view;

import org.springframework.core.Ordered;
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.ViewResolver;

import java.util.Locale;

public class MyViewResolver implements ViewResolver, Ordered {
    private int order = 0;
    public View resolveViewName(String viewName, Locale locale) throws Exception {

        //如果前缀是msb:开头的就进行解析
        if (viewName.startsWith("msb:")){
            System.out.println("msb:");
            return new MyView();
        }else{
            //如果不是，则直接返回null
            return null;
        }
    }

    public int getOrder() {
        return this.order;
    }

    public void setOrder(Integer order) {
        this.order = order;
    }
}

```

MyView.java

```java
package com.mashibing.view;import org.springframework.core.Ordered;import org.springframework.web.servlet.View;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Map;public class MyView implements View {    public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception {        System.out.println("保存的对象是："+model);        response.setContentType("text/html");        response.getWriter().write("欢迎加入马士兵教育");    }    /**     * 返回数据内容的类型     * @return     */    public String getContentType() {        return "text/html";    }}
```

springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">    <context:component-scan base-package="com.mashibing"></context:component-scan>    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">        <property name="prefix" value="/WEB-INF/page/"></property>        <property name="suffix" value=".jsp"></property>    </bean>    <bean class="com.mashibing.view.MyViewResolver">        <property name="order" value="1"></property>    </bean></beans>
```

### （3）自定义类型转换器

在日常的企业开发需求中，我们输入文本框的内容全部都是字符串类型，但是在后端处理的时候我们可以用其他基本类型来接受数据，也可以使用实体类来接受参数，这个是怎么完成的呢？就是通过SpringMVC提供的类型转换器，SpringMVC内部提供了非常丰富的类型转换器的支持，但是有些情况下有可能难以满足我们的需求，因此需要我们自己实现，如下：

![image-20200312211944841](image\类型转换器.png)

User.java

```java
package com.mashibing.bean;public class User {    private Integer id;    private String name;    private Integer age;    private String gender;    public User() {    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    @Override    public String toString() {        return "User{" +                "id=" + id +                ", name='" + name + '\'' +                ", age=" + age +                ", gender='" + gender + '\'' +                '}';    }}
```

MyConverter.java

```java
package com.mashibing.converter;

import com.mashibing.bean.User;
import org.springframework.core.convert.converter.Converter;
import org.springframework.stereotype.Component;

@Component
public class MyConverter implements Converter<String, User> {
    public User convert(String source) {
        User user = null;
        String[] split = source.split("-");
        if (source!=null && split.length==4){
            user = new User();
            user.setId(Integer.parseInt(split[0]));
            user.setName(split[1]);
            user.setAge(Integer.parseInt(split[2]));
            user.setGender(split[3]);
        }
        return user;
    }
}
```

UserController.java

```java
package com.mashibing.controller;

import com.mashibing.bean.User;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class UserController {

    @RequestMapping("/user")
    public String add(User user, Model model){
        System.out.println(user);
        model.addAttribute("user","user");
        return "success";
    }
}
```

success.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: root
  Date: 2020/3/12
  Time: 21:36
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
${requestScope.user}
</body>
</html>

```

springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"

       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <context:component-scan base-package="com.mashibing"></context:component-scan>
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/page/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>
    <bean class="com.mashibing.view.MyViewResolver">
        <property name="order" value="1"></property>
    </bean>
    <mvc:annotation-driven conversion-service="conversionService"></mvc:annotation-driven>
    <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
        <property name="converters">
            <set>
                <ref bean="myConverter"></ref>
            </set>
        </property>
    </bean>
</beans>
```

### （4）自定义日期格式化转换器

有时候我们经常需要在页面添加日期等相关信息，此时需要制定日期格式化转换器，此操作非常简单：只需要在单独的属性上添加@DateTimeFormat注解即可，制定对应的格式

User.java

```java
package com.mashibing.bean;

import org.springframework.format.annotation.DateTimeFormat;

import java.util.Date;

public class User {

    private Integer id;
    private String name;
    private Integer age;
    private String gender;
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private Date birth;

    public User() {
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public Date getBirth() {
        return birth;
    }

    public void setBirth(Date birth) {
        this.birth = birth;
    }

    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", gender='" + gender + '\'' +
                ", birth=" + birth +
                '}';
    }
}
```

index.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %><html>  <head>    <title>$Title$</title>  </head>  <body><form action="dateConvertion" method="post">  编号：<input type="text" name="id"><br>  姓名：<input type="text" name="name"><br>  年龄：<input type="text" name="age"><br>  性别：<input type="text" name="gender"><br>  日期：<input type="text" name="birth"><br>  <input type="submit" value="提交"></form>  </body></html>
```

DateConvertionController.java

```java
package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class DateConvertionController {    @RequestMapping("dateConvertion")    public String dateConvertion(User user){        System.out.println(user);        return "hello";    }}
```

springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:mvc="http://www.springframework.org/schema/mvc"       xsi:schemaLocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">    <context:component-scan base-package="com.mashibing"></context:component-scan>    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">        <property name="prefix" value="/WEB-INF/page/"></property>        <property name="suffix" value=".jsp"></property>    </bean>    <bean class="com.mashibing.view.MyViewResolver">        <property name="order" value="1"></property>    </bean>    <!--此配置表示  我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理    静态资源可以访问，但是动态请求无法访问    -->    <mvc:default-servlet-handler/>    <!--保证静态资源和动态请求都能够访问-->    <mvc:annotation-driven></mvc:annotation-driven></beans>
```

此时运行发现是没有问题的，但是需要注意的是，如果同时配置了自定义类型转换器之后，那么日期格式转化是有问题的。

springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:mvc="http://www.springframework.org/schema/mvc"       xsi:schemaLocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">    <context:component-scan base-package="com.mashibing"></context:component-scan>    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">        <property name="prefix" value="/WEB-INF/page/"></property>        <property name="suffix" value=".jsp"></property>    </bean>    <bean class="com.mashibing.view.MyViewResolver">        <property name="order" value="1"></property>    </bean>    <!--此配置表示  我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理    静态资源可以访问，但是动态请求无法访问    -->    <mvc:default-servlet-handler/>    <!--保证静态资源和动态请求都能够访问-->    <mvc:annotation-driven conversion-service="conversionService"></mvc:annotation-driven>    <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">        <property name="converters">            <set>                <ref bean="myConverter"></ref>            </set>        </property>    </bean></beans>
```

原因就在于ConversionServiceFactoryBean对象中有且仅有一个属性converters，此时可以使用另外一个类来做替换FormattingConversionServiceFactoryBean

springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"

       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <context:component-scan base-package="com.mashibing"></context:component-scan>
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/page/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>
    <bean class="com.mashibing.view.MyViewResolver">
        <property name="order" value="1"></property>
    </bean>
    <!--此配置表示  我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理
    静态资源可以访问，但是动态请求无法访问
    -->
    <mvc:default-servlet-handler/>
    <!--保证静态资源和动态请求都能够访问-->
<!--    <mvc:annotation-driven></mvc:annotation-driven>-->
    <mvc:annotation-driven conversion-service="conversionService"></mvc:annotation-driven>
    <bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
        <property name="converters">
            <set>
                <ref bean="myConverter"></ref>
            </set>
        </property>
    </bean>
</beans>
```

### （5）数据校验

一般情况下我们会在前端页面实现数据的校验，但是大家需要注意的是前端校验会存在数据的不安全问题，因此一般情况下我们都会使用前端校验+后端校验的方式，这样的话既能够满足用户的体验度，同时也能保证数据的安全，下面来说一下在springmvc中如何进行后端数据校验。

JSR303是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中 。JSR 303 (Java Specification Requests意思是Java 规范提案)通过**在** **Bean** **属性上标注**类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证。

JSR303:

![](image\JSR303.png)

Hibernate Validator 扩展注解:

![](image\hibernate.png)

spring中拥有自己的数据校验框架，同时支持JSR303标准的校验框架，可以在通过添加注解的方式进行数据校验。在spring中本身没有提供JSR303的实现，需要导入依赖的包。

pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">    <modelVersion>4.0.0</modelVersion>    <groupId>com.mashibing</groupId>    <artifactId>springmvc_viewResolver</artifactId>    <version>1.0-SNAPSHOT</version>    <dependencies>        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->        <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-context</artifactId>            <version>5.2.3.RELEASE</version>        </dependency>        <!-- https://mvnrepository.com/artifact/org.springframework/spring-web -->        <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-web</artifactId>            <version>5.2.3.RELEASE</version>        </dependency>        <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->        <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-webmvc</artifactId>            <version>5.2.3.RELEASE</version>        </dependency>        <dependency>            <groupId>javax.servlet</groupId>            <artifactId>servlet-api</artifactId>            <version>2.5</version>            <scope>provided</scope>        </dependency>        <dependency>            <groupId>javax.servlet</groupId>            <artifactId>jsp-api</artifactId>            <version>2.0</version>            <scope>provided</scope>        </dependency>        <dependency>            <groupId>org.hibernate</groupId>            <artifactId>hibernate-validator</artifactId>            <version>5.1.0.Final</version>        </dependency>    </dependencies></project>
```

index.jsp

```jsp
<%--  Created by IntelliJ IDEA.  User: root  Date: 2020/3/12  Time: 15:23  To change this template use File | Settings | File Templates.--%><%@ page contentType="text/html;charset=UTF-8" language="java" %><html>  <head>    <title>$Title$</title>  </head>  <body><form action="dataValidate" method="post">  编号：<input type="text" name="id"><br>  姓名：<input type="text" name="name"><br>  年龄：<input type="text" name="age"><br>  性别：<input type="text" name="gender"><br>  日期：<input type="text" name="birth"><br>  邮箱：<input type="text" name="email"><br>  <input type="submit" value="提交"></form>  </body></html>
```

DataValidateController.java

```java
package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.RequestMapping;import javax.validation.Valid;@Controllerpublic class DataValidateController {    @RequestMapping("/dataValidate")    public String validate(@Valid User user, BindingResult bindingResult) {        System.out.println(user);        if (bindingResult.hasErrors()) {            System.out.println("验证失败");            return "redirect:/index.jsp";        } else {            System.out.println("验证成功");            return "hello";        }    }}
```

User.java

```java
package com.mashibing.bean;import org.hibernate.validator.constraints.Email;import org.hibernate.validator.constraints.Length;import org.springframework.format.annotation.DateTimeFormat;import javax.validation.constraints.NotNull;import javax.validation.constraints.Past;import java.util.Date;public class User {    private Integer id;    @NotNull    @Length(min = 5,max = 10)    private String name;    private Integer age;    private String gender;    @Past    @DateTimeFormat(pattern = "yyyy-MM-dd")    private Date birth;    @Email    private String email;    public User() {    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }    public Date getBirth() {        return birth;    }    public void setBirth(Date birth) {        this.birth = birth;    }    public String getEmail() {        return email;    }    public void setEmail(String email) {        this.email = email;    }    @Override    public String toString() {        return "User{" +                "id=" + id +                ", name='" + name + '\'' +                ", age=" + age +                ", gender='" + gender + '\'' +                ", birth=" + birth +                ", email='" + email + '\'' +                '}';    }}
```

此时大家发现在报错的地方无法出现错误提示，可以换另外一种方式：

index.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %><html>  <head>    <title>$Title$</title>  </head>  <body><a href="add">添加用户</a>  </body></html>
```

add.jsp

```jsp
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %><%@ page contentType="text/html;charset=UTF-8" language="java" %><html><head>    <title>$Title$</title></head><body><form:form action="dataValidate"  modelAttribute="user" method="post">    id:<form:input path="id"></form:input><form:errors path="id"></form:errors> <br/>    name:<form:input path="name"></form:input><form:errors path="name"></form:errors><br/>    age:<form:input path="age"></form:input><form:errors path="age"></form:errors><br/>    gender:<form:input path="gender"></form:input><form:errors path="gender"></form:errors><br/>    birth:<form:input path="birth"></form:input><form:errors path="birth"></form:errors><br/>    email:<form:input path="email"></form:input><form:errors path="email"></form:errors><br/>    <input type="submit" value="submit"></form:form></body></html>
```

DataValidateController.java

```java
package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.RequestMapping;import javax.validation.Valid;@Controllerpublic class DataValidateController {    @RequestMapping("/dataValidate")    public String validate(@Valid User user, BindingResult bindingResult, Model model) {        System.out.println(user);        if (bindingResult.hasErrors()) {            System.out.println("验证失败");            return "add";        } else {            System.out.println("验证成功");            return "hello";        }    }    @RequestMapping("add")    public String add(Model model){        model.addAttribute("user",new User(1,"zhangsan",12,"女",null,"1234@qq.com"));        return "add";    }}
```

web.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"         version="4.0">    <listener>        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>    </listener>    <context-param>        <param-name>contextConfigLocation</param-name>        <param-value>classpath:springmvc.xml</param-value>    </context-param>    <servlet>        <servlet-name>springmvc</servlet-name>        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>        <init-param>            <param-name>contextConfigLocation</param-name>            <param-value>classpath:springmvc.xml</param-value>        </init-param>            </servlet>    <servlet-mapping>        <servlet-name>springmvc</servlet-name>        <url-pattern>/</url-pattern>    </servlet-mapping>    <filter>        <filter-name>encoding</filter-name>        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>        <init-param>            <param-name>encoding</param-name>            <param-value>UTF-8</param-value>        </init-param>        <init-param>            <param-name>forceEncoding</param-name>            <param-value>true</param-value>        </init-param>    </filter>    <filter-mapping>        <filter-name>encoding</filter-name>        <url-pattern>/*</url-pattern>    </filter-mapping></web-app>
```

原生的表单如何获取错误信息：

DataValidateController.java

```java
package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.bind.annotation.RequestMapping;import javax.validation.Valid;import java.util.HashMap;import java.util.List;import java.util.Map;@Controllerpublic class DataValidateController {    @RequestMapping("/dataValidate")    public String validate(@Valid User user, BindingResult bindingResult, Model model) {        System.out.println(user);        Map<String,Object> errorsMap = new HashMap<String, Object>();        if (bindingResult.hasErrors()) {            System.out.println("验证失败");            List<FieldError> fieldErrors = bindingResult.getFieldErrors();            for (FieldError fieldError : fieldErrors) {                System.out.println(fieldError.getDefaultMessage());                System.out.println(fieldError.getField());                errorsMap.put(fieldError.getField(),fieldError.getDefaultMessage());            }            model.addAttribute("errorInfo",errorsMap);            return "add";        } else {            System.out.println("验证成功");            return "hello";        }    }    @RequestMapping("add")    public String add(Model model){        model.addAttribute("user",new User(1,"zhangsan",12,"女",null,"1234@qq.com"));        return "add";    }}
```

add.jsp

```jsp
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %><%@ page contentType="text/html;charset=UTF-8" language="java" %><html><head>    <title>$Title$</title></head><body><form:form action="dataValidate"  modelAttribute="user" method="post">    编号:<form:input path="id"></form:input><form:errors path="id"></form:errors>--->${errorInfo.id} <br/>    姓名:<form:input path="name"></form:input><form:errors path="name"></form:errors>--->${errorInfo.name}<br/>    年龄:<form:input path="age"></form:input><form:errors path="age"></form:errors>--->${errorInfo.age}<br/>    性别:<form:input path="gender"></form:input><form:errors path="gender"></form:errors>--->${errorInfo.gender}<br/>    生日:<form:input path="birth"></form:input><form:errors path="birth"></form:errors>--->${errorInfobirth}<br/>    邮箱:<form:input path="email"></form:input><form:errors path="email"></form:errors>--->${errorInfo.email}<br/>    <input type="submit" value="submit"></form:form></body></html>
```



# 源码链接
该文章源码链接 [Github](url)