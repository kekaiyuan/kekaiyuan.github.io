---
layout: post
title: Java 学习笔记之 11 —— 线程池
categories: Java
description: Java 学习笔记之 11 —— 线程池
keywords: Java
---
# 序言


为什么需要线程池？

在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。<br>
因此，在大多数并发框架中都会使用线程池来管理线程，使用线程池管理线程主要有如下好处：
1. 使用线程池可以重复利用已有的线程继续执行任务，避免线程在创建和销毁时造成的消耗。
2. 由于没有线程创建和销毁时的消耗，可以提高系统响应速度。
3. 通过线程可以对线程进行合理的管理，根据系统的承受能力调整可运行线程数量的大小等。

# 工作原理

![image](/images/posts/java/javase/11-threadpool/theory2.png)

线程池执行所提交的任务过程：
1. 先判断线程池中核心线程池所有的线程是否都在执行任务。如果不是，则新创建一个线程执行刚提交的任务，否则，核心线程池中所有的线程都在执行任务，则进入第2步；
2. 判断当前阻塞队列是否已满，如果未满，则将提交的任务放置在阻塞队列中；否则，则进入第3步；
3. 判断线程池中所有的线程是否都在执行任务，如果没有，则创建一个新的线程来执行任务，否则，则交给饱和策略进行处理


# 线程池的分类
![image](/images/posts/java/javase/11-threadpool/category.png)

- newCachedThreadPool
	- 线程池的大小不是固定的，最大可达到 `Integer.MAX_VALUE`。
	- 线程池中的线程存活时间很短，只有 60 秒。
	- 当线程池中没有可用线程时就创建新线程。
- newFixedThreadPool
	- 固定大小。
	- 除非被显式关闭，否则池中的线程一直存在。
	- 多余的线程将在 LinkedBlockingQueue 中等待。
- newSingleThreadExecutor
	- 只有一个工作线程。
	- LinkedBlockingQueue
- newScheduledThreadPool
	- 线程池中的线程数量有一个初始值。<br>
		任意时间都不会低于初始值，即使线程是空闲的。
	- 可定时或延迟地执行线程活动。
- newWorkStealingPool
	- 创建一个带并行级别的线程池，并行级别决定了同一时刻最多有多少个线程在执行。<br>
		默认情况下并行级别为当前系统的 CPU 个数。



# 线程池的生命周期

<div class="mermaid">
graph LR;
A(Running) --"shutdown()"--> B1(SHUTDOWN)
A --"shutdownNow()"--> B2(STOP)
</div>


线程池的生命周期
.RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务；
.SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。
.STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。
.TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用terminated() 方法进入TERMINATED 状态。
.TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。

线程池只有两种状态： running 和 terminated ，在这两个状态之间有三种过渡状态


线程池的创建
注意：一定要掌握各个参数的具体含义


参数说明
.corePoolSize：核心线程池的大小
.maximumPoolSize：线程池能创建线程的最大个数
.keepAliveTime：空闲线程存活时间
.unit：时间单位，为keepAliveTime指定时间单位
.workQueue：阻塞队列，用于保存任务的阻塞队列
.threadFactory：创建线程的工程类
.handler：饱和策略（拒绝策略）


# 阻塞队列
- ArrayBlockingQueue
	- 基于数组实现。<br>
		用一个定长数组维护队列中的数据对象。<br>
		还保存了两个整形变量标识着队列的头部和尾部在数组中的位置。
	- 只有一个锁。<br>
		生产者和消费者无法真正并行运行。
	- 在构造时也选择公平锁或非公平锁。	
- LinkedBlockingQueue
	- 基于链表实现。
	- 生产者一般不会被阻塞，除非队列已满（默认为 `Integer.MAX_VALUE`）。
	- 生产者和消费者用的是两把锁，并发度更高。
- DelayQueue
	- 一般很特殊的队列，使用场景较少。
	- 队列中的元素只有当其指定的延迟时间到了，才能被取出。
	- 没有大小限制。<br>
		生产者永远不会被阻塞。<br>
		只有消费者会被阻塞。
- PriorityBlockingQueue
	- 基于优先级（通过构造函数传入的 Comparator 对象决定）的阻塞队列。
	- 不会阻塞生产者，只会阻塞消费者。<br>
		所以要注意生产速度，否则会耗尽堆空间。
	- 使用公平锁。
- SynchronousQueue
	- 与之前的阻塞队列不同，它没有缓冲区。<br>
		所以生产者和消费者很容易被阻塞（不能把数据丢进缓冲区就跑），必须找到对应的对象进行“交易”。
	- 吞吐量会降低，但响应速度可以会变快。
	- 公平模式：
		- 使用公平锁和 FIFO 队列维护生产者和消费者。
	- 非公平模式：
		- 使用非公平锁和 LIFO 队列维护生产者和消费者。
		- 会发生“饿死”（某些生产者或消费者永远等不到处理）。
- 面试常问：ArrayBlockingQueue 和 LinkedBlockingQueue 的区别：
	- ArrayBlockingQueue 的消费者和生产者共有同一个锁。<br>
		LinkedBlockingQueue 的消费者和生产者使用分离锁。
	- ArrayBlockingQueue 必须指定大小（因为是数组）。<br>
		LinkedBlockingQueue 可以不指定队列大小，默认下 `Integer.MAX_VALUE`。


# 拒绝策略

拒绝策略
.ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
.ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
.ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
.ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务


execute方法执行逻辑


execute方法执行逻辑
.如果当前运行的线程少于corePoolSize，则会创建新的线程来执行新的任务；
.如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中；
.如果当前workQueue队列已满的话，则会创建新的线程来执行任务；
.如果线程个数已经超过了maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来进行处理。


Executor和Submit
.submit是基方法Executor.execute(Runnable)的延伸，通过创建并返回一个Future类对象可用于取消执行和/或等待完成。


线程池的关闭
.关闭线程池，可以通过shutdown和shutdownNow两个方法
.原理：遍历线程池中的所有线程，然后依次中断
.1、shutdownNow首先将线程池的状态设置为STOP,然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表；
.2、shutdown只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程


启动线程的方式：
1. Thread
2. Runnable
3. Lambda 表达式
4. Executors.newCachedThread