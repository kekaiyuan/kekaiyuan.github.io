

[
  
  
    {
      "title"    : "页面没有找到",
      "url"      : "https://kekaiyuan.github.io//404.html",
      "keywords" : "404"
    } ,
  
  
  
    {
      "title"    : "About",
      "url"      : "https://kekaiyuan.github.io//about/",
      "keywords" : "Zhuang Ma, 马壮"
    } ,
  
  
  
    {
      "title"    : "归档",
      "url"      : "https://kekaiyuan.github.io//archives/",
      "keywords" : "归档"
    } ,
  
  
  
    {
      "title"    : "Categories",
      "url"      : "https://kekaiyuan.github.io//categories/",
      "keywords" : "分类"
    } ,
  
  
  
  
  
    {
      "title"    : "Links",
      "url"      : "https://kekaiyuan.github.io//links/",
      "keywords" : "友情链接"
    } ,
  
  
  
    {
      "title"    : "mindmap",
      "url"      : "https://kekaiyuan.github.io//mindmap-viewer/",
      "keywords" : "mindmap"
    } ,
  
  
  
    {
      "title"    : "Open Source Projects",
      "url"      : "https://kekaiyuan.github.io//open-source/",
      "keywords" : "开源,open-source,GitHub,开源项目"
    } ,
  
  
  
  
  
    {
      "title"    : "Wiki",
      "url"      : "https://kekaiyuan.github.io//wiki/",
      "keywords" : "维基, Wiki"
    } ,
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
    {
      "title"    : "关于 Markdown 的一些奇技淫巧",
      "category" : "Markdown",
      "content": "自从几年前开始在 GitHub 玩耍，接触到 Markdown 之后，就一发不可收拾，在各种文档编辑上，有条件用 Markdown 的尽量用，不能用的创造条件也要用——README、博客、公众号、接口文档等等全都是，比如当前这篇文章就是用 Markdown 编辑而成。 这几年也发现越来越多的网站和程序提供了对 Markdown 的支持，从最初接触的 GitHub、Jekyll，到简书、掘金、CSDN 等等，由此也从别人做得好的文档中，学到了一些『奇技淫巧』，所以本文不是对 Markdown 基础语法的介绍，而是一些相对高级、能将 Markdown 玩出更多花样的小技巧。 注：如下技巧大多是利用 Markdown 兼容部分 HTML 标签的特性来完成，不一定在所有网站和软件里都完全支持，主要以 GitHub 支持为准。 在表格单元格里换行 借助于 HTML 里的 &lt;br /&gt; 实现。 示例代码： | Header1 | Header2     | |---------|----------------------------------| | item 1 | 1. one&lt;br /&gt;2. two&lt;br /&gt;3. three | 示例效果：    Header1  Header2     item 1  1. one2. two3. three   图文混排 使用 &lt;img&gt; 标签来贴图，然后指定 align 属性。 示例代码： &lt;img align=right src=https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/markdown/demo.png/&gt; 这是一个示例图片。 图片显示在 N 段文字的右边。 N 与图片高度有关。 刷屏行。 刷屏行。 到这里应该不会受影响了，本行应该延伸到了图片的正下方，所以我要足够长才能确保不同的屏幕下都看到效果。 示例效果： 这是一个示例图片。 图片显示在 N 段文字的右边。 N 与图片高度有关。 刷屏行。 刷屏行。 到这里应该不会受影响了，本行应该延伸到了图片的正下方，所以我要足够长才能确保不同的屏幕下都看到效果。 控制图片大小和位置 标准的 Markdown 图片标记 ![]() 无法指定图片的大小和位置，只能依赖默认的图片大小，默认居左。 而有时候源图太大想要缩小一点，或者想将图片居中，就仍需要借助 HTML 的标签来实现了。图片居中可以使用 &lt;div&gt; 标签加 align 属性来控制，图片宽高则用 width 和 height 来控制。 示例代码： **图片默认显示效果：** ![](https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/markdown/demo.png) **加以控制后的效果：** &lt;div align=center&gt;&lt;img width=65 height=75 src=https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/markdown/demo.png/&gt;&lt;/div&gt; 示例效果： 图片默认显示效果： 加以控制后的效果： 格式化表格 表格在渲染之后很整洁好看，但是在文件源码里却可能是这样的： |Header1|Header2| |---|---| |a|a| |ab|ab| |abc|abc| 不知道你能不能忍，反正我是不能忍。 好在广大网友们的智慧是无穷的，在各种编辑器里为 Markdown 提供了表格格式化功能，比如我使用 Vim 编辑器，就有 vim-table-mode 插件，它能帮我自动将表格格式化成这样： | Header1 | Header2 | |---------|---------| | a  | a  | | ab | ab | | abc  | abc  | 是不是看着舒服多了？ 如果你不使用 Vim，也没有关系，比如 Atom 编辑器的 markdown-table-formatter 插件，Sublime Text 3 的 MarkdownTableFormatter 等等，都提供了类似的解决方案。 使用 Emoji 这个是 GitHub 对标准 Markdown 标记之外的扩展了，用得好能让文字生动一些。 示例代码： 我和我的小伙伴们都笑了。:smile: 示例效果： 我和我的小伙伴们都笑了。:smile: 更多可用 Emoji 代码参见 https://www.webpagefx.com/tools/emoji-cheat-sheet/。 行首缩进 直接在 Markdown 里用空格和 Tab 键缩进在渲染后会被忽略掉，需要借助 HTML 转义字符在行首添加空格来实现，&amp;ensp; 代表半角空格，&amp;emsp; 代表全角空格。 示例代码： &amp;emsp;&amp;emsp;春天来了，又到了万物复苏的季节。 示例效果：   春天来了，又到了万物复苏的季节。 展示数学公式 如果是在 GitHub Pages，可以参考 http://wanguolin.github.io/mathmatics_rending/ 使用 MathJax 来优雅地展示数学公式（非图片）。 如果是在 GitHub 项目的 README 等地方，目前我能找到的方案只能是贴图了，以下是一种比较方便的贴图方案：  在 https://www.codecogs.com/latex/eqneditor.php 网页上部的输入框里输入 LaTeX 公式，比如 $$x=  frac{-b  pm  sqrt{b^2-4ac}}{2a}$$；   在网页下部拷贝 URL Encoded 的内容，比如以上公式生成的是 https://latex.codecogs.com/png.latex?%24%24x%3D%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D%24%24；    在文档需要的地方使用以上 URL 贴图，比如 ![](https://latex.codecogs.com/png.latex?%24%24x%3D%5Cfrac%7B-b%5Cpm%5Csqrt%7Bb%5E2-4ac%7D%7D%7B2a%7D%24%24)   示例效果：  任务列表 在 GitHub 和 GitLab 等网站，除了可以使用有序列表和无序列表外，还可以使用任务列表，很适合要列出一些清单的场景。 示例代码： **购物清单** - [ ] 一次性水杯 - [x] 西瓜 - [ ] 豆浆 - [x] 可口可乐 - [ ] 小茗同学 示例效果： 购物清单  一次性水杯 西瓜 豆浆 可口可乐 小茗同学 自动维护目录 有时候维护一份比较长的文档，希望能够自动根据文档中的标题生成目录（Table of Contents），并且当标题有变化时自动更新目录，能减轻工作量，也不易出错。 如果你使用 Vim 编辑器，那可以使用我维护的插件 vim-markdown-toc 来帮你完美地解决此事： 插件地址：https://github.com/mzlogin/vim-markdown-toc 如果你使用其它编辑器，一般也能找到对应的解决方案，比如 Atom 编辑器的 markdown-toc 插件，Sublime Text 的 MarkdownTOC 插件等。 后话 好了，这一波的奇技淫巧就此告一段落，希望大家在了解这些之后能有所收获，更好地排版，专注写作。 如果你觉得本文对你有帮助，欢迎关注我的微信公众号 isprogrammer，获取更多有帮助的内容。 参考  https://raw.githubusercontent.com/matiassingers/awesome-readme/master/readme.md https://www.zybuluo.com/songpfei/note/247346 ",
      "url"      : "https://kekaiyuan.github.io//2017/09/01/markdown-odd-skills/",
      "keywords" : "Markdown, 奇技淫巧"
    } ,
  
    {
      "title"    : "一份简明的 Markdown 笔记与教程",
      "category" : "Markdown",
      "content": "为部门内知识分享准备的素材，记录了 Markdown 的优点、应用场景和编辑工具，介绍了标准语法与扩展语法，以及一些应用 Markdown 的奇技淫巧。个人使用 Markdown 的经验持续补充中，最新完整版请参见 https://github.com/mzlogin/markdown-intro 自从 2014 年左右接触到 Markdown 以来，对它的使用就一发而不可收拾。从最开始使用它在 GitHub Pages 里写博客，到用它编辑项目的 README 文件，再到撰写开发文档，编辑微信公众号文章和邮件内容等等，这期间也见证了它在各类平台和网站上的普及和被原生支持，可以说，Markdown 如今已经渗透了我在技术和网络活动的方方面面，成为了我撰写文本文档的首选。 那么首先我们一起来看一下它的「定义」：  Markdown 是一种轻量级标记语言，创始人为 John Gruber。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档」。——维基百科 本文档的目的不在于面面俱到地介绍 Markdown，只是作为我对其理解的笔记整理，希望能同时帮助一些对 Markdown 感兴趣的人快速上手，或是作为一个工具，供对其已经有所了解的人在需要时参考。 接下来请随我一起深入了解这门并不神秘的实用标记语言。 目录  背景  优点  使用场景  编辑工具   语法  标题  段落  行内格式  引用块  超链接  图片  列表  代码块  水平分割线  嵌入 HTML   扩展语法  表格  任务列表  删除线  自动链接  emoji   奇技淫巧  画流程图和时序图  插入数学公式  用 Markdown 做 PPT  用 Markdown 写微信公众号  更多   参考  背景 优点  专注于文字内容；   纯文本，易读易写，可以方便地纳入版本控制；   语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。 使用场景  各类代码托管平台 主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。   技术社区和写作平台 StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记   论坛 V2EX、光谷社区 个人感觉比较遗憾的一点是各平台可能采用不同语言实现的 Markdown 解析引擎，或采用同一解析引擎的不同版本，而且可能有不同程度的定制与扩展，这导致在不同平台上使用 Markdown 写作时体验并不完全一致。不过幸好对于大家公认的一些标准语法，各家都是支持的。 编辑工具 理论上任何一款文本编辑器都能用于编辑 Markdown 文档，它们分别提供了不同程度的语法高亮、预览等功能，以下只是列举其中一部分，选择自己称手的即可。  现代编辑器 VSCode / Atom   传统编辑器 Vim / Emacs / Sublime Text / Notepad++   IDE 自带编辑器 IntelliJ IDEA / Android Studio / WebStorm   专用编辑器 Ulysses / Mou / Typora / Markpad   在线编辑器 各种支持 Markdown 的网站都提供了在线编辑器 语法 标题 Markdown： # atx-style 一级标题 ## 二级标题 ###### 六级标题 Setext-style 一级标题 === 二级标题 --- 预览效果：  atx-style 一级标题 二级标题 六级标题 Setext-style 一级标题 二级标题 对应 HTML： &lt;h1&gt;atx-style 一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; &lt;h6&gt;六级标题&lt;/h6&gt; &lt;h1&gt;Setext-style 一级标题&lt;/h1&gt; &lt;h2&gt;二级标题&lt;/h2&gt; 段落 中间没有空行的连续不断的几行文字被视为一个段落。 Markdown： 白日依山尽， 黄河入海流。 （句号后面没空格） 欲穷千里目， 更上一层楼。 （句号后面有俩空格） 预览效果： 白日依山尽， 黄河入海流。 （句号后面没空格） 欲穷千里目， 更上一层楼。 （句号后面有俩空格） 对应 HTML： &lt;p&gt;白日依山尽，&lt;/p&gt; &lt;p&gt;黄河入海流。 （句号后面没有空格）&lt;/p&gt; &lt;p&gt;欲穷千里目，&lt;/p&gt; &lt;p&gt; 更上一层楼。 &lt;br&gt; （句号后面有俩空格） &lt;/p&gt; 行内格式 对段落或者部分文本的强调效果。 Markdown： 后面俩字**加黑** 后面俩字*斜体* 预览效果： 后面俩字加黑 后面俩字斜体 对应 HTML： &lt;p&gt; 后面俩字 &lt;strong&gt;加黑&lt;/strong&gt; &lt;/p&gt; &lt;p&gt; 后面俩字 &lt;em&gt;斜体&lt;/em&gt; &lt;/p&gt; 引用块 Markdown： &gt; 引用块段落一。 &gt; &gt; 引用块段落二。 &gt;&gt; 内嵌引用块段落一。 &gt; &gt; ### 引用块内的标题 预览效果：  引用块段落一。 引用块段落二。  内嵌引用块段落一。  引用块内的标题 对应 HTML： &lt;blockquote&gt; &lt;p&gt;引用块段落一。&lt;/p&gt; &lt;p&gt;引用块段落二。&lt;/p&gt; &lt;blockquote&gt;  &lt;p&gt;内嵌引用块段落一。&lt;/p&gt; &lt;/blockquote&gt; &lt;h3 id=引用块内的标题&gt;引用块内的标题&lt;/h3&gt; &lt;/blockquote&gt; 超链接 Markdown 支持行内式链接和引用式链接。 Markdown： 行内式 [博客](https://mazhuang.org 我的个人博客) 链接，带 title。 行内式 [GitHub](https://github.com/mzlogin) 链接。 引用式 [博客][1] 链接。 引用式 [GitHub][2] 链接，带 title。 [1]: https://mazhuang.org [2]: https://github.com/mzlogin 我的 GitHub 主页 预览效果： 行内式 博客 链接，带 title。 行内式 GitHub 链接。 引用式 博客 链接。 引用式 GitHub 链接，带 title。 对应 HTML： &lt;p&gt;行内式 &lt;a href=https://mazhuang.org title=我的个人博客&gt;博客&lt;/a&gt; 链接，带 title。&lt;/p&gt; &lt;p&gt;行内式 &lt;a href=https://github.com/mzlogin&gt;GitHub&lt;/a&gt; 链接。&lt;/p&gt; &lt;p&gt;引用式 &lt;a href=https://mazhuang.org&gt;博客&lt;/a&gt; 链接。&lt;/p&gt; &lt;p&gt;引用式 &lt;a href=https://github.com/mzlogin title=我的 GitHub 主页&gt;GitHub&lt;/a&gt; 链接，带 title。&lt;/p&gt; 图片 在超链接的写法前加一个 !，就是引用图片的方法。 Markdown： ![Alt text](https://mazhuang.org/favicon.ico favicon) 预览效果： 对应 HTML： &lt;img src=https://mazhuang.org/favicon.ico alt=Alt text title=favicon&gt; 列表 包括有序列表和无序列表。 Markdown： - 苹果 - 葡萄 - 榴莲 1. 苹果 2. 葡萄 3. 榴莲 预览效果：  苹果 葡萄 榴莲 苹果 葡萄 榴莲 对应 HTML： &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;榴莲&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;榴莲&lt;/li&gt; &lt;/ol&gt; 其中无序列表的标记可以使用 +、- 或 *，有序列表前的数字可以是乱序的。 代码块 支持行内代码和代码块。 Markdown： Android 里使用 `TextUtils` 类的 `isEmpty` 方法来判断字符串是否为空。 ```java if (TextUtils.isEmpty(text)) {  return null; } ``` 预览效果： Android 里使用 TextUtils 类的 isEmpty 方法来判断字符串是否为空。 if (TextUtils.isEmpty(text)) {  return null; } 对应 HTML： &lt;p&gt;Android 里使用 &lt;code&gt;TextUtils&lt;/code&gt; 类的 &lt;code&gt;isEmpty&lt;/code&gt; 方法来判断字符串是否为空。&lt;/p&gt; &lt;div class=highlight highlight-source-java&gt;&lt;pre&gt;&lt;span class=pl-k&gt;if&lt;/span&gt; (&lt;span class=pl-smi&gt;TextUtils&lt;/span&gt;&lt;span class=pl-k&gt;.&lt;/span&gt;isEmpty(text)) {  &lt;span class=pl-k&gt;return&lt;/span&gt; &lt;span class=pl-c1&gt;null&lt;/span&gt;; }&lt;/pre&gt;&lt;/div&gt; 上例中的语言标记 java 可选填，可用于在编辑器和渲染后的效果里添加语法高亮。 块式代码也可以对整个代码段缩进四个空格，或一个 Tab 来实现。 水平分割线 使用一个单独行里的三个或以上 *、- 来生产一条水平分割线，它们之间可以有空格。 Markdown： *** ----- - - - 预览效果：  对应 HTML： &lt;hr /&gt; &lt;hr /&gt; &lt;hr /&gt; 嵌入 HTML Markdown 标记语言的目的不是替代 HTML，也不是发明一种更便捷的插入 HTML 标签的方式。它对应的只是 HTML 标签的一个很小的子集。 对于那些没有办法用 Markdown 语法来对应的 HTML 标签，直接使用 HTML 来写就好了。 扩展语法 本节的内容是介绍一些受到广泛支持的 Markdown 扩展语法。 表格 Markdown： | 编号 | 姓名（左） | 年龄（右） | 性别（中） | | ----- | :-------- | ---------: | :------: | | 0  | 张三  | 28  | 男  | | 1  | 李四  | 29  | 男  | 预览效果：    编号  姓名（左）  年龄（右）  性别（中）     0  张三  28  男    1  李四  29  男   对应 HTML： &lt;table&gt; &lt;thead&gt;  &lt;tr&gt;  &lt;th&gt;编号&lt;/th&gt;  &lt;th align=left&gt;姓名（左）&lt;/th&gt;  &lt;th align=right&gt;年龄（右）&lt;/th&gt;  &lt;th align=center&gt;性别（中）&lt;/th&gt;  &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;  &lt;tr&gt;  &lt;td&gt;0&lt;/td&gt;  &lt;td align=left&gt;张三&lt;/td&gt;  &lt;td align=right&gt;28&lt;/td&gt;  &lt;td align=center&gt;男&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;  &lt;td&gt;1&lt;/td&gt;  &lt;td align=left&gt;李四&lt;/td&gt;  &lt;td align=right&gt;29&lt;/td&gt;  &lt;td align=center&gt;男&lt;/td&gt;  &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 任务列表 在 GitHub / GitLab 里有较好的支持。 Markdown： - [x] 洗碗 - [ ] 清洗油烟机 - [ ] 拖地 预览效果：  洗碗 清洗油烟机 拖地 对应 HTML： &lt;ul class=contains-task-list&gt; &lt;li class=task-list-item&gt;&lt;input type=checkbox id= disabled= class=task-list-item-checkbox checked=&gt; 洗碗&lt;/li&gt; &lt;li class=task-list-item&gt;&lt;input type=checkbox id= disabled= class=task-list-item-checkbox&gt; 清洗油烟机&lt;/li&gt; &lt;li class=task-list-item&gt;&lt;input type=checkbox id= disabled= class=task-list-item-checkbox&gt; 拖地&lt;/li&gt; &lt;/ul&gt; 如果是在 GitHub / GitLab 的 Issue 里，会附赠任务完成比例提示效果： 还可以直接在网页上拖动调整顺序，勾选和取消勾选。 删除线 Markdown： 后面三个字打上~~删除线~~。 预览效果： 后面三个字打上删除线。 对应 HTML： &lt;p&gt;后面三个字打上&lt;del&gt;删除线&lt;/del&gt;。&lt;/p&gt; 自动链接 自动链接扩展，即：当识别到 URL，或用 &lt;、&gt; 包括的 URL 时，会自动为其生成 a 标签。 Markdown： https://github.com &lt;example@gmail.com&gt; 预览效果： https://github.com example@gmail.com 对应 HTML： &lt;p&gt;&lt;a href=https://github.com&gt;https://github.com&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=mailto:example@gmail.com&gt;example@gmail.com&lt;/a&gt;&lt;/p&gt; emoji 以 GitHub Pages 为例。 Markdown： :camel: :blush: :smile: 预览效果： :camel: :blush: :smile: 对应 HTML： &lt;p&gt; &lt;img class=emoji title=:camel: alt=:camel: src=https://assets-cdn.github.com/images/icons/emoji/unicode/1f42b.png height=20 width=20&gt; &lt;img class=emoji title=:blush: alt=:blush: src=https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png height=20 width=20&gt; &lt;img class=emoji title=:smile: alt=:smile: src=https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png height=20 width=20&gt; &lt;/p&gt; 奇技淫巧 脑洞清奇的工程师们还发掘了很多使用 Markdown 的方法，大部分都是引入第三方 JavaScript 插件来实现。对这部分我只做简述，对其中的部分功能比如作图等，还是推荐用专门的可视化工具去做。 画流程图和时序图 有部分网站和编辑器实现了对 Markdown 里流程图和时序图的支持，比如我们使用的项目管理工具 TAPD 的在线编辑器，还有 VSCode + 插件 Markdown Preview Enhanced 等。 以我们使用的项目管理工具 TAPD 的在线编辑器为例： 插入数学公式 仍然以 TAPD 为例： 应该是利用 JavaScript 支持了 LaTeX 公式语法。 用 Markdown 做 PPT 有专门的工具 Marp，另外使用 VSCode + 插件 Markdown Preview Enhanced 也可以实现。 用 Markdown 写微信公众号 可以将公众号素材用 Markdown 编辑好后，贴到在线排版工具以后，复制到公众号编辑器里即可。有多种页面主题和代码主题可选择。 我维护的工具地址：https://md.mazhuang.org 更多 想象力丰富的工程师们还扩展了很多基于 Markdown 的玩法，包括但不限于：  自动生成 / 更新 Table of Contents 流程图 / 时序图 制作幻灯片 集成 PlantUML / GraphViz 的能力 导出 HTML / PDF / 电子书 … 以上功能基本都可以用 VSCode + 插件 Markdown Preview Enhanced 实现。 另外可以参考我以前的一篇博客 关于 Markdown 的一些奇技淫巧。 参考  Markdown: Syntax - DARING FIREBALL Markdown - 维基百科 GitHub Flavored Markdown Spec 关于 Markdown 的一些奇技淫巧  欢迎关注我的微信公众号，接收 markdown-intro 最新动态。 ",
      "url"      : "https://kekaiyuan.github.io//2018/09/06/markdown-intro/",
      "keywords" : "Markdown, VSCode"
    } ,
  
    {
      "title"    : "Java 学习笔记之 02 ——数据类型和运算符",
      "category" : "Java",
      "content": "Java 学习笔记之 02 ——数据类型和运算符 标识符 作用  常量、变量、方法、类和包等的名称，类似于人的名称，用于标识某个特定的个体。   命名规则  必须以字母、下划线“_”、美元符号“$”开头。  其它部分可以是字母、下划线“_”、美元符“$”和数字的任意组合。  大小写敏感，长度无限制。  不可以是Java的关键字。    Java关键字是Java语言保留供内部使用的，是预先设置好的，有特殊意义的标识符。     注意    Java不采用通常语言使用的ASCII字符集，而是采用unicode这样的标准的国际字符集。   因此Java命名所使用的字母除了英文还包括汉字，但是不推荐使用汉字。     命名规范  所有命名做到见名知意  驼峰原则    除第一个单词外所有单词首字母大写     项目名    全部小写     变量、方法名、属性名：首字母小写，驼峰原则    run(),runRun(),age,ageNew,monthSalary     类名、接口名：首字母大写和驼峰原则    Man、GoodMan     常量名：大写+下划线    MAX_VALUE     属性文件.properties定义变量命名    object.a_b_c格式，全部小写，其中object是宿主，a_b_c多个单词下划线分开。   例：hibernate.cache.use_second_level_cache，hibernate.cache.provider_class，hibernate.cache.provider_configuration_file_resource_path     xml文件命名    全部小写，-符号是其xml的用途说明，类似applicationContext属习惯命名。比如springmvc-servlet.xml、workdesk-manager.xml、workdesk-servlet.xml、applicationContext-basic.xml等   xml里的内容多个字符间以-隔开，比如param-name，filter-mapping等。     普通文件命名(jsp,js,img等)和java普通变量规范相同。  属性文件properties    以下划线隔开：errors_zh_CN.properties，hibernate_test.properties     数据库命名：    表、字段命名全部大写，多个单词以_隔开。     包名    全小写     字符集 ASCII  英文字符集  1个字节   ISO8859-1  西欧字符集  1个字节   BIG5  台湾的大五码，表示繁体汉字  2个字节   GB2312  大陆使用最早、最广的简体中文字符集  2个字节   GBK  GB2312的扩展，可以表示繁体中文  2个字节   GB18030  最新GBK的扩展，可以表示汉字、维吾尔文、藏文等中华民族字符  2个字节   Unicode  国际通用字符集  2个字节   Java数据类型 Java是一种强类型语言  常量是有数据类型的  变量都必须声明其数据类型。   整型常量  十进制整数  99,-500,0   八进制整数  以0开头，如：015   十六进制整数  0x或0X开头，如：0x15   整型常量默认为int型，声明long型常量可以后加‘l’或‘L‘，推荐使用大写，便于与数字1区分 浮点型  float类型  单精度，尾数到小数点后7位数，大多数情况下精度不够   double类型  双精度，精度是float的双倍，推荐使用   浮点型默认为double类型，要变为float，需在后面添加f/F，如3.14f/3.14F 浮点数存在舍入误差，很多数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。 字符数据类型 2个字节 单引号用来表示字符常量，双引号表示字符串  ‘A’是一个字符  “A”是含有一个字符的字符串   char类型用来表示在Unicode编码表中的字符  Unicode编码被设计用来处理各种语言的所有文字，它占2个字节，可允许有65536个字符；ASCII码占1个字节，可允许有128个字符（最高位是0），是Unicode编码表中前128个字符。   使用转义字符‘  ’来将其后的字符转变为其它的含义  char类型在内存中存储的是该字符的Unicode编码值，所以char类型可以当做int类型来处理 布尔数据类型 一位，不是一个字节 boolean类型只有两个值，true和false，用来判断逻辑条件，控制程序流程 常量和变量 常量  运行中值不会发生改变的数据   变量  运行中值会发生改变的数据  使用final修饰的变量值不可更改，变成了常量   运算符 java支持以下运算符  算术运算符:+，-，*，/，%，++，–  赋值运算符:=  扩展赋值运算符:+=，-=，*=，/=  关系运算符:&lt;，&gt;，&gt;=，&lt;=，==，!=  逻辑运算符:&amp;&amp;，||，!  位运算符:&amp;，|，^，~，»，«，»&gt;  条件运算符:？：   算术运算符  二元运算符的类型提升  整数运算    如果两个操作数有一个为Long,则结果也为long   没有long时，结果为int。即使操作数全为shot,byte，结果也是int     浮点运算    如果两个操作数有一个为double,则结果为double.   只有两个操作数都是float,则结果才为float.     一元运算符 ++,--  赋值运算符 基本赋值运算符  =   扩展赋值运算符  算术运算符和赋值运算符结合   关系运算符 用于比较运算 结果为布尔值 逻辑运算符 逻辑运算符与布尔操作数一起使用，组成逻辑表达式 逻辑表达式的结果是布尔值 &amp;和&amp;&amp;的区别  &amp;    无论任何情况，“&amp;”两边的表达式都会参与计算     &amp;&amp;    当“&amp;&amp;”的左边为false，则将不会计算其右边的表达式。即左false则false     “|”和“||”的区别与“&amp;”和“&amp;&amp;”的区别类似。   位运算符 对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数 如果操作的对象是char、byte、short，位移动作发生前其值会自动晋升为int，运算结果也为int 条件运算符 语法格式  x ? y : z  唯一的三目运算符   执行过程  x 为 boolean 类型表达式  x为true，整个三目运算的结果为表达式 y 的值  x为false，整个三目运算的结果为表达式 z 的值   经常用来代替简单的if-else判断 a?b:c?d:e的返回值  该式应该这样看a?b:(c?d:e)  a为true，返回b  a为false，返回(c?d:e)的结果   运算符的优先级  赋值&lt;三目&lt;逻辑&lt;关系 &lt;算术&lt;单目 类型转换 在赋值运算或算术运算时，要求数据类型相同，否则要进行类型转换 转换方式  自动转换    左侧宽度&gt;右侧宽度     强制转换    左侧宽度&lt;右侧宽度     除boolean类型外，所有的基本数据类型因为各自的精度不同，赋值时都要考虑这个问题 算术运算时的转换  整型，浮点型，字符型数据可以混合运算。  运算中不同类型的数据先转化为同一类型，然后进行运算，转换从低级到高级。   ",
      "url"      : "https://kekaiyuan.github.io//2021/05/27/02-datatype-operator/",
      "keywords" : "Java"
    } ,
  
    {
      "title"    : "Java 学习笔记之 03 ——流程控制语句",
      "category" : "Java",
      "content": "Java 学习笔记之 03 ——流程控制语句 序言 流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。 其流程控制方式采用结构化程序设计中规定的三种基本流程结构， 即：顺序结构、分支结构和循环结构，如下图所示： 顺序结构 程序将按照从上往下的顺序逐条执行语句 选择结构 单分支 if语句对条件表达式进行一次测试，若测试为真，则执行下面的语句，否则跳过该语句 双分支 当条件表达式为真时，执行语句块1 否则，执行语句块2，也就是else部分。 多分支  if(布尔表达式1){  语句块1; }else if(布尔表达式2){  语句块2; }... else if(布尔表达式n){  语句块n; }else{  语句块n+1; }   逐条if语句进行判断  条件匹配，进入语句体  否则对if语句继续匹配   嵌套if结构   if (条件1) {  if (条件2) {   代码块1;  } else {   代码块2;  } } else {  代码块3; }   switch多值选择结构 根据表达式值的不同执行许多不同的操作  switch (表达式) {  case 值1:   语句序列;   [break];  case 值2:   语句序列;   [break];  ...  [default:   默认语句;] }   switch语句会根据表达式的值去匹配相等的case值，然后执行对应的语句序列，直到遇到第一个break  活用break，可以让switch语句更加流畅   若没有匹配的case值，则执行default语句（如果有的话） 只能处理等值判断，不能处理大于、小于这样的关系判断  表达式必须为byte，short，int或char类型，不能是String或 double，float  1.7之后可以使用string   常量值必须是与表达式类型兼容的特定的一个常量 不允许有重复的case值 default子句为可选 比较switch和多重if选择结构 相同点  都是用来处理多分支条件的结构   不同点  switch选择结构    只能处理等值条件判断的情况，而且条件必须是整型变量或字符型变量或者字符串（jdk1.7之后）     多重if选择结构    没有switch选择结构的限制，特别适合某个变量处于某个连续区间时的情况     循环结构 用于实现大量的重复性动作 while循环 在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体。而对于后来每一次额外的循环，都会在开始前重新计算一次。 语句中应有使循环趋向于结束的语句，否则会出现无限循环–––”死”循环。   public class WhileTest {  public static void main(String[] args) {   int i = 0;   int sum = 0;   while (i &lt;= 100) {   sum += i; //sum = sum+i;   i++;   }   System.out.println(Sum= + sum);  }  }   do-while循环 do-while  先执行，后判断。  do-while循环总是保证循环体至少执行一次，这是它与while循环最大的区别   while  先判断，后执行。     int a = 0; do {  System.out.println(a);  a++; } while (a &lt; 0);     for循环 for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构 语法形式     for (初始表达式;布尔表达式;步进) {  循环体; }     注意事项    for循环在执行条件测试后，先执行程序部分，再执行步进。   在for语句的初始化部分声明的变量，其作用域为整个for循环体   “初始化”和“循环条件表达式”部分可以使用逗号来执行多个操作   如果三个部分都为空语句（分号不能省），相当于一个无限循环     跳转语句 break和continue 在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句。(break语句还可用于多支语句switch中) continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。 什么是break语句 break：改变程序控制流  用于do-while、while、for中时，可跳出循环而执行循环后面的语句   什么是continue语句 continue ：只能用在循环里 continue 作用：跳过循环体中剩余的语句而执行下一次循环 对比break和continue 使用场合  break可用于switch结构和循环结构中  continue只能用于循环结构中   作用（循环结构中）  break语句终止某个循环，程序跳转到循环块外的下一条语句。  continue跳出本次循环，进入下一次循环   return return语句从当前方法退出，返回到调用该方法的语句处，并从该语句的下条语句处继续执行程序 返回语句的两种格式  return expression    返回一个值给调用该方法的语句。   返回值的数据类型必须和方法声明中的返回值类型一致或是精度低于声明的数据类型。     return    当方法声明中用void声明返回类型为空时，应使用这种返回类型，它不返回任何值。     多重循环 多重循环  一个循环体内又包含另一个完整的循环结构  任何两种循环都可以相互嵌套  可以任意层次循环，但是一般不超过3层   多重循环执行过程  外层循环变量变化一次，内层循环变量要变化一遍   递归算法 什么是递归（recursion）  程序调用自身的编程技巧称为递归。  一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法   递归问题的特点  一个问题可被分解为若干层简单的子问题  子问题和其上层问题的解决方案一致  外层问题的解决依赖于子问题的解决   递归结构  递归结构包括两个部分：    递归结束条件。解答：什么时候不调用自身方法。如果没有条件，将陷入死循环。   递归体。解答：什么时候需要调用自身方法。   递归的示例     求阶乘      public class A {  static long factorial(int n){   if(n==1){   return 1;   }else{   return n*factorial(n-1);   }  }  public static void main(String[] args) {   long d1 = System.currentTimeMillis();  System.out.println(阶乘的结果: ,factorial(10));   long d2 = System.currentTimeMillis();   System.out.println(“递归费时： ”,d2-d1);  //耗时：32ms  } }              递归的优点    程序简单     递归的缺点    递归调用会占用大量的系统堆栈，内存耗用多   在递归调用层次多时速度要比循环慢的多     递归的使用场合    任何可用递归解决的问题也能使用迭代解决。   当递归方法可以更加自然地反映问题，并且易于理解和调试，并且不强调效率问题时，可以采用递归；   在要求高性能的情况下尽量避免使用递归，递归既花时间又耗内存。     总结 选择结构  if语句    单、双、多分支选择结构，等值、不等值判断均可     switch语句    只有多分支选择结构 只针对等值判断     循环结构  while循环    先判断再循环   适合循环次数不固定情况     do-while循环    先循环再判断   适合循环次数不固定情况     for循环    适合循环次数固定情况     循环跳转语句  break    跳出本层循环，跳出外层循环需要结合标签或符号位实现     continue    提前结束本次循环     return    结束当前方法     多重循环  任何两种循环都可以相互嵌套  外层循环变量变化一次，内层循环变量要变化一遍   递归  程序调用自身的编程技巧称为递归。  递归简单，但是内存耗用多，速度要比循环慢  任何可用递归解决的问题也能使用循环解决，反之不见得   ",
      "url"      : "https://kekaiyuan.github.io//2021/05/28/03-process/",
      "keywords" : "Java"
    } ,
  
    {
      "title"    : "Java 学习笔记之 04 ——数组",
      "category" : "Java",
      "content": "Java 学习笔记之 04 ——数组 Content here ",
      "url"      : "https://kekaiyuan.github.io//2021/05/29/04-array/",
      "keywords" : "Java, 数组"
    } ,
  
    {
      "title"    : "Java 学习笔记之 05 ——面向对象编程",
      "category" : "Java",
      "content": "Java 学习笔记之 05 ——面向对象编程 概念 编程语言的演变   第一代：机器语言    机器语言是仅有0和1组成的语言，是机器才能够识别的语言，人类无法识别。   那时候程序员需要把程序用0和1表示出来，然后把长长的一串01字符打在一条纸带上（打孔代表1，不打孔代表0），把纸带送入纸带机中交给计算机运行。   纸带错一个孔，整条纸带都必须重做。   “BUG”一词由来于此。“BUG”原意指臭虫、小虫。当纸带被臭虫污染后就无法使用，所以开始用“BUG”指代那些让程序无法运行的错误。     第二代：汇编语言    开始使用一些英文词汇指代某些常用的指令，变得可以被人类理解。   主要对寄存器进行操作。   汇编语言会被编译器编译为机器语言。     第三代：高级语言    现在最广泛的语言，主要是相对于汇编语言而言的，它是较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序。   便于人类阅读、理解、学习。   一条高级语言往往对应多条汇编语言。   其中诞生了两个主要的分支：面向过程和面向对象。     第四代：目标语言    当前的一个研究方向，概述为智能语言，其一种说法是我只需要把目标定得足够明确，足够细致，那么就会自动化地生成对应的代码。   尚未成熟。     面向对象和面向过程  一个小例子：造桌子    面向过程     造桌子过程      寻找合适的木材    伐木    切割木材    设计图纸    造桌子         如果仅有一个人来造桌子，是这样的过程。但如果是两个人呢？       面向对象     我们可以把造桌子的过程分成两部分      木材交给伐木工人处理        寻找合适的木材     伐木     切割木材           组装交给家具工人处理        设计图纸     造桌子               现在造桌子的过程被分成两部分了。      对于家具工人，木材不再是一个过程，他没有参与木材的制作，也不知道伐木工人跑到了哪儿的森林，用什么姿势伐木，用什么东西运输回来的… 他通通不知道，他只知道这里有木材，他需要把木材变成桌子。 对于家具工人来说，木材就是对象。    对于伐木工人，造桌子也不是个过程。 他不知道图纸长什么样，也不知道怎么组装，他只负责把木材通通交给家具工人，木材就会变成桌子。 对于伐木工人来说，桌子就是对象。         扩展开来，对于家具工人，钉子是对象，锤子是对象……对于伐木工人，电锯是对象，车子是对象…..所以有一句话，现实世界是由对象组成的。         放在编程的世界里，面向过程就是把一切的步骤都放在一起： 第一步做什么、第二部做什么…..这会形成很长的一条过程流。 而面向对象就是把这个很长的过程，按照某种逻辑，分成不同的对象。 对于某个具体的对象而言，它根本不需要知道其他对象内部都是什么过程，它只需要这个对象有什么用，怎么用就足够了。  越复杂的问题，越是不能用面向过程的思想解决，必须用面向对象的思想解决。    就像一家杂货店，进货、看店、算账都可以交由一个人解决。但是一家超市不可能只有一个员工。     面向过程和面向对象不是毫无关联的。 对于某个对象来说，它内部的逻辑过程它是知晓的。 所以对外是面向对象，对内是面向过程。   类和对象 现实世界是由什么组成的？ 对象和类的概念  对象是具体的事物  类是对对象的抽象   每个人手里都有一个喝水的器皿，这是对象。 所有喝水的器皿抽象成一个概念，就是杯子这个类。  每个人都是独一无二的个体，是对象。  所有人抽象成一个概念，就是人类这个类。   对象  特征    属性     对象具有的各种特征   每个对象的每个属性都拥有特定值   例如每个人都有姓名、年龄、性别……       方法     对象执行的操作   例如收银员可以执行收银、打印账单、找零等方法。教师可以执行上课、下课、补课等方法。         总之，对象就是用来描述客观事物的一个实体，由一组属性和方法构成。  列出尼古拉斯·凯奇驾驶的这辆法拉利F360 Spider的属性和方法      属性：     品牌：法拉利   型号：F360 Spider   颜色：黄色   价格：380万元       方法：     发动   停止   加速         列出小狗对象的属性和方法      属性：     颜色：白色       方法：     叫   跑   吃         类  从对象中抽象出“类”    抽取出下列对象的属性和方法的共同特征     轿车类      属性        车轮     引擎     外壳     ……           方法        启动     加速     停止     ……                     类是模子，确定对象将会拥有的特征（属性）和行为（方法）  类指具有相同属性和方法的一组对象的集合   类和对象的关系  类是抽象的概念，仅仅是模板，比如说：“人”  对象是一个你能够看得到、摸得着的具体实体   对象和类的总结  对象和类的关系：特殊到一般，具体到抽象。  类叫做class。  对象叫做Object, instance(实例)。 某个类的对象，某个类的实例是同一个的意思。  类可以看成一类对象的模板，对象可以看成该类的一个具体实例。  类是用于描述同一类型的对象的一个抽象的概念，类中定义了这一类对象所应具有的静态和动态属性。  对象是Java程序的核心，在Java程序中“万事万物皆对象”。  JDK提供了很多类供编程人员使用，编程人员也可定义自己的类。   类的属性  属性：field，或者叫成员变量。  属性用于定义该类或该类对象包含的数据或者说静态属性。  属性作用范围是整个类体  在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化。    整型默认值：0   浮点型默认值：0.0   char类型：  u0000   boolean类型：false   所有引用类型：null     属性定义格式：    [修饰符] 属性类型 属性名 = [默认值]   修饰符     可以省略   可以是：public, protected, private,Static,final       属性类型     可以是任何类型，包括基本类型和引用类型       属性名     合法的标识符       默认值     可以省略   当属性有默认值时，在创建对象时该属性会被赋予默认值，后续可更改。         类的方法  面向对象中，整个程序的基本单位是类，方法是从属于对象的  方法定义格式：   [修饰符] 方法返回值类型 方法名(形参列表 ) {  // n条语句 }  t     JAVA中方法参数传递是：值传递！    值传递是指在调用方法时将实际参数复制一份传递到方法中，这样在方法中如果对参数进行修改，将不会影响到实际参数。   与之对应的是引用传递。对参数进行修改，实际参数也会被修改。     ",
      "url"      : "https://kekaiyuan.github.io//2021/05/30/05-oop/",
      "keywords" : "Java, 面向对象"
    } ,
  
    {
      "title"    : "学习计划",
      "category" : "Blog",
      "content": "学习计划  hashcode为什么*31 函数式接口 集合框架源码阅读  Collection  List   数据结构  BTS树、AVL树、红黑树   处理流为什么比节点流快 IO流源码阅读 bufferedReader = new BufferedReader(new FileReader(4.txt));里new出来的FileReader会被自动close吗  使用jd-gui反编译.class文件发现并没有   Socket client = new Socket(“127.0.0.1”, 13003); DataInputStream dataInputStream = new DataInputStream(client.getInputStream()); 里的client.getInputStream()创建了对象吗 github的.ignore和license 通过注解优化策略模式https://www.cnblogs.com/hhhshct/p/10585790.html asm 动态代理与面向切面编程 aio、bio、nio  bio不能用线程池，阻塞式  nio，阻塞式，但是阻塞时间很快  aio异步   ServerSocket半双工，关了outputstream，inputstream用不了  ServerSocketChannel全双工   NIO 的 ByteBuffer 只有一个指针，读写都用这个指针，很难用  Netty 的 ByteBuf 有两个指针，一个读指针，一个写指针   注释的等级// // /*/ 一本书：提问的艺术 netty官网demo 数据仓库 sql 注入 Lucene，Solr，ElasticSearch mvcc的行级锁 阅读 MySQL 的参考手册 apache commons工具包 博客的归档有bug 缓存一致性协议 aqs源码阅读 jdk 和 cglib 的动态代理性能差异 修改 mermaid 部分 正则表达式 Morris 遍历 nginx，lvs，keepalived 等负载均衡 redis，zookeeper 消息中间件 springcloud dubbo 调优，jvm，mysql，tomcat，项目调优 项目重构，架构设计的思想 书：代码简洁之道 PostgresSQL  堆表  数据表体积膨胀   MNS ",
      "url"      : "https://kekaiyuan.github.io//2021/06/02/question/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "设计模式之——单例 Singleton",
      "category" : "DesignPatterns",
      "content": "设计模式之——单例 Singleton 概念  以下内容引用自 菜鸟教程 单例模式 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意  单例类只能有一个实例。  单例类必须自己创建自己的唯一实例。  单例类必须给所有其他对象提供这一实例。  介绍 意图  保证一个类仅有一个实例，并提供一个访问它的全局访问点。  主要解决  一个全局使用的类频繁地创建与销毁。  何时使用  当您想控制实例数目，节省系统资源的时候。  如何解决  判断系统是否已经有这个单例，如果有则返回，如果没有则创建。  关键代码  构造函数是私有的。  应用实例  一个班级只有一个班主任。  Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。  一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。  优点  在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。  避免对资源的多重占用（比如写文件操作）。  缺点  没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。  使用场景：  要求生产唯一序列号。  WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。  创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。  注意事项  getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现 单例模式的关键在于： 将构造函数私有化，使得外部无法创建实例。 由该类自己创建实例，并且保证实例唯一。 需要考虑多线程并发下的安全问题。 饿汉式 饿汉式是最经典的单例模式，通过静态变量或静态代码块创建实例，即在类加载时创建，那么此时是不存在多线程并发的，所以无需考虑线程安全问题。 优点很明显，设计简单，不容易出错，不需要关心线程不安全的问题，同时逻辑简洁，运行效率高。 至于所谓的缺点，即饿汉式这个名称的由来： 该单例模式的创建和使用是分开的，所以存在创建实例后却没有执行任何任务，发生对象饿死的情况。 这个问题是分场景的： JVM 共有四种类加载器： 启动类加载器 加载 &lt;JAVA_HOME&gt;/lib 目录下的常用基础库：  java.util.*, java.io.*, java.lang.* 这些以 java 开头的类库。  因为语言差异，一些底层原理需要用 C 语言实现的类。   扩展类加载器 加载 &lt;JAVA_HOME&gt;/lib/ext 目录下的 JVM 扩展类：  swing 系列，js 引擎，xml 解析器等，这些类库以 javax 开头   系统类加载器 加载用户路径（ClassPath）下的类，也是使用次数最多的类加载器，用于加载我们自定义的类和引入的第三方 jar 包。 自定义加载器 除了 JVM 定义的三种类加载器，我们可以自定义实现一个加载器。 那么哪些类会在程序开始运行后，立即加载的呢？ 只有启动类和扩展类。 而我们自定义的类和第三方 jar 包则是使用时才加载，也就是说天然就是懒加载的。 所以在平常使用时，饿汉式的单例模式是不会饿死的。 考虑饿汉式单例会不会饿死时，应该先考虑当前环境下，这个单例模式会不会在程序启动时直接进行类加载。 静态变量 public class Singleton01 { private static final Singleton01 INSTANCE = new Singleton01(); private Singleton01(){} public static Singleton01 getInstance(){  return INSTANCE;  } } 静态代码块 public class Singleton02 { private static final Singleton02 INSTANCE; static {  INSTANCE = new Singleton02();  } private Singleton02(){} public static Singleton02 getInstance(){  return INSTANCE;  } } 懒汉式 懒汉式即实现懒加载，用到的时候才创建实例。 那么此时需要考虑线程安全问题： 某一时刻实例尚未创建，如果此时有多个线程同时访问该实例，就会创建多个实例，违反单例模式的定义。 所以需要实现线程同步。 public class Singleton03 { private static Singleton03 INSTANCE; private Singleton03(){  } public static synchronized Singleton03 getInstance() {  if(INSTANCE == null){   INSTANCE = new Singleton03();  }  return INSTANCE;  } } 双检锁 双检锁是懒汉式的升级，懒汉式使用的是同步方法，这也导致了每次取实例对象都需要上锁，浪费资源。 而双检锁减小了同步代码块的大小，提高并发度和效率。 只有实例未初始化时，创建实例的过程需要上锁，防止创建多个实例。 取对象时直接取即可。 public class Singleton04 { //使用volatile关键字，禁止指令重排  private static volatile Singleton04 INSTANCE; private Singleton04(){  } public static Singleton04 getInstance() {  if(INSTANCE == null){   // 上锁   synchronized (Singleton04.class){    //双重检查    if(INSTANCE == null){    INSTANCE = new Singleton04();    }   }  }  return INSTANCE;  } } 在双检锁中，必须使用 volatile 关键字，原因是 禁止指令重排 静态内部类 可以采用静态内部类的方式，由 JVM 保证单例。 同时加载外部类时并不会加载内部类，可以实现懒加载。 public class Singleton05 { private Singleton05(){} private static class Singleton{  private final static Singleton05 INSTANCE = new Singleton05();  } public static Singleton05 getInstance(){  return Singleton.INSTANCE;  } } 枚举 使用反射破坏单例模式 以上四种单例模式的关键之一在于将构造函数私有化，从而阻止其它创建实例的行为。 但是 Java 的反射机制可以获取一个类的私有构造器，并设置成可访问的，从而破坏单例模式。 public static void main(String[] args) throws Exception {  t// 创建实例 1  tSingleton01 singleton01 = Singleton01.getInstance();  t// 通过反射获取构造器  tClass&lt;? extends Singleton01&gt; aClass = singleton01.getClass();  tConstructor&lt;? extends Singleton01&gt; constructor = aClass.getDeclaredConstructor();  t// 设置构造器为可访问的  tconstructor.setAccessible(true);  t// 创建实例 2  tSingleton01 singleton02 = constructor.newInstance();  t// 对比是否是同一个对象  tSystem.out.println(singleton01 == singleton02); // false } 注意，只能通过 getDeclaredConstructor() 方法获取 private 构造器。 getConstructor() 方法和 getConstructors() 方法都无效。 结果 false 可以看到，单例模式失效了。 如果要防止反射的话，可以使用枚举来实现单例模式。 枚举这种特殊的数据类型天生就是单例的，而且无法通过反射获取其构造器，还可以防止反序列化。 public enum Singleton06 { INSTANCE; public static Singleton06 getInstance(){  return INSTANCE;  } } 如何检查是否是单例模式？ 通过 hashCode() 方法判断 //多线程访问，通过hashcode检验是否是单例模式 for(int i=0;i&lt;100;i++){  tnew Thread(()-&gt; System.out.println(Singleton06.getInstance().hashCode())).start(); } 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/02/singleton/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "Java 学习笔记之 06 ——异常",
      "category" : "Java",
      "content": "Java 学习笔记之 06 ——异常 什么是异常 异常是指在程序的运行过程中所发生的不正常的事件，它会中断正在运行的程序。 除数为0，数组越界，空指针都属于异常。 当异常发生时，程序会中断运行。 异常处理 Java编程语言使用异常处理机制为程序提供了错误处理的能力。 加入异常处理后，程序遇到异常后不会中断，而是会转入异常处理程序，正确处理后继续运行。 关键字 try catch finally throw throws 捕获异常 try{  t//可能会发生异常的代码块 }catch(ExceptionType e){  t//处理异常 }finally{  t//无论是否发生异常都会执行的块 } 执行过程中可能会发生的情况  正常执行，只执行try中的代码  遇到异常情况，会处理try中异常代码之前的逻辑，后面的逻辑不会执行，然后执行catch中的代码   try块中存放可能会发生异常的代码。  尽量放置少量的代码，做到精准地处理程序中的异常。   catch块将对异常进行处理。  参数为某具体异常  可使用printStackTrace函数的堆栈跟踪功能显示出程序运行到当前类的执行流程   多重catch块  引发多种类型的异常  排列catch 语句的顺序：先子类后父类  发生异常时按顺序逐个匹配  只执行第一个与异常类型匹配的catch语句   try{  t... }catch(ExceptionType1 e){  t//捕获到ExceptionType1的异常如何处理  t... }catch(ExceptionType2 e){  t//捕获到ExceptionType2的异常如何处理  t... }catch(ExceptionType3 e){  t//捕获到ExceptionType3的异常如何处理  t... } ...  t finally块  finally块中存放的代码是一定会被执行的，除了唯一一种情况：在try块或catch块中添加System.exit(1)  finally包含哪些处理逻辑？    IO流的关闭操作   数据库的连接关闭操作     声明异常 有时可以将异常抛出，由外部的调用方法进行处理 public class ExceptionThrow {  tpublic static void main(String[] args) {  t ttry{  t t ttest();  t t}catch (Exception e){  t t t...  t t}  t}  tpublic static void test() throws Exception{  t ...  t} } 应用场景：  多个方法之间的调用，每个方法中都可能出现异常。此时可选择将所有异常由最外层的方法进行统一处理。  在程序的调用过程中，如果某方法的外层的调用方法有对异常的处理，那么可以直接使用throws，否则，需要使用try…catch…处理本方法中的异常   如果程序中一直都在声明异常（包括main方法），那么最终异常将交由JVM处理，不推荐。 抛出异常 除了被自动捕获的异常外，我们还可以手动地抛出异常 public class ExceptionThrow { public static void main(String[] args) {  try{   test();  }catch (Exception e){   e.printStackTrace();  }  } public static void test() throws Exception{  throw new Exception();  } } 结果 java.lang.Exception  tat ExceptionThrow.test(ExceptionThrow.java:16)  tat ExceptionThrow.main(ExceptionThrow.java:9) 可以在Exception()中添加参数，打印错误信息 public class ExceptionThrow { public static void main(String[] args) {  try{   test();  }catch (Exception e){   e.printStackTrace();  }  } public static void test() throws Exception{  throw new Exception(It's exception!!!);  } } 结果 java.lang.Exception: It's exception!!!  tat ExceptionThrow.test(ExceptionThrow.java:16)  tat ExceptionThrow.main(ExceptionThrow.java:9) 自定义异常 在java的api中提供了非常丰富的异常类，但是在某些情况下不太满足我们的需求，此时需要自定义异常 步骤： 继承Exception类 自定义实现构造方法 需要使用的时候，使用throw new 自定义异常的名称 public class GenderException extends Exception { public GenderException(){  System.out.println(性别异常);  } public GenderException(String msg){  System.out.println(msg);  } } 异常中的return  情况一：try中有return，finally中没有return  public class TryTest{ public static void main(String[] args){  System.out.println(test()); } private static int test(){  int num = 10;  try{   System.out.println(try);   return num += 80;  }catch(Exception e){   System.out.println(error);  }finally{   if (num &gt; 20){   System.out.println(num : + num);   }   System.out.println(finally);  }  System.out.println(method end);  return num; } }    执行结果   try num : 90 finally 90     执行顺序：    “return num += 80;”被拆分成了“num = num+80;”和“return num;”两个语句   num = num+80;   finally块   return num;   外面的”System.out.println(“method end”);”则不会被执行     情况二：try和finally中均有return  public class TryTest{ public static void main(String[] args){  System.out.println(test()); } private static int test(){  try{   return 80;  }catch(Exception e){  }finally{   return 100;  } } }    执行结果：   100      原因：    try中的return语句会被finally中的return语句覆盖。     情况三：finally中改变返回值num  public class TryTest{ public static void main(String[] args){  System.out.println(test()); } private static int test(){  int num = 10;  try{   return num;  }catch(Exception e){  }finally{   num = 100;  }  return num; } }   执行结果：   10     原因：    在执行”return num;”语句时分为三步:     存储num的值   执行finally块   return第一步存储的num的值         情况四：将num的值包装在Num类中  public class TryTest{  public static void main(String[] args){   System.out.println(test().num);  }  private static Num test(){   Num number = new Num();   try{   return number;   }catch(Exception e){   }finally{   number.num = 100;   }   return number;  } } class Num{  public int num = 10; }   执行结果：  100   原因：   try中的”return number;”存储的是number的引用，所以会被finally块修改其中的值   总结：   try语句在返回前，将其他所有的操作执行完，保留好要返回的值，而后转入执行finally中的语句，而后分为以下三种情况：    情况一：如果finally中有return语句，则会将try中的return语句”覆盖“掉，直接执行finally中的return语句，得到返回值，这样便无法得到try之前保留好的返回值。   情况二：如果finally中没有return语句，也没有改变要返回值，则执行完finally中的语句后，会接着执行try中的return语句，返回之前保留的值。   情况三：如果finally中没有return语句，但是改变了要返回的值，这里有点类似与引用传递和值传递的区别，分以下两种情况：     1）如果return的数据是基本数据类型或文本字符串，则在finally中对该基本数据的改变不起作用，try中的return语句依然会返回进入finally块之前保留的值。   2）如果return的数据是引用数据类型，而在finally中对该引用数据类型的属性值的改变起作用，try中的return语句返回的就是在finally中改变后的该属性的值。               异常的分类 checked异常  主流ide在编译时check出的代码错误。   RunTimeException  运行时在某种条件下才会发生的异常，例如除0异常、空指针异常   Q:所有异常的父类?  A:Throwable   源码链接 本文源码链接 https://github.com/kky970614/javase/tree/main/code/exception ",
      "url"      : "https://kekaiyuan.github.io//2021/06/02/06-exception/",
      "keywords" : "Java，异常"
    } ,
  
    {
      "title"    : "设计模式之——策略 Strategy",
      "category" : "DesignPatterns",
      "content": "设计模式之——策略 Strategy 概念  以下内容引用自 菜鸟教程 策略模式 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。 介绍 意图  定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。  主要解决  在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。  何时使用  一个系统有许多许多类，而区分它们的只是他们直接的行为。  如何解决  将这些算法封装成一个一个的类，任意地替换。  关键代码  实现同一个接口。  应用实例  诸葛亮的锦囊妙计，每一个锦囊就是一个策略。  旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。  JAVA AWT 中的 LayoutManager。  优点  算法可以自由切换。  避免使用多重条件判断。  扩展性良好。  缺点  策略类会增多。  所有策略类都需要对外暴露。  使用场景  如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。  一个系统需要动态地在几种算法中选择一种。  如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。  注意事项  如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。 实现 uml 图 Context 上下文 Context 即上下文角色，也叫 Context 封装角色。 起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。 public class Context {  tprivate Strategy strategy;  t//上下文接口  tpublic void contextInterface() {  t tstrategy.algorithmInterface();  t} } 抽象策略角色 抽象策略角色是对策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。 public abstract class Strategy {  t//算法方法  tpublic abstract void algorithmInterface(); } 具体策略角色 用于实现抽象策略中的操作，即实现具体的算法。 有多少个策略，就编写多少个具体策略角色。 public class ConcreteStrategyA extends Strategy {  t@Override  tpublic void algorithmInterface() {  t t//策略A的具体算法  t t...  t} } 调用 创建一个 Context 上下文 通过设置 Context 的策略对象来实现对不同策略的调用 public static void main(String[] args) {  tContext context = new Context();  tcontext.setStrategy(new ConcreteStrategyA());  t// 调用策略 A  tcontext.contextInterface();  tcontext.setStrategy(new ConcreteStrategyB());  t// 调用策略 B  tcontext.contextInterface();  tcontext.setStrategy(new ConcreteStrategyC());  t// 调用策略 C  tcontext.contextInterface();  t... } 源码链接 本文章源码链接 Github 现在有两个类，Cat 类和 Dog 类  Cat 类代表猫，有两个属性：体重和身高  Dog 类代表狗，有一个属性：食量   使用策略模式实现一个能对 Cat 对象和 Dog 对象进行排序的方法  策略一：将猫根据体重升序排序  策略二：将猫根据身高降序排序  策略三：将狗按照食量升序排序  ",
      "url"      : "https://kekaiyuan.github.io//2021/06/03/strategy/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "设计模式之——工厂 Factory",
      "category" : "DesignPatterns",
      "content": "设计模式之——工厂 Factory 工厂模式 工厂是一个概念，任何可以产生对象的方法或类，都可以称之为工厂。 而工厂模式则是对工厂进行了一定程度的抽象，定义了具有通用性的模板。 为什么有了 new 之后，还要有工厂？ 灵活控制生产过程 权限、修饰、日志 假如我现在有一个类，在 100 个地方通过 new 的方式创建了这个类的对象。 现在我想要增加一些操作，比如说有权限的用户才能创建这个类，或是添加一些修饰，或是打印日志。 那么我得修改 100 个地方。 但是如果这些对象都是通过同一个工厂生产出来的。 那么此时我们只需要对工厂做出 1 次修改，所有对象都会被修改。 那么工厂模式适合什么场景呢？ 对象数量很多，需要统一管理生产过程 对象的生产过程复杂，需要用工厂类对生产过程进行封装，方便二次调用 工厂模式有以下四种类型： 简单工厂 静态工厂 工厂方法 抽象工厂 工厂类型 简单工厂 简单工厂专门用于生产某一类的子类 比如交通工具里有汽车、飞机、自行车…… 那么我们就可以定义一个交通工具的简单工厂，专门用它来生产各类交通工具。 概念  以下内容引用自 菜鸟教程 工厂模式 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。 介绍 意图  定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。  主要解决  主要解决接口选择的问题。  何时使用  我们明确地计划不同条件下创建不同实例时。  如何解决  让其子类实现工厂接口，返回的也是一个抽象的产品。  关键代码  创建过程在其子类执行。  应用实例  您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。  Hibernate 换数据库只需换方言和驱动就可以。  优点  一个调用者想创建一个对象，只要知道其名称就可以了。  扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。  屏蔽产品的具体实现，调用者只关心产品的接口。  缺点  每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。  使用场景  日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。  数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。  设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。  注意事项  作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。 实现 产品抽象类 所有交通工具类的父类。 public abstract class Vehicle {  public abstract void go(); }  枚举 定义交通工具的类型，使用枚举的好处能够限定参数种类，避免无效参数的传入。 同时将产品类型列举在枚举中，方便第三方查看和调用。 public enum VehicleType {  Car, Plane, Broom }  具体的产品类 汽车  public class Car extends Vehicle { @Override public void go() {  System.out.println(开汽车); } }   飞机  public class Plane extends Vehicle { @Override public void go() {  System.out.println(开飞机); } }   魔法扫帚  public class Broom extends Vehicle { @Override public void go() {  System.out.println(骑扫帚); } }   简单工厂 public class SimpleVehicleFactory { public Vehicle createVehicle(VehicleType type) {  switch (type) {   case Car:    return new Car();   case Plane:    return new Plane();   case Broom:    return new Broom();   default:    return null;  }  } }  测试 public static void main(String[] args) {  SimpleVehicleFactory simpleVehicleFactory = new SimpleVehicleFactory(); Vehicle car = simpleVehicleFactory.createVehicle(VehicleType.Car);  car.go(); Vehicle plane = simpleVehicleFactory.createVehicle(VehicleType.Plane);  plane.go(); Vehicle broom = simpleVehicleFactory.createVehicle(VehicleType.Broom);  broom.go(); } 结果 开汽车 开飞机 骑扫帚 静态工厂 静态工厂是简单工厂的升级。 很明显，工厂是一个无状态的类，程序中并不需要实际的工厂对象，所以把工厂的方法设置为静态的，并且将工厂类的构造器私有化，避免创建工厂对象。 public class StaticFactory {  private StaticFactory() {  } public static Vehicle createVehicle(VehicleType type) {  switch (type) {   case Car:    return new Car();   case Plane:    return new Plane();   case Broom:    return new Broom();   default:    return null;  }  } } 工厂方法 在简单工厂中，工厂可以生产所有的交通工具：汽车、飞机、扫帚…… 但是在工厂方法中，每种产品都由特定的工厂生产。 有多少种产品，就有多少个工厂。 实现 工厂抽象类 所有工厂类的父类 public interface VehicleFactory {  Vehicle createVehicle(); }  具体工厂 汽车工厂  public class CarFactory implements VehicleFactory { @Override public Vehicle createVehicle() {  return new Car(); } }   飞机工厂  public class PlaneFactory implements VehicleFactory { @Override public Vehicle createVehicle() {  return new Plane(); } }   魔法扫帚工厂  public class BroomFactory implements VehicleFactory { @Override public Vehicle createVehicle() {  return new Broom(); } }   测试 public static void main(String[] args) {  VehicleFactory carFactory = new CarFactory();  Vehicle car = carFactory.createVehicle();  car.go(); VehicleFactory planeFactory = new PlaneFactory();  Vehicle plane = planeFactory.createVehicle();  plane.go(); VehicleFactory broomFactory = new BroomFactory();  Vehicle broom = broomFactory.createVehicle();  broom.go(); } 结果 开汽车 开飞机 骑扫帚 抽象工厂 抽象工厂生产的是产品族，即固定的产品搭配。 什么是产品族？ 比如现在我有以下产品 载具  汽车  魔法扫帚   武器  AK47  魔法棒   食物  方便面  魔法蘑菇   很明显，除了种类之外，这六类产品可以按照世界观分为两类 现实世界：汽车、AK47、方便面 魔法世界：魔法扫帚、魔法棒、魔法蘑菇 这就是产品族，把多个产品定义成一个整体。 于是我们就可以为这两个产品族建立两个抽象工厂 现实世界的抽象工厂专门生产 {汽车，AK47，方便面} 魔法世界的抽象工厂专门生产 {魔法扫帚，魔法棒，魔法蘑菇} 抽象工厂的目的主要有两个 维护产品族的内容  我通过抽象工厂得到的产品族一定是唯一的。 就像我通过上面的两个抽象工厂一定只能得到 {汽车，AK47，方便面} 和 {魔法扫帚，魔法棒，魔法蘑菇} 之中的一个产品族。 我不可能得到 {汽车，魔法棒，魔法蘑菇} 这样的产品族。 就像你不能去食品工厂生产电子产品，去电子工厂生产食品一样。  抽象工厂保证了各个类之间的正确组合。   方便生产  假如现在有六个工厂，分别生产上述六种东西的一种，那么我们可以很方便地得到其中一种：调用某个工厂得到某个产品。 如果需要产品族，那么就调用三个工厂，得到三个产品。  但是抽象工厂更方便，我只需要调用一个抽象工厂，就能得到一整套的产品族。   最常使用抽象工厂就是换皮肤。 无论是游戏内人物的皮肤，还是某款应用的界面，都非常适合用抽象工厂进行设计。 一套皮肤是由许多组件构成的，使用抽象工厂，就不会出现换皮肤后，一半是新皮肤，一半是旧皮肤的错误。 因为组件数量特别多，所以需要抽象工厂将组件集中到一起，实现“一键换皮”。 概念  以下内容引用自 菜鸟教程 抽象工厂模式 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 介绍 意图  提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。  主要解决  主要解决接口选择的问题。  何时使用  系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。  如何解决  在一个产品族里面，定义多个产品。  关键代码  在一个工厂里聚合多个同类产品。  应用实例  工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。  优点  当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。  缺点  产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。  使用场景  QQ 换皮肤，一整套一起换。  生成不同操作系统的程序。  注意事项  产品族难扩展，产品等级易扩展。 实现 抽象工厂需要定义非常多的抽象类，抽象工厂本身就是一个抽象类，每种产品又需要一个抽象类。 食物 抽象类  public abstract class Food { public abstract void getName(); }   抽象类  public class InstantNoodles extends Food{ @Override public void getName() {  System.out.println(方便面); } }   方便面  public class InstantNoodles extends Food{ @Override public void getName() {  System.out.println(方便面); } }   魔法蘑菇  public class MushRoom extends Food{ @Override public void getName() {  System.out.println(魔法蘑菇); } }   载具 抽象类  public abstract class Vehicle { public abstract void go(); }   汽车  public class Car extends Vehicle { @Override public void go() {  System.out.println(开汽车); } }   魔法扫帚  public class Broom extends Vehicle { @Override public void go() {  System.out.println(骑扫帚); } }   武器 抽象类  public abstract class Weapon { public abstract void shoot(); }   AK47  public class AK47 extends Weapon{ @Override public void shoot() {  System.out.println(AK47); } }   魔法棒  public class MagicStick extends Weapon{ @Override public void shoot() {  System.out.println(魔法棒); } }   有了产品以后，就需要定义包装产品族的抽象工厂了。 抽象工厂 抽象类  public abstract class AbstractFactory {  public abstract Food getFood();  public abstract Vehicle getVehicle();  public abstract Weapon getWeapon(); }   现代工厂  public class ModernFactory extends AbstractFactory{  @Override  public Food getFood() {   return new InstantNoodles();  }  @Override  public Vehicle getVehicle() {   return new Car();  }  @Override  public Weapon getWeapon() {   return new AK47();  } }   魔法工厂  public class MagicFactory extends AbstractFactory{  @Override  public Food getFood() {   return new MushRoom();  }  @Override  public Vehicle getVehicle() {   return new Broom();  }  @Override  public Weapon getWeapon() {   return new MagicStick();  } }   测试 public class Main {  tpublic static void main(String[] args) {  t tAbstractFactory abstractFactory1 = new MagicFactory();  t tshow(abstractFactory1);  t tSystem.out.println(-------);  t tAbstractFactory abstractFactory2 = new ModernFactory();  t tshow(abstractFactory2);  t}  tpublic static void show(AbstractFactory abstractFactory){  t tabstractFactory.getFood().getName();  t tabstractFactory.getVehicle().go();  t tabstractFactory.getWeapon().shoot();  t} } 结果 魔法蘑菇 骑扫帚 魔法棒 ------- 方便面 开汽车 AK47 可以看到，使用了抽象工厂以后，产品族的搭配变得十分稳定，而且调用很简单。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/04/factory/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "Java 学习笔记之 08 ——容器",
      "category" : "Java",
      "content": "Java 学习笔记之 08 ——容器 简介 使用场景  不知道对象的具体数量，需要动态扩展  对象的存储方式复杂   Java集合框架包含的内容  Java集合框架提供了一套性能优良、使用方便的接口和类，它们位于java.util包中  Collection接口 常用方法  集合作为容器应该具有的功能（增，删，改，查），不一定全有。  集合的基本操作：增加，删除，判断，取出   List与Set接口 Collection 接口存储一组不唯一，无序的对象   List 接口存储一组不唯一，有序（插入顺序）的对象  Set 接口存储一组唯一，无序的对象（存入和取出的顺序不一定一致）  Map接口存储一组键值对象，提供key到value的映射  List接口 特点：有序，不唯一（可重复） 实现类   ArrayList    实现了长度可变的数组，在内存中分配连续的空间。   优点     遍历元素和随机访问元素的效率比较高       缺点     插入和删除等需要移动大量元素的操作效率低   按照内容查询效率低         LinkedList    采用链表存储方式   优点     插入、删除元素时效率比较高       缺点     遍历和随机访问元素效率低下         特有方法  凡是可以操作索引的方法都是该体系特有方法   Set接口 特性  Set接口存储一组唯一，无序的对象（存入和取出的顺序不一定一致）  操作数据的方法与List类似，Set接口不存在get()方法   实现类   HashSet    采用Hashtable哈希表存储结构   优点：插入、查询、删除速度快   缺点：无序   子类：LinkedHashSet     采用哈希表存储结构，同时使用链表维护次序    有序（添加顺序）         TreeSet    采用二叉树（红黑树）的存储结构3   优点：有序（排序后的升序）查询速度比List快   缺点：查询速度没有HashSet快     Hash表 在计算机中，Hash表是一种非常高效的存储方式，它通过散列函数计算数据的存放位置，而读取数据时也是根据散列函数计算位置。 这比起遍历数组时需要从头读到尾要高效得多。 散列函数的设计是Hash表的重中之中，顾名思义，散列函数的作用就是把数据的存放位置尽可能地“散开”，如果散列程度不够，大量数据经过函数计算后存放位置相同，那么依然需要类似于数组遍历一样遍历该位置上的所有数据。 最简单的散列函数就是将数据%散列表的长度。 表长7，数据45%7=3，所以把45存放在3号位置。 …… 可以看到，33和12处于同一位置，而散列表还有空余，所以散列函数的设计是一门大学问。 Iterator 接口 所有实现了Collection接口的容器类都有一个iterator方法用以返回一个实现了Iterator接口的对象。 Iterator对象称作迭代器，用以方便的实现对容器内元素的遍历操作。 所有的集合类均未提供相应的遍历方法，而是把遍历交给迭代器完成。迭代器为集合而生，与门实现集合遍历 Iterator是迭代器设计模式的具体实现 Iterator方法  boolean hasNext()判断是否存在下一个可访问的元素  Object next()返回要访问的下一个元素  void remove()删除上次访问返回的对象  Demo       for(Iterator iterator = set.iterator();iterator.hasNext();){  System.out.println(iterator.next()); }         可以使用Iterator遍历的本质是什么？  实现Iterable接口   For-each循环     ArrayList list = new ArrayList(); list.add(1); list.add(2); list.add(3); list.add(4); for (Object i : list) {  System.out.println(i); }     特点    增强的for循环，遍历array或Collection的时候相当简便   无需获得集合和数组的长度，无需使用索引访问元素，无需循环条件   遍历集合时底层调用Iterator完成操作     缺陷    数组     不能方便的访问下标值   不要在for-each中尝试对变量赋值，只是一个临时变量       集合     与使用Iterator相比，不能方便 的删除集合中的内容         总结    除了简单的遍历并读出其中的内容外，不建议使用增强for     注意  不能在使用迭代器遍历的过程中使用集合对象的方法。  例如：当我们在使用Iterator遍历数组并删除指定元素时，必须使用Iterator.remove()方法，而不能使用数组的remove()方法  错误写法   ArrayList arrayList = new ArrayList(); arrayList.add(...); ... Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) { Object object = iterator.next(); if (object.equals(...)) {  //正确写法  iterator.remove();  t t t  //错误写法，程序会报错  arrayList.remove(object); } }     原因    ArrayList的遍历是通过两个int类型的变量实现的——cursor和lastRet     cursor变量指向下一个要读取的元素的下标值   而lastRet变量则指向刚刚返回的元素的下标值   流程      一开始cursor=0lastRet=-1，读取arrayList[cursor]也就是arrayList[0]，然后cursor=1lastRet=0    接下来读取arrayList[cursor]也就是arrayList[1]然后cursor=2lastRet=1    ……    当cursor&gt;=数组的长度结束遍历            当在遍历中调用ArrayList.remove(Object o)方法时，数组元素被删除了，cursor和lastRet却不会被修改，此时就会报错   但是Iterator.remove()方法就会正确地修改cursor和lastRet，保证遍历的运行     Iterator类的局限性 Iterator类的方法很少，除去第一个非常用方法，只有三个：判断(hasNext)，取出(next)，删除(remove)，不能修改元素，也不能添加元素… 正如上文所提，在使用迭代器遍历的过程中不能直接调用集合对象的方法，比如ArrayList.add()方法。 所以这时候，就需要使用Iterator类的子类——ListIterator类来实现更加丰富的操作 总结： 当我们只需要遍历数组或者删除某数组元素时，使用Iterator类 其他复杂的操作必须使用ListIterator类 LinkList LinkedList类特有的方法 k-v：session、json、Redis、HBase treemap：红黑树 https://www.cnblogs.com/zhuyeshen/p/10956822.html```java  ",
      "url"      : "https://kekaiyuan.github.io//2021/06/04/08-collection/",
      "keywords" : "Java, 容器"
    } ,
  
    {
      "title"    : "设计模式之——中介者 Mediator 和外观 Facade",
      "category" : "DesignPatterns",
      "content": "设计模式之——中介者 Mediator 和外观 Facade 中介者模式 假设现在你有五个模块，这五个模块之间互有联系。 联系有点复杂，但是好像还可以接受。 但是如果模块数量继续增加呢？ 联系网会迅速膨胀，变得复杂，臃肿，并且难以维护。 所以我们需要一个“中介者”，帮我们调停模块之间的联系。 消息队列也是提现了这样的思想。 模块们把消息送给消息队列，然后从消息队列拿自己需要的消息。 我的消息应该送给谁？我应该从谁哪里拿消息？这些问题就不需要考虑了，程序耦合度会大大降低。 所有的消息都放在队列中，想要什么消息自己取，而不是等着谁来发给你你所需要的消息。 消息队列就类似于菜鸟驿站，快递员只负责把快递送到驿站，不负责送到每个人手里。谁有快递自己去驿站取。 概念  以下内容引用自 菜鸟教程  意图   用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。    主要解决   对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。    何时使用   多个类相互耦合，形成了网状结构。    如何解决   将上述网状结构分离为星型结构。    关键代码   对象 Colleague 之间的通信封装到一个类中单独处理。    应用实例   中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。  机场调度系统。  MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的调停者。    优点   降低了类的复杂度，将一对多转化成了一对一。  各个类之间的解耦。  符合迪米特原则。    迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。英文简写为: LOD。       缺点   中介者会庞大，变得复杂难以维护。    使用场景：   系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。  想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。    注意事项   不应当在职责混乱的时候使用。   外观模式 外观模式和中介者模式非常像，其核心思想都是把程序解耦，把各个模块之间的复杂联系集中到一个单独的类中。 区别在于一个是外部联系，一个是内部联系。 比如说现在有一家公司，人员和业务非常多。 前台就是外观模式，他负责帮助外来人员和公司之间的联系。 而公司内部负责协调工作的小组就是中介者模式，他负责协调公司内部各个部门之间的联系。 又比如 MVC 模式，对于 Model 来说，Controller 是中介者。 因为 Model 通过 Controller 和其它 Model 产生联系，他们是一个群体，Controller 是内部的协调器，是中介者模式。 对于 View 来说，Controller 是外观模式。 因为 View 通过 Controller 和 Model 群体产生联系，这是两个群体的交互。 所以是一个外部的协调器，是外观模式。 加入外观模式之前： 加入外观模式之后： 概念 外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。  以下内容引用自 菜鸟教程  意图   为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。    主要解决   降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。    何时使用   客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。  定义系统的入口。    如何解决   客户端不与系统耦合，外观类与系统耦合。    关键代码   在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。    应用实例   去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。  JAVA 的三层开发模式。    优点   减少系统相互依赖。  提高灵活性。  提高了安全性。    缺点   不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。    开闭原则      对拓展开放，对修改关闭。    可以加新功能，但是不要修改原有功能的代码。            使用场景   为复杂的模块或子系统提供外界访问的模块。  子系统相对独立。  预防低水平人员带来的风险。    注意事项   在层次化结构中，可以使用外观模式定义系统中每一层的入口。   总结 中介者模式和外观模式并不是类似于单例模式有特定模板的模式，它们体现的是封装的思想。 调用关系是编程中也需要特别注意的一点，当调用关系比较复杂时，一定要设计一个模块，专门用于封装不同模块之间的调用。 当程序过于复杂时，甚至可以采用多重中介者模式。 每个中介者协调一组模块，最终所有的中介者再由一个中介者协调。 例如快递网络。 小镇的运输中心聚集附近村子的快递。 城市的运输中心聚集附近小镇的。 省会的运输中心聚集该省的快递。 在这之上还有按地域划分的运输中心：比如华东运输中心、华南运输中心…… 通过这多重网络才真正覆盖全国。 ",
      "url"      : "https://kekaiyuan.github.io//2021/06/05/mediator-facade/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "Java 学习笔记之 09 —— IO",
      "category" : "Java",
      "content": "Java 学习笔记之 09 —— IO File类  常用方法 遍历文件 当需要遍历某目录以及子目录下的所有文件时，需要使用递归方式遍历。 遍历时会报空指针错误，这是因为当前文件系统受保护，某些文件没有访问权限。  public static void printFiles(File file) {  if (file.isDirectory()) {   File[] files = file.listFiles();   for (File f : files) {   printFiles(f);   }  } else {   System.out.println(file.getAbsolutePath());  } }   流 Java通过流来读写文件  流是指一连串流动的字符,是以先进先出方式发送信息的通道。   输入/输出流与数据源  输入流：XXX——&gt;程序  输出流：程序——&gt;XXX  数据源    提供原始数据的原始媒介。   常见的：数据库、文件、其他程序、内存、网络连接、IO设备。   数据源就像水箱，流就像水管中流着的水流，程序就是我们最终的用户。   流是一个抽象、动态的概念，是一连串连续动态的数据集合。     Java流的分类  按流向划分    输入流     InputStream   Reader       输出流     OutputStream   Writer         按照处理数据单元划分    字节流     字节流是 8 位通用字节流。   InputStream   OutputStream       字符流     字符流是 16 位 Unicode 字符流。   Reader   Writer         按照功能划分    节点流     可以直接从数据源或目的地读写数据。         处理流（包装流）     不直接连接到数据源或目的地，是其他流进行封装。目的主要是简化操作和提高性能。         怎么理解节点流和处理流？     假设现在有两个水箱      节点流就是直接通过水管将两个水箱连接起来。    处理流就是其中一个水箱连接水管，然后将水管进行一些改造（也就是Java中的封装），再连接到另一个水箱。            节点流和处理流的关系     节点流处于io操作的第一线，所有操作必须通过他们进行。   处理流可以对其他流进行处理（提高效率或操作灵活性）。         Java.Io中的常用类[1] 这里只列举了一部分，详细地请阅读JDK API文档。 InputStream ByteArrayInputStream  包含一个内部缓冲区，其中包含可以从流中读取的字节。构造方法需要一个byte数组   PipedInputStream FilterInputStream  处理流，构造方法需要一个InputStream对象   BufferedInputStream  为另一个输入流添加功能，即缓冲输入和支持mark和reset方法的功能   DataInputStream  数据输入流允许应用程序以独立于机器的方式从底层输入流读取原始Java数据类型  应用程序使用数据输出流来写入稍后可以被数据输入流读取的数据  与DataOutputStream搭配使用   FileInputStream  从文件系统中的文件获取输入字节   ObjectInputStream  反序列化先前使用ObjectOutputStream编写的原始数据和对象  与ObjectOutputStream搭配使用   OutputStream ByteArrayOutputStream  该类实现了将数据写入字节数组的输出流   PipedOutStream FilterOutStream  这个类是过滤输出流的所有类的超类  BufferedOutputStream    该类实现缓冲输出流     DataOutputStream    数据输出流使应用程序以便携式方式将原始Java数据类型写入输出流   与DataInputStream搭配使用     PrintStream    为另一个输出流添加了功能，即能够方便地打印各种数据值的表示   常用的System.out的类型就是PrintStream     FileOutputStream  文件输出流是用于将数据写入到输出流File或一个FileDescriptor   ObjectOutputStream  ObjectOutputStream将Java对象的原始数据类型和图形写入OutputStream  与ObjectInputStream搭配使用   Reader CharArrayReader  该类实现了一个字符缓冲区，可以用作字符输入流。   PipedReader BufferedReader  从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取。  FileReader    阅读字符文件的便利类     InputStreamReader  处理流  InputStreamReader是从字节流到字符流的桥：它读取字节，并使用指定的字符集将其解码为字符   Writer 用于写入字符流的抽象类 CharArrayWriter  该类实现了可以用作Writer的字符缓冲区   PipedWriter BufferedWriter  将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入   OutputStreamWriter  OutputStreamWriter是字符流到字节流的桥：可用制定的字符集对写入的字符进行编码  FileWriter    写字符文件的便利类     PrintWriter  将对象的格式表示打印到文本输出流   流的选择 文本文件的读写  用FileInputStream和FileOutputStream读写文本文件  用BufferedReader和BufferedWriter读写文本文件   二进制文件的读写  使用DataInputStream和DataOutputStream读写二进制文件以及基本数据类型数据的读写   对象的读写  使用ObjectInputStream和ObjectOutputStream读写对象(序列化与反序列化)   速度测试[2] 通过程序复制文件测量不同类的速度  字节流和字符流    如果文件是视频、音乐…那么必须使用字节流，如果文件是含中文的文本，必须使用字符流。如果文件是纯英文的文本，字符流和字节流都可以，但是谁更快呢？   文本大小：25MB纯英文txt   测试次数：100次   字节流     FileInputStream和FileOutputStream   平均用时163ms       字符流     FileReader和FileWriter   平均用时89ms       结论     文本使用字符流处理更快         节点流和处理流    文本大小：25MB纯英文txt   测试次数：100次   节点流     FileReader和FileWriter   平均用时97ms       处理流     InputStreamReader和OutputStreamWriter   平均用时97ms       结论     节点流和处理流在速度上区别不大         使用缓冲区和不使用缓冲区    使用 FileReader和FileWriter   文本大小：25MB纯英文txt   测试次数：10次   不使用缓冲区     平均用时1121ms       使用缓冲区     平均用时93ms         注意事项 每个Io流在使用后都必须调用close()方法关闭Io流，否则会造成资源泄露  正常的写法   InputStream inputStream = null; OutputStream outputStream = null; try {  inputStream = new FileInputStream(...);  outputStream = new FileOutputStream(...);  ... } catch (...) {  ... } finally {  try {   inputStream.close();  } catch (IOException e) {   e.printStackTrace();  }  try {   outputStream.close();  } catch (IOException e) {   e.printStackTrace();  } }     注意： 每个Io流的关闭都要被单独的try-catch语句处理    这种写法是错误的   finally {  try {   inputStream.close();   outputStream.close();   ...  } catch (IOException e) {   e.printStackTrace();  } }       因为这种写法若第一个Io流的关闭操作出现异常，程序转去执行catch块后就会退出finally块，接下来的Io流将不会执行关闭操作。   而每个Io流的关闭都由单独的try-catch语句处理，即使某一Io流的关闭操作出现异常也不会影响到下面的Io流的关闭操作。     try-with-resources       try (InputStream inputStream = new FileInputStream(source);  OutputStream outputStream = new FileOutputStream(desk);) {  ... } catch (...){  ... }       编译器会自动补全close()，反编译.class文件可以印证这一点。     如果是带缓冲区的OutputStream类或Writer类如何正确的写出数据？  使用flush()方法刷新输出流并强制缓冲区的输出字节被写出。  使用close()方法。close()方法里包括了flush()方法的调用。  当我们需要在Io流关闭后写入数据，调用close()方法。  当我们需要在Io流关闭前写入数据，调用flush()方法。   当使用ObjectInputStream和ObjectOutputStream读写对象时  所读写的类必须实现Serializable接口。  读对象时用的实体类和写对象时用的实体类不只是属性和类名一致，包名也必须一致。  序列化时，只对对象的状态进行保存，而不管对象的方法。  serialVersionUID类似于一个标记。    反序列化时，JVM会验证字节流中的serialVersionUID和本地相应实体类的serialVersionUID是否一致。若一致，进行反序列化，读取对象。若不一致则无法序列化。   可以通过serialVersionUID进行版本的兼容。     若不修改serialVersionUID，那么即使对实体类进行了修改，依然可以反序列化之前的对象。   若修改serialVersionUID，那么即使没有做出修改，依然无法反序列化。         static类型的成员无法被序列化。因为序列化是对堆中的数据进行序列化，“方法区”中的数据无法序列化。  transient类型的成员数据不能被序列化。transient代表对象的临时数据。   源码链接 本文源码链接 https://github.com/kky970614/kky970614.github.io 1.^Java.Io常用类的使用方法 2.^测试代码 3.  将http://www.baidu.com的原文件以特定的编码方式读取到控制台输出 4.  图片复制 4.  分块读取文件 ",
      "url"      : "https://kekaiyuan.github.io//2021/06/05/09-io/",
      "keywords" : "Java, IO"
    } ,
  
    {
      "title"    : "设计模式之——装饰者 Decorator",
      "category" : "DesignPatterns",
      "content": "设计模式之——装饰者 Decorator 装饰者模式 装饰者模式，是一种可以给对象无限加“装饰”的模式。 何为无限？ 数量无限 搭配无限 穿衣服是装饰者模式。 我可以穿任意数量衣服，一件、两件……。 我可以随意搭配衣服，衬衫 + 牛仔裤，羽绒服 + 围巾…… 奶茶也是装饰者模式。 可以假设杯子无限大，钱包也无限大，那么配料的数量就是无限多的。 配料的搭配也是无限多的。 概念  以下内容引用自 菜鸟教程 装饰器模式 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。 介绍 意图  动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。  主要解决  一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。  何时使用  在不想增加很多子类的情况下扩展类。  如何解决  将具体功能职责划分，同时继承装饰者模式。  关键代码  Component 类充当抽象角色，不应该具体实现。  修饰类引用和继承 Component 类，具体扩展类重写父类方法。  应用实例：  孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。  不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。  优点  装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。  缺点  多层装饰比较复杂。  使用场景  扩展一个类的功能。  动态增加功能，动态撤销。  注意事项  可代替继承。 实现 用装饰者模式实现一杯配料无限的超级奶茶。 装饰者模式的关键在于： 被装饰类和装饰类都必须继承于同一个抽象类。 被装饰类是装饰类的成员属性。 无限调用构造方法，形成类似于套娃的效果。 定义抽象类 Beverage，装饰类和被装饰类都必须继承于这个类 public abstract class Beverage { //饮料的描述  protected String description = null; public String getDescription() {  return description;  } //饮料的价格  public abstract double cost(); public void printDescription() {  System.out.println(getDescription() + : + cost() + 元);  } }  被装饰类：绿茶 public class GreenTea extends Beverage{ public GreenTea(){  this.description = 绿茶;  } @Override  public double cost() {  return 8;  } }  装饰抽象类：奶茶配料 public abstract class CondimentDecorator extends Beverage { //被装饰的对象  protected Beverage beverage = null; @Override  public abstract String getDescription(); }  装饰类 珍珠  //珍珠 public class Pearl extends CondimentDecorator{  public Pearl(Beverage beverage){   this.beverage = beverage;  }  //价格+1  @Override  public double cost() {   return beverage.cost()+1;  }  //添加描述  @Override  public String getDescription() {   return beverage.getDescription() + + 珍珠;  } }   椰果  //椰果 public class Coco extends CondimentDecorator{  public Coco(Beverage beverage){   this.beverage = beverage;  }  //价格+2  @Override  public double cost() {   return beverage.cost()+2;  }  //添加描述  @Override  public String getDescription() {   return beverage.getDescription() + + 椰果;  } }   测试 public static void main(String[] args) {  Beverage beverage = new GreenTea();  beverage.printDescription(); beverage = new Pearl(beverage);  beverage.printDescription(); beverage = new Pearl(beverage);  beverage.printDescription(); beverage = new Coco(beverage);  beverage.printDescription(); beverage = new Coco(beverage);  beverage.printDescription(); } 结果 绿茶 : 8.0 元 绿茶 + 珍珠 : 9.0 元 绿茶 + 珍珠 + 珍珠 : 10.0 元 绿茶 + 珍珠 + 珍珠 + 椰果 : 12.0 元 绿茶 + 珍珠 + 珍珠 + 椰果 + 椰果 : 14.0 元  总结 通过示例可以看到，只要愿意，我们可以无限地给绿茶加装饰。 而且其描述和价格是动态改变的，不需要我们关心。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/06/decorator/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "Java 学习笔记之 10 —— 线程",
      "category" : "Java",
      "content": "Java 学习笔记之 10 —— 线程 基本概念 程序 Program 程序是一个指令集合，是静态的。 我们平时编程所写的代码，就是程序。 进程 Process 进程指的是正在执行中的程序，是一个动态的概念。 一台电脑中可以运行多个进程，比如我们经常一边登着 QQ 和微信，一边放着音乐或视频，还打着游戏…… 它们之间互不干扰。 为什么？ 这是因为 CPU 会把时间划分为一个个固定的时间片，假定时间片大小为 5ms 。 那么第一个 5ms ：运行 QQ 进程。 第二个 5ms ：运行音乐或视频软件的进程。 第三个 5ms ：运行游戏进程。 第四个 5ms ：运行 QQ 进程。 …… CPU 会以一种极快的速度切换所执行的进程，这使得在人眼中看来：这些进程像是同时进行的。 这就是进程的宏观并行（同时执行），微观交替执行。 进程由三部分组成：  PCB 进程控制块 PCB中记录了操作系统所需的，用于描述进程的当前情况以及控制进程运行的全部信息。 这是一个进程最重要的模块，有了它，系统才能识别这个进程，并为它分配资源，使得它可以运行。   代码段 存放该进程对应的程序源码。 即程序员们所编写的那些代码。   数据段 存放着该进程的各类数据：原始数据，进程执行过程中产生的数据…… 线程 Thread 电脑需要一种并行技术，使得一台电脑可以运行多个程序，所以有了进程的概念。 进程也需要一种并行技术，使得进程内部可以并行地执行某些东西。 例如：游戏都有背景音乐。 如果进程内部是顺序执行的： ... 播放音乐 玩游戏 ... 如果是这种设计，那么在音乐停止之前，我们无法玩游戏。 我们想要的是这样的： ... 一边播放音乐 一边玩游戏 ... 就类似于电脑中： ... 一边使用 QQ 和微信 一边听音乐或看视频 一边玩游戏 ... 我们需要进程的进程，于是有了线程：进程中一个单一顺序的控制流。 操作系统将时间划分为固定大小的时间片，每个时间片服务一个进程。 进程内部再把时间片划分为更小的时间片，服务不同的线程。 这就使得一个进程也可以并行执行不同的任务。 线程和进程很类似，所以线程又被称为轻量级进程。 注意：  进程是资源分配的最小单位。 操作系统会给进程分配 CPU 、内存、外设等资源。 但是不会给线程分配资源，所有线程共享其进程的资源。 这也就意味着，线程之间的通信是非常简单的，因为它们共享内存。 它们可以随时从内存中取出其他线程的信息。 而进程之间的通信是非常困难的。 因为操作系统会阻止某进程访问其他进程的内存。   线程是调度的基本单位。 操作系统划分时间片给进程，进程又把时间划分给线程。 所以真正执行任务的是线程。   一个程序至少拥有一个线程。 在 Java 中，Main 方法是程序的入口，这其实就是程序的主线程。   线程结束，其进程不一定结束。 进程结束，其所有线程统统结束。   进程和线程的数量没有上限。 当然，进程和线程数量太多会引起很多问题，最常见的就是死机。 进程和线程的区别    区别  进程  线程     根本区别  作为资源分配的单位  调度和执行的单位    开销  每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销。  线程可以看成时轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小。    所处环境  在操作系统中能同时运行多个任务(程序)  在同一应用程序中有多个顺序流同时执行    分配内存  系统在运行的时候会为每个进程分配不同的内存区域  除了CPU之外，不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源    包含关系  没有线程的进程是可以被看作单线程的。如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。  线程是进程的一部分，所以线程有的时候被称为是轻权进程或者轻量级进程。   Java 中线程的实现 在Java中负责线程的这个功能的是Java.lang.Thread 这个类 .可以通过创建 Thread 的实例来创建新的线程。 .每个线程都是通过某个特定Thread对象所对应的方法run( )来完成其操作的，方法run( )称为线程体。 .通过调用Thread类的start()方法来启动一个线程。 继承 Thread 类 操作步骤： 继承 Thread 类  重写 run() 方法 run() 方法中的即是该线程的核心逻辑 创建 Thread 对象，调用 start() 方法启动线程 //继承 Thread 类 public class ThreadDemo extends Thread { //重写 run 方法  @Override  public void run() {  for (int i = 0; i &lt; 3; i++) {   System.out.println(Thread.currentThread().getName() + ------ + i);  }  } public static void main(String[] args) {  //创建对象  ThreadDemo thread1 = new ThreadDemo();  ThreadDemo thread2 = new ThreadDemo();  //调用 start 方法  thread1.start();  thread2.start();  } } 结果 Thread-0------0 Thread-1------0 Thread-0------1 Thread-1------1 Thread-0------2 Thread-1------2 注意： 如果调用了线程对象的 run() 方法，只是单纯地调用了方法，并没有启动线程。 只有调用了线程对象的 start() 方法，才真正地开启了线程，使得并行执行。 实现 Runnable 接口 操作步骤： 实现 Runnable 接口 重写 run() 方法 先创建 Runnable 对象 通过 Runnable 对象创建 Thread 对象 调用 start() 方法启动线程 //实现 Runnable 接口 public class RunnableDemo implements Runnable { //重写 run() 方法  @Override  public void run() {  for (int i = 0; i &lt; 3; i++) {   System.out.println(Thread.currentThread().getName() + ------ + i);  }  } public static void main(String[] args) {  //先创建 Runnable 对象  Runnable runnable1 = new RunnableDemo();  Runnable runnable2 = new RunnableDemo();   //通过 Runnable 对象创建 Thread 对象  Thread thread1 = new Thread(runnable1);  Thread thread2 = new Thread(runnable2);   //调用 start() 方法启动线程  thread1.start();  thread2.start();  } } 实际上 Thread 类本身就是继承自 Runnable 接口的 静态代理，调用的是 runnable 的 run 方法 案例演示–《卖票》 public static void main(String[] args) { new Ticket().start(); new Ticket().start(); new Ticket().start(); new Ticket().start(); } public static void main(String[] args) {  TicketImplements ti=new TicketImplements();  new Thread(ti).start();  new Thread(ti).start();  new Thread(ti).start();  new Thread(ti).start(); } 创建了5个线程对象，每个线程对象中都包含5张票，一共卖出40张票 创建了一个线程对象，启动了4次，四个线程所操作的是一个线程对象，实现了资源的共享 创建了5个线程对象，每个线程对象中都包含5张票，一共卖出40张票 创建了一个线程对象，启动了4次，四个线程所操作的是一个线程对象，实现了资源的共享 实现多线程的时候：  1、需要继承Thread类  2、必须要重写run方法，指的是核心执行的逻辑  3、线程在启动的时候，不要直接调用run方法，而是要通过start()来进行调用  4、每次运行相同的代码，出来的结果可能不一样，原因在于多线程谁先抢占资源无法进行人为控制 第二种实现方式：使用了代理设计模式  1、实现Runnable接口  2、重写run方法  3、创建Thread对象，将刚刚创建好的Runnable的子类实现作为thread的构造参数  4、通过thread.start()进行启动 两种实现方式哪种用的比较多 推荐使用第二种方式，  1、java是单继承，将继承关系留给最需要的类  2、使用runnable接口之后不需要给共享变量添加static关键字，每次创建一个对象，作为共享对象即可  线程的生命周期：  1、新生状态：  当创建好当前线程对象之后，没有启动之前（调用start方法之前）  ThreadDemo thread = new ThreadDemo()  RunnableDemo run = new RunnableDemo()  2、就绪状态：准备开始执行，并没有执行，表示调用start方法之后  当对应的线程创建完成，且调用start方法之后，所有的线程会添加到一个就绪队列中，所有的线程同时去抢占cpu的资源  3、运行状态：当当前进程获取到cpu资源之后，就绪队列中的所有线程会去抢占cpu的资源，谁先抢占到谁先执行，在执行的过程中就叫做运行状态  抢占到cpu资源，执行代码逻辑开始  4、死亡状态：当运行中的线程正常执行完所有的代码逻辑或者因为异常情况导致程序结束叫做死亡状态   进入的方式：    1、正常运行完成且结束    2、人为中断执行，比如使用stop方法    3、程序抛出未捕获的异常  5、阻塞状态：在程序运行过程中，发生某些异常情况，导致当前线程无法再顺利执行下去，此时会进入阻塞状态，进入阻塞状态的原因消除之后，    所有的阻塞队列会再次进入到就绪状态中，随机抢占cpu的资源，等待执行  进入的方式：   sleep方法   等待io资源   join方法（代码中执行的逻辑）  注意：  在多线程的时候，可以实现唤醒和等待的过程，但是唤醒和等待操作的对应不是thread类   而是我们设置的共享对象或者共享变量  t t  t t  t t 多线程并发访问的时候回出现数据安全问题：  解决方式：  1、同步代码块   synchronized(共享资源、共享对象，需要是object的子类){具体执行的代码块}  2、同步方法   将核心的代码逻辑定义成一个方法，使用synchronized关键字进行修饰，此时不需要指定共享对象 JAVA中实现多线程（二） .继承Thread类方式的缺点：那就是如果我们的类已经从一个类继承（如小程序必须继承自 Applet 类），则无法再继承 Thread 类 .通过Runnable接口实现多线程 .优点：可以同时实现继承。实现Runnable接口方式要通用一些。 .1)避免单继承 .2)方便共享资源 同一份资源 多个代理访问 上机练习 –创建线程，输出1~100之间的偶数。要求使用两种方式创建线程 线程的代理设计模式 真实角色:潘金莲 代理角色:王婆 实现共同的接口KindWoman 真实角色:MyThread 代理角色:Thread 实现共同的接口Runnable 线程状态 graph LR; A((创建)) --start()--&gt; B[就绪状态] B --调度--&gt; C[运行状态] C --调度--&gt; B C --导致阻塞的事件--&gt; D[阻塞状态] D --阻塞解除--&gt; B C --&gt; E((终止)) 线程的状态 .新生状态 –用new关键字建立一个线程后，该线程对象就处于新生状态。 –处于新生状态的线程有自己的内存空间，通过调用start()方法进入就绪状态。 .就绪状态 –处于就绪状态线程具备了运行条件，但还没分配到CPU，处于线程就绪队列，等待系统为其分配CPU。 –当系统选定一个等待执行的线程后，它就会从就绪状态进入执行状态，该动作称为“CPU调度”。 .运行状态 –在运行状态的线程执行自己的run方法中代码,直到等待某资源而阻塞或完成任何而死亡。 –如果在给定的时间片内没有执行结束，就会被系统给换下来回到等待执行状态。 .阻塞状态 –处于运行状态的线程在某些情况下，如执行了sleep(睡眠)方法，或等待I/O设备等资源，将让出CPU并暂时停止自己运行，进入阻塞状态。 –在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续执行。 .死亡状态 –死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有三个，一个是正常运行 的线程完成了它的全部工作；另一个是线程被强制性地终止，如通过stop方法来终止一个 线程【不推荐使用】；三是线程抛出未捕获的异常。 线程操作的相关方法 序号 方法名称 描述 1 public static Thread currentThread() 返回目前正在执行的线程 2 public final String getName() 返回线程的名称 3 public final int getPriority() 返回线程的优先级 4 public final void setPriority(String name) 设定线程名称 5 public final boolean isAlive() 判断线程是否在活动，如果是，返回true,否则返回false 6 public final void join() 调用该方法的线程强制执行，其它线程处于阻塞状态，该线程执行完毕后，其它线程再执行 7 public static void sleep(long millis) 使用当前正在执行的线程休眠millis秒,线程处于阻塞状态 8 public static void yield() 当前正在执行的线程暂停一次，允许其他线程执行,不阻塞，线程进入就绪状态,如果没有其他等待执行的线程，这个时候当前线程就会马上恢复执行。 9 public final void stop() 强迫线程停止执行。已过时。不推荐使用。 notify 和 wait 阻塞状态(sleep/yield/join方法) .有三种方法可以暂停Thread执行： 1.sleep： 不会释放锁，Sleep时别的线程也不可以访问锁定对象。 yield: 让出CPU的使用权，从运行态直接进入就绪态。让CPU重新挑选哪一个线程进入运行状态。 join: 当某个线程等待另一个线程执行结束后，才继续执行时，使调用该方法的线程在此之前执行完毕，也就是等待调用该方法的线程执行完毕后再往下继续执行 上机练习 .需求说明 –定义一个线程A，输出1 ～ 10之间的整数，定义一个线程B，逆序输出1 ～ 10之间的整数，要求线程A和线程B交替输出 .分析 –使用sleep()方法阻塞当前线程 锁 多线程访问同一个资源时经常会发生安全问题。 例如： 现实生活中，厕所好比 CPU ，只有一个，上厕所的人好比线程，轮流使用厕所。 如果厕所没有锁，一个人进去上厕所，上了一小会，另一个人冲进来也要上厕所。 这肯定是不合适的。 所以厕所都有锁，谁进去上厕所了，就把厕所锁上。 此时有人也要上厕所，他发现厕所被锁上了，他就知道里面有人，他会在外面先等待里面的人结束。 在计算机中也是如此。 当多线程访问同一个资源时，这里的资源往往指的是共享数据。 线程 1 需要修改数据，线程 2 也要修改数据，线程 3 …… 如果没有锁的控制： 线程 1 改数据改到一半，被线程 2 抢走了，当线程 1 再次拿到数据时，这份数据已经不是它当初要改的那份数据了。 所以在多线程中，锁是一个非常重要的技术点。 案例 有一个银行账户，其中有 5000 元，丈夫和妻子轮流从中取 1000 元，取完为止。 无锁 class Account {  //账户余额  private int balance = 0; public Account(int balance) {  this.balance = balance;  } public int getBalance() {  return balance;  } //取钱  public void draw(int money) {  balance -= money;  } } class Person0 implements Runnable {  Account account = null; public Person0(Account account) {  this.account = account;  } @Override  public void run() {  while (true) {   try {    Thread.sleep(1);   } catch (InterruptedException e) {    e.printStackTrace();   }   if (account.getBalance() &gt;= 1000) {    account.draw(1000);    System.out.println(Thread.currentThread().getName() +     取了 1000 元,还剩 + account.getBalance() + 元);   }   if (account.getBalance() &lt;= 0) {    return;   }  }  } } public static void main(String[] args) {  Account account = new Account(5000);  Runnable runnable0 = new Person0(account);  new Thread(runnable0, 丈夫).start();  new Thread(runnable0, 妻子).start();  } 结果 丈夫取了 1000 元,还剩 4000 元 妻子取了 1000 元,还剩 4000 元 妻子取了 1000 元,还剩 3000 元 丈夫取了 1000 元,还剩 2000 元 丈夫取了 1000 元,还剩 1000 元 妻子取了 1000 元,还剩 0 元 可以看到，程序出现了 BUG： 前两次取钱操作的结果不对，导致一共取了 6000 元。  synchronized 锁的是对象 synchronized 的使用很灵活。 但是无论代码是怎样的，synchronized 锁的永远是对象。 根据对象的不同可以划分为两种锁： 实例对象锁 类对象锁 这两者的区别在哪儿？ 类对象是程序之前就加载好的，每个类永远只有一个类对象。 而实例对象是通过实例化类对象创建的，可以有很多个。 这也就导致了：       实例对象锁  类对象锁     上锁对象  实例对象  类对象    可以同步同一个实例的不同线程吗  是  是    可以同步不同实例的线程的吗  否  是   根据上锁的方式又可分为：  同步代码块  sychronized (object){ 具体执行的代码块 }  在括号中填入代表着共享资源的对象，往往使用 this 关键字代表当前对象。   同步方法 将核心的代码逻辑定义成一个方法，使用synchronized关键字进行修饰，此时不需要指定共享对象。 需要注意： 只把不能互斥访问的代码设置为同步，请尽量少（但不要影响功能）。 同步的代码量越多，效率越差。 实例对象锁 同步代码块 class SyncBlock implements Runnable { @Override  public void run() {  while (true) {   synchronized (this) {    System.out.println(Thread.currentThread().getName() + ---- + System.currentTimeMillis());    try {    Thread.sleep(1000);    } catch (InterruptedException e) {    e.printStackTrace();    }   }   try {    Thread.sleep(1000);   } catch (InterruptedException e) {    e.printStackTrace();   }  }  } } 测试 Runnable runnable = new SyncBlock(); new Thread(runnable,A).start(); new Thread(runnable,B).start(); new Thread(runnable,C).start(); 线程 A , B , C 是同一个 Runnable 对象创建的不同实例 结果 B----1626407708812 C----1626407709824 B----1626407710838 A----1626407711849 B----1626407712851 A----1626407713861 同步了同一实例的不同线程。 new Thread(new SyncBlock(),A).start(); new Thread(new SyncBlock(),B).start(); new Thread(new SyncBlock(),C).start(); C----1626407840700 B----1626407840700 A----1626407840700 B----1626407842714 A----1626407842714 C----1626407842714    ```v ### 锁类对象 ## 锁实例方法 用 synchronized 修饰不能并发执行的方法。 能锁住同一个对象的不同线程。 ```java //方法锁 class MethodLock implements Runnable { @Override  public void run() {  while (true) {   try {    Thread.sleep(1000);   } catch (InterruptedException e) {    e.printStackTrace();   }   lock();  }  } public synchronized void lock() {  System.out.println(Thread.currentThread().getName() + ---- + System.currentTimeMillis());  try {   Thread.sleep(1000);  } catch (InterruptedException e) {   e.printStackTrace();  }  } } lock() 方法被 synchronized 修饰后，同一对象的不同线程不能同时调用该方法，同一时刻至多有一个线程可以使用该方法。 测试： 方法锁能锁住同一对象的不同线程 public static void main(String[] args) {  //方法锁能锁住同一对象的不同线程  {   Runnable runnable = new MethodLock();   new Thread(runnable, A).start();   new Thread(runnable, B).start();   new Thread(runnable, C).start();   new Thread(runnable, D).start();  }  } 线程 A ,B ,C ,D 都是通过 runnable 建立的，它们是同一对象的不同线程。 结果 C----1626355653686 D----1626355654701 C----1626355655703 D----1626355656718 A----1626355657729 D----1626355658743 B----1626355659752 A----1626355660757  方法锁锁不住 不同对象的线程。 public static void main(String[] args) {  //方法锁锁不住不同对象的线程  {   new Thread(new MethodLock(), A).start();   new Thread(new MethodLock(), B).start();   new Thread(new MethodLock(), C).start();   new Thread(new MethodLock(), D).start();  }  } 线程 A ,B , C, D 是四个不同对象的线程，这时候方法锁无效。 结果 A----1626355951649 B----1626355951649 C----1626355951649 D----1626355951649 C----1626355953663 D----1626355953663 B----1626355953663 A----1626355953663 可以看到，同一时刻有四个方法在运行。 对象锁 语法： synchronized (对象){  t方法体 } 在 () 中填入需要锁住的对象，然后在方法体中填写不能并发执行的逻辑。 例 class ObjectLock implements Runnable { @Override  public void run() {  while (true) {   synchronized (this) {    System.out.println(Thread.currentThread().getName() + ---- + System.currentTimeMillis());    try {    Thread.sleep(1000);    } catch (InterruptedException e) {    e.printStackTrace();    }   }   try {    Thread.sleep(1000);   } catch (InterruptedException e) {    e.printStackTrace();   }  }  } } 对象锁和方法锁一样，能锁住同一对象的不同线程。 public static void main(String[] args) {  t//对象锁能锁住同一对象的不同线程  t{  t tRunnable runnable = new ObjectLock();  t tnew Thread(runnable, A).start();  t tnew Thread(runnable, B).start();  t tnew Thread(runnable, C).start();  t tnew Thread(runnable, D).start();  t} } 结果 A----1626356376585 B----1626356377601 A----1626356378610 C----1626356379618 A----1626356380622 C----1626356381635 A----1626356382638 D----1626356383639 锁不住不同对象的线程 public static void main(String[] args) {  t//对象锁锁不住不同对象的线程  t{  t tnew Thread(new ObjectLock(),A).start();  t tnew Thread(new ObjectLock(),B).start();  t tnew Thread(new ObjectLock(),C).start();  t tnew Thread(new ObjectLock(),D).start();  t} } 结果 A----1626356843348 B----1626356843348 C----1626356843348 D----1626356843348 D----1626356845362 C----1626356845362 B----1626356845362 A----1626356845362 类锁 方法锁和对象锁都锁不住不同对象的线程。 这很好理解。 对象锁，不同对象当然对应不同的锁。 方法锁，不同对象的方法是不同的  多线程的安全性问题 public class TicketImplements implements Runnable { private int tick=5; public void run() { while(true){  if (tick&gt;0) {  Thread.sleep(10);  System.out.println(Thread.currentThread().getName()+”卖票:”+tick–);  } } } public static void main(String[] args) { TicketImplements ti=new TicketImplements(); new Thread(ti).start(); new Thread(ti).start(); new Thread(ti).start(); new Thread(ti).start(); } 线程的同步不死锁 .多线程的运行出现了安全问题 银行账户问题 使用同步解决多线程的安全性问题 .同步代码块 public void run() { while(true){ synchronized (this) {//通常将当前对象作为同步对象  if (tick&gt;0) {   Thread.sleep(10); System.out.println(Thread.currentThread().getName()+”卖票:”+tick–); }    }  } } AAAAA 使用同步解决线程的安全性问题 .同步的前提: .(1)必须有两个或两个以上的线程 .(2)必须是多个线程使用同一资源 .(3)必须保证同步中只能有一个线程在运行 同步方法解决线程的安全性问题 .将需要同步的代码放到方法中 public void run() {  while(true){ sale();  } } public synchronized void sale(){ //通常将当前对象作为同步对象 if (tick&gt;0) {  Thread.sleep(10);   System.out.println(Thread.currentThread().getName()+”卖票:”+tick–); } } 线程同步小结 .同步监视器 –synchronized(obj){}中的obj称为同步监视器 –同步代码块中同步监视器可以是任何对象，但是推荐使用共享资源作为同步监视器 –同步方法中无需指定同步监视器，因为同步方法的监视器是this，也就是该对象本身 .同步监视器的执行过程 –第一个线程访问，锁定同步监视器，执行其中代码 –第二个线程访问，发现同步监视器被锁定，无法访问 –第一个线程访问完毕，解锁同步监视器 –第二个线程访问，发现同步监视器未锁，锁定并访问 上机练习 .需求说明 –张三和妻子各拥有一张银行卡和存折，可以对同一个银行账户进行存取款的操作，请使用多线程及同步方法模拟张三和妻子同时取款的过程。要求使用同步方法和同步代码块两种方式实现 .分析 –定义Account类表示银行帐户 –定义两个线程分别实现张三和妻子取款的操作 同步方法.JPG 死锁 .同步可以保证资源共享操作的正确性，但是过多同步也会产生死锁  .死锁一般情况下表示互相等待，是程序运行时出现的一种问题 线程的生产者不消费者 .生产者不断生产，消费者不断取走生产者生产的产品  .生产者生产产品放到一个区域中，之后消费者从此区域里取出产品 线程通信 .Java提供了3个方法解决线程之间的通信问题 方法名 作用 final void wait() 表示线程一直等待，直到其它线程通知 final void wait(long timeout) 线程等待指定毫秒参数的时间 final void wait(long timeout,int nanos) 线程等待指定毫秒、微妙的时间 final void notify() 唤醒一个处于等待状态的线程 final void notifyAll() 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先运行 注意事项：以上方法都只能在同步方法或者同步代码块中使用，否则会抛出异常 Object 类中的等待不唤醒 上机练习 .需求说明 –使用线程通信解决生产消费者问题 .分析 –定义共享资源类 –定义生产者线程类 –定义消费者线程类 优先级高的不一定先执行，只是概率增大，等待时间 本章总结 【1】程序、进程、线程 【2】线程的创建方式，实现Runnable接口或继承Thread类 【3】线程状态：创建，新绪，运行，阻塞，消亡 【4】线程冻结的几种情况   该线程对象的wait方法   该线程本身调用sleep方法   该线程一另一个线程的join在一起 【5】解冻，使用线程进入阻塞的几种情况  该线程对象的nofity唤醒   sleep方法，休眠时间到了 【6】run方法执行结束，线程进入消亡状态 【7】当多个对象操纵同一共享资源时，要使用同步方法或同步代码块来进行资源的同步处理 【8】过多的同步将产生死锁 【9】生产者与消费者问题（同步，等待与唤醒） 源码链接 该文章源码链接 Github Yield 只让出一下 CPU 返回到就绪状态，依然会去试图抢占 cpu join 不要关闭线程，让线程正常结束 stop 不要用 底层框架会使用 interrupt ，但是不要用 interrupt 控制业务逻辑 synchronized 是可重入锁 synchronized 不能用 String 常量 Interger Long 用 object 线程同步 锁的是对象不是代码 this XX.Class 锁定方法 非锁定方法 同时执行 ",
      "url"      : "https://kekaiyuan.github.io//2021/06/06/10-thread/",
      "keywords" : "Java"
    } ,
  
    {
      "title"    : "设计模式之——责任链 Chain of Responsibility",
      "category" : "DesignPatterns",
      "content": "设计模式之——责任链 Chain of Responsibility 责任链 责任链是一个类似于流水线的设计模式。 通过三个问题理解责任链模式： Q1 假如现在程序里有类 A，然后需要依次调用 100 个方法处理 A 最简单的实现肯定是这样的 A a = new A(); method1(a); method2(a); method3(a); …… method100(a); return a;  Q2 如果说这 100 个方法不需要全部调用，而是选择式的。 即先调用 method1() 处理，如果处理成功，则不调用剩下的方法。 如果处理失败，则调用 method2()…… A a = new A(); if(method1(a)){  return a; } if(method2(a)){  return a; } if(method3(a)){  return a; } …… method100(a); return a; 这样的调用方式肯定是不好的，一个比较抖机灵的办法是自定义异常。 如果这 100 个方法抛出了该异常，则代表处理成功。 A a = new A(); try{  method1(a);  method2(a);  method3(a);  ……  method100(a); }catch(MyException e){  t…… }finally{  return a; } 虽然这个方法有一些小问题，但确实是可行的。 Q3 实现这些方法的动态扩展。 即我可以随时添加某个方法，也可以删除某个方法。 Q1 和 Q2 还可以尝试用最粗暴的编程思想去解决，但是 Q3 却没有解决办法。 在程序中加入大量的参数和选择语句肯定是不可行的，我们急需一种设计模式来解决这个问题。 于是责任链模式应运而生。 所有的处理方法组织成链式结构。 然后某个具体的处理方法可以决定处理对象是否已经处理完毕，是否需要交给下一个方法处理，或是直接结束处理流程。 这就以一个比较完美的程序设计解决了 Q1 和 Q2。 至于 Q3，所有的处理类继承于同一个接口，然后可以用 List 这样的集合来保存这些处理类。 然后调用 List 类的 add() 和 remove() 方法就可以很简单的实现动态扩展。 概念  以下内容引用自 菜鸟教程 责任链模式 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。 介绍 意图  避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。  主要解决  职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。  何时使用  在处理消息的时候用以过滤很多道。  如何解决  拦截的类都实现统一接口。  关键代码  Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。  应用实例  红楼梦中的”击鼓传花”。  JS 中的事件冒泡。  JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。  优点  降低耦合度。它将请求的发送者和接收者解耦。  简化了对象。使得对象不需要知道链的结构。  增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。  增加新的请求处理类很方便。  缺点  不能保证请求一定被接收。  系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。  可能不容易观察运行时的特征，有碍于除错。  使用场景  有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。  在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。  可动态指定一组对象处理请求。  注意事项  在 JAVA WEB 中遇到很多应用。 实现 定义接口 public interface ProcessInterface {  boolean execute(Object o); }  定义三个实现类 public class Process1 implements ProcessInterface {  @Override  public boolean execute(Object o) {  System.out.println(执行方法 1);  Random random = new Random();  if (random.nextInt(10) &gt; 8) {   return true;  }  return false;  } } public class Process2 implements ProcessInterface {  @Override  public boolean execute(Object o) {  System.out.println(执行方法 2);  Random random = new Random();  if (random.nextInt(10) &gt; 8) {   return true;  }  return false;  } } public class Process3 implements ProcessInterface {  @Override  public boolean execute(Object o) {  System.out.println(执行方法 3);  Random random = new Random();  if (random.nextInt(10) &gt; 8) {   return true;  }  return false;  } }  责任链 public class ChainOfResponsibility implements ProcessInterface {  private List&lt;ProcessInterface&gt; chain = new ArrayList&lt;ProcessInterface&gt;(); public void addMethod(ProcessInterface method){  chain.add(method);  } public void removeMethod(ProcessInterface method){  chain.remove(method);  } @Override  public boolean execute(Object o) {  for (ProcessInterface method : chain) {   boolean result = method.execute(o);   if(result){    return true;   }  }  return false;  } }  说明 类之间是解耦的，不知道彼此的存在，它们的组合由责任链控制。 方法的返回值任意，不一定是 boolean，用 int, String, Object 都可以。 甚至可以是 void，通过读取参数的值或是抛出异常来实现。 只要能提供一个判断依据即可。 责任链最好也实现接口，这样多个责任链的结构统一，而且可以实现多个责任链的组合。 责任链  public class ColliderChain implements Collider {  private List&lt;Collider&gt; colliders = new LinkedList&lt;&gt;();  public ColliderChain() {   add(new BulletTankCollider());   add(new TanksCollider());   add(new BulletWallCollier());   add(new TankWallCollider());  }  public void add(Collider collider) {   colliders.add(collider);  }  @Override  public boolean collide(GameObject o1, GameObject o2) {   for (int i = 0; i &lt; colliders.size(); i++) {   if (colliders.get(i).collide(o1, o2)) {    return false;   }   }   return true;  } }    ColliderChain 继承 Collider 的好处    可以把责任链合并     为什么 collider 方法的返回值是 boolean    实现责任链的断开。   BulletTankCollider 是碰撞链的第一环，当它检测到传入责任链的参数是坦克和子弹时，那么就没有必要把参数传入下一环。     如何调用  //碰撞检测的责任链 ColliderChain colliderChain = new ColliderChain();  t //碰撞检测，使用责任链 for (int i = 0; i &lt; objects.size(); i++) {   for (int j = i + 1; j &lt; objects.size(); j++) {   GameObject o1 = objects.get(i);   GameObject o2 = objects.get(j);   colliderChain.collide(o1, o2);   }  }  objects 是存储坦克大战中所有游戏对象的数组。 只需要用双重循环遍历游戏对象所有可能的两两组合，并把组合传入责任链中，即可实现碰撞检测。 这样写可以实现程序的解耦，无论责任链怎么变，外部的调用都不需要修改。 Servlet中的责任链 Servlet 是常用的前后端交互的技术，它把前端发送的请求传入后端进行处理然后再返回给前端。 从 Client 到 Server ，称为 Request 。 从后端到 Client ，称为 Response 。 在这个过程中，需要用到多个 Filter 过滤器对数据进行处理。 Request 需要 Filter 过滤掉不必要的前端信息。 Response 需要 Filter 加上必要的前端信息。 如果采用这样的设计 这需要实现两个责任链，六个 Filter ，而且需要建立两次 Http 请求。 一次 Http 请求是从 可以改进一下，使用一条责任链完成 假设现在有三个过滤器， 从前端到后端，需要经过 Filter1 , Filter2 , Filter3 从后端到前端，需要经过 Filter3 , Filter2 , Filter1 过滤器在数据的往返时都需要用到，而且顺序是相反的。 这种设计应该如何用责任链实现?  源码链接 该文章源码链接 url ",
      "url"      : "https://kekaiyuan.github.io//2021/06/07/chain-of-responsibility/",
      "keywords" : "Java,设计模式"
    } ,
  
    {
      "title"    : "Java 学习笔记之 11 —— 线程池",
      "category" : "Java",
      "content": "序言 在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。 于是有了线程池的概念： 把所有线程都放到一个“池”中，当需要并发执行任务时，就从线程池中拿出一个线程使用。 原来： 创建一个新的线程。 现在：  从线程池中取出一个线程。  使用完后将线程放回线程池中。 线程主要有两个好处： 使用线程池可以重复利用已有的线程继续执行任务，避免线程在创建和销毁时造成的消耗，提高系统响应速度。 通过线程池可以对线程进行合理的管理，避免许多问题。 线程池的创建 使用如下代码创建线程池： ThreadPoolExecutor executor = new ThreadPoolExecutor(...); 其构造方法有五个必选参数，两个可选参数。    参数  说明     corePoolSize  核心线程池的大小    maximumPoolSize  线程池能创建线程的最大个数    keepAliveTime  空闲线程存活时间    unit  keepAliveTime 的时间单位    workQueue  保存任务的阻塞队列    threadFactory  创建线程的工厂类    handler  饱和策略（拒绝策略）   简单解释一下七个参数： 线程池的概念很简单： 用一个“池子”存储所有的线程，当某任务需要线程时，从池中取出一个线程，任务执行结束后，将线程放回池子中。 核心线程池 线程池线程数量的初始值。 这些线程是不会被销毁的，即使它们是空闲的。  线程池刚创建时核心线程池为空，随着任务的增多而不断开辟线程。  如果设置了 allowCoreThreadTimeOut=true，那么核心线程池的线程会被超时销毁。  如果线程运行时发生异常，该线程会被销毁，并立刻创建一个新的线程替代。   线程池的最大容量 当阻塞队列满了，此时如果又有新的任务，就需要创建新的线程为其服务。 无限制地创建线程会带来很严重的问题，所以应该设置一个上限。 空闲线程存活时间  核心线程池之外的线程在被创建后，如果一段时间内都为空闲状态，会被销毁。  当该时间设置为 0 时，则是无限期的。 存活时间的时间单位 毫秒、秒、分钟…… 阻塞队列 当核心线程池已满，新的任务会被存入某个队列中等待空闲线程的调用。 threadFactory  可以使用 工厂模式 来创建线程。 饱和策略  当线程池达到最大容量时，使用某种策略处理新的任务。 工作原理 当有新的任务时： 如果核心线程池未满，则直接开辟新线程。 如果核心线程池已满，放入阻塞队列等待空闲线程。 如果阻塞队列已满，直接开辟新线程。 如果线程池达到最大容量，则根据饱和策略处理新任务。 执行方法 启动线程使用的是 start() 方法。 而线程中启动线程用的是 executor() 和 submit() executor() 只能接受 Runnable 接口  submit() 能接受 Runnable 接口和 Callable 接口 Runnable 接口的 run() 方法无返回值。 Callable 接口的 call() 方法有返回值，可以通过 Future 对象获取返回值。 线程池的生命周期 线程池有两种状态，三种过渡状态 graph LR; A(Running) --shutdown()--&gt; B1(SHUTDOWN); A --shutdownNow()--&gt; B2(STOP); B1 --阻塞队列为空，线程池中的工作线程数量为 0--&gt; C(TIDYING); B2 --线程池中的工作线程数量为 0--&gt; C; C --terminated()--&gt; D(TERMINATED);   线程的生命周期  说明     RUNNING  能接受新提交的任务，并且也能处理阻塞队列中的任务    SHUTDOWN  关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。    STOP  不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。    TIDYING  如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用terminated() 方法进入TERMINATED 状态。    TERMINATED  在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。   线程池的关闭 shutdown() 将线程池状态设为 SHUTDOWN，然后中断所有没有正在执行任务的线程。 shutdownNow() 将线程池状态设为 STOP，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表。 线程池的分类 newCachedThreadPool  线程池的大小不是固定的，最大可达到 Integer.MAX_VALUE。  线程池中的线程存活时间很短，只有 60 秒。  当线程池中没有可用线程时就创建新线程。   newFixedThreadPool  固定大小。  除非被显式关闭，否则池中的线程一直存在。  多余的线程将在 LinkedBlockingQueue 中等待。   newSingleThreadExecutor  只有一个工作线程。  LinkedBlockingQueue   newScheduledThreadPool  线程池中的线程数量有一个初始值。 任意时间都不会低于初始值，即使线程是空闲的。  可定时或延迟地执行线程活动。   newWorkStealingPool  创建一个带并行级别的线程池，并行级别决定了同一时刻最多有多少个线程在执行。 默认情况下并行级别为当前系统的 CPU 个数。   尽管 JDK 中定义了许多线程池，但还是建议使用 ThreadPoolExecutor executor = new ThreadPoolExecutor(...); 手写参数来生成线程池，能够更好地理解该线程池的细节。 阻塞队列 ArrayBlockingQueue  基于数组实现。 用一个定长数组维护队列中的数据对象。 还保存了两个整形变量标识着队列的头部和尾部在数组中的位置。  只有一个锁。 生产者和消费者无法真正并行运行。  在构造时也选择公平锁或非公平锁。   LinkedBlockingQueue  基于链表实现。  生产者一般不会被阻塞，除非队列已满（默认为 Integer.MAX_VALUE）。  生产者和消费者用的是两把锁，并发度更高。   DelayQueue  一般很特殊的队列，使用场景较少。  队列中的元素只有当其指定的延迟时间到了，才能被取出。  没有大小限制。 生产者永远不会被阻塞。 只有消费者会被阻塞。   PriorityBlockingQueue  基于优先级（通过构造函数传入的 Comparator 对象决定）的阻塞队列。  不会阻塞生产者，只会阻塞消费者。 所以要注意生产速度，否则会耗尽堆空间。  使用公平锁。   SynchronousQueue  与之前的阻塞队列不同，它没有缓冲区。 所以生产者和消费者很容易被阻塞（不能把数据丢进缓冲区就跑），必须找到对应的对象进行“交易”。  吞吐量会降低，但响应速度可以会变快。  公平模式：    使用公平锁和 FIFO 队列维护生产者和消费者。     非公平模式：    使用非公平锁和 LIFO 队列维护生产者和消费者。   会发生“饿死”（某些生产者或消费者永远等不到处理）。     面试常问：ArrayBlockingQueue 和 LinkedBlockingQueue 的区别：  ArrayBlockingQueue 的消费者和生产者共有同一个锁。 LinkedBlockingQueue 的消费者和生产者使用分离锁。  ArrayBlockingQueue 必须指定大小（因为是数组）。 LinkedBlockingQueue 可以不指定队列大小，默认下 Integer.MAX_VALUE。   拒绝策略 ThreadPoolExecutor.AbortPolicy  丢弃任务并抛出RejectedExecutionException异常。   ThreadPoolExecutor.DiscardPolicy  丢弃任务，但是不抛出异常。   ThreadPoolExecutor.DiscardOldestPolicy  丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）.   ThreadPoolExecutor.CallerRunsPolicy  由调用线程处理该任务   ",
      "url"      : "https://kekaiyuan.github.io//2021/06/07/11-thread-pool/",
      "keywords" : "Java"
    } ,
  
    {
      "title"    : "设计模式之——观察者 Observer",
      "category" : "DesignPatterns",
      "content": "设计模式之——观察者 Observer 观察者模式 观察者是非常常用的模式，在Java中，以下名词均是观察者模式 Observer 观察者 Listener 监听器 Hook 钩子 Callback 回调函数 其意义也非常容易理解。 该模式中有观察者和被观察者，在被观察者做出某种行为后，所有观察者都需要作出某种反应。 比如说有十个人在观察一个花的花开。 当花开的时候。 这十个人都应该观察到“花开”，并作出响应。 概念  以下内容引用自 菜鸟教程 观察者模式 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。 介绍  意图   定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。    主要解决   一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。    何时使用   一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。    如何解决   使用面向对象技术，可以将这种依赖关系弱化。    关键代码   在抽象类里有一个 ArrayList 存放观察者们。    应用实例   拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。  西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。    优点   观察者和被观察者是抽象耦合的。  建立一套触发机制。    缺点   如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。  如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。    使用场景   一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。  一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。  一个对象必须通知其他对象，而并不知道这些对象是谁。  需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。    注意事项   JAVA 中已经有了对观察者模式的支持类。  避免循环引用。  如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。   代码示例 通过一个案例说明观察者的设计。 孩子是被观察者，爸爸、妈妈、小狗是观察者。 观察的事件是孩子的哭，当孩子哭时，爸爸会找食物，妈妈会抱孩子，小狗会叫。  UML图  抽象事件类  abstract class Event&lt;T&gt; {  T source;  public T getSource(){   return source;  }; }    记录细节    在观察者模式有事件的概念，是因为根据细节的不同，观察者会有不同的行为，此时需要将观察时的细节记录下来，就有了事件类。例如该例子就是哭事件CryEvent，记录孩子在哪里哭的，在什么时间哭的…     代码复用    Event类是所有具体的事件类的父类，因为可能不同的事件调用的是观察者的同一个方法，如果将观察者的方法形参写为某个具体的事件类，那么其他的事件类将无法传入方法。而如果将方法形参写为Event类，那么就可以实现一个方法处理多种事件。     事件源source    上面代码中的source代表着事件源，即事件的源头是谁发出的，即被观察者是谁。在通过Event类完成一个方法处理多种事件的同时，我们希望能让观察者知道该事件是由谁发出的，这样观察者就可以做出一些细节上的调整。   除了作出细节的调整，观察者还可以利用事件源调用事件源的方法。     具体事件类  class CryEvent&lt;T&gt; extends Event{  long timestamp;  String location;  public CryEvent(long timestamp, String location, T source) {   this.timestamp = timestamp;   this.location = location;   super.source = source;  } }    记录哭的时间、地点、事件源   观察者接口  interface Observer {  void actionOnCry(Event event); }    定义所有观察者都需要实现的方法。   具体的观察者  class Dad implements Observer {  @Override  public void actionOnCry(Event event) {   if (event.getSource() instanceof Child) {   System.out.println(dad feeding...);   }  } } class Mom implements Observer {  @Override  public void actionOnCry(Event event) {   if (event.getSource() instanceof Child) {   System.out.println(mom hugging...);   }  } } class Dog implements Observer {  @Override  public void actionOnCry(Event event) {   if (event.getSource() instanceof Child) {   System.out.println(dog wang...);   }  } }   被观察者  class Child {  private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();  //添加观察者  {   observers.add(new Dad());   observers.add(new Mom());   observers.add(new Dog());  }  public void cry(String location) {  //记录事件   CryEvent event = new CryEvent(System.currentTimeMillis(), location, this);  //通知所有观察者   for (Observer o : observers) {   o.actionOnCry(event);   }  } }   完整代码及测试 public class Main {  tpublic static void main(String[] args) {  t tChild child = new Child();  t tchild.cry(bed);  t tSystem.out.println(------);  t tChild2 child2 = new Child2();  t tchild2.cry(bed);  t} } class Child {  tprivate List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();  t//添加观察者  t{  t tobservers.add(new Dad());  t tobservers.add(new Mom());  t tobservers.add(new Dog());  t}  tpublic void cry(String location) {  t t//记录事件  t tCryEvent event = new CryEvent(System.currentTimeMillis(), location, this);  t t//通知所有观察者  t tfor (Observer o : observers) {  t t to.actionOnCry(event);  t t}  t} } class Child2 {  tprivate List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();  t//添加观察者  t{  t tobservers.add(new Dad());  t tobservers.add(new Mom());  t tobservers.add(new Dog());  t}  tpublic void cry(String location) {  t t//记录事件  t tCryEvent event = new CryEvent(System.currentTimeMillis(), location, this);  t t//通知所有观察者  t tfor (Observer o : observers) {  t t to.actionOnCry(event);  t t}  t} } abstract class Event&lt;T&gt; {  tT source;  tpublic T getSource() {  t treturn source;  t} } class CryEvent&lt;T&gt; extends Event {  tlong timestamp;  tString location;  tpublic CryEvent(long timestamp, String location, T source) {  t tthis.timestamp = timestamp;  t tthis.location = location;  t tsuper.source = source;  t} } interface Observer {  tvoid actionOnCry(Event event); } class Dad implements Observer {  t@Override  tpublic void actionOnCry(Event event) {  t tif (event.getSource() instanceof Child) {  t t tSystem.out.println(dad feeding...);  t t}  t} } class Mom implements Observer {  t@Override  tpublic void actionOnCry(Event event) {  t tif (event.getSource() instanceof Child) {  t t tSystem.out.println(mom hugging...);  t t}  t} } class Dog implements Observer {  t@Override  tpublic void actionOnCry(Event event) {  t tif (event.getSource() instanceof Child) {  t t tSystem.out.println(dog wang...);  t t}  t} } 结果  dad feeding... mom hugging... dog wang... ------   结论 可以看到Child2和Child的代码一模一样，但是观察者并没有对Child2的哭作出反应。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/08/observer/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "Github 如何写脚注",
      "category" : "Github",
      "content": "Github 如何写脚注 如何在Github中使用脚注？ md标准格式 文章内容[^1] [^1]: 脚注1的说明 文章内容1 自定义锚点 文章内容&lt;sup id=a1&gt;[[1]](#f1)&lt;/sup&gt; &lt;span id=f1&gt;1[.^](#a1)&lt;/span&gt; 脚注1的说明 文章内容[1] 1.^ 脚注1的说明 注意：”[“与”^”之间必须隔开，可以是空格、小数点等一切字符   脚注1的说明 &#8617;  ",
      "url"      : "https://kekaiyuan.github.io//2021/06/08/footnote/",
      "keywords" : "Github，脚注"
    } ,
  
    {
      "title"    : "Java 学习笔记之 12 ——网络",
      "category" : "Java",
      "content": "Java 学习笔记之 12 ——网络 基本概念 网络 一组相互连接的计算机  多台计算机组成  使用物理线路进行连接    网络编程的三要素 IP地址  唯一标识网络上的每一台计算机  两台计算机之间通信的必备要素   端口号  计算机中应用的标号(代表一个应用程序)  0-1024为系统使用或保留端口，不可使用  0-65536为有效端口   通信协议  通信的规则  TCP，UDP   网络模型 OSI参考模型  开放系统互连参考模型（Open System Interconnect）   TCP/IP参考模型  传输控制/网际协议 Transfer Controln Protocol/Internet Protocol   IP地址的表示方法 IP地址  32位，由4个8位二进制数组成   IP表示方法  点分十进制   IP地址 = 网络ID +主机ID  网络ID    标识计算机或网络设备所在的网段     主机ID    标识特定主机或网络设备     IP地址好比人的居住地，网络ID指住在哪个城市，主机ID指住在城市里的哪个地方   特殊的IP地址  0.0.0.0    本机     127.0.0.1    本机回环地址，用于本机测试     255.255.255.255    当前子网，一般用于向当前子网广播信息     IP地址的分类 根据网络ID和主机ID的长度可以把IP地址划分为五类       网络ID  主机ID  最高位  网络数量  每个网络可容纳主机数  用途     A类  1字节  3字节  0  126  1600万+  大规模网络    B类  2字节  2字节  10  16382  6万+  中等规模网络    C类  3字节  1字节  110  209万+  254  小规模网络    D类        1110        多点广播    E类        1111        保留用于将来和实验使用   地址范围  A: 1.0.0.1-127.255.255.254    0代表任何地址   127为回环测试地址   127.0.0.1是一个特殊的IP地址，表示主机本身，用于本地机器的测试     B: 128.0.0.1-191.255.255.254  C: 192.0.0.1-223.255.255.254  D: 224.0.0.0-239.255.255.255  E: 240.0.0.0-255.255.255.255   InetAddress类 这是Java中对应IP地址的类  端口 端口:port  端口是虚拟的概念，并不是说在主机上真的有若干个端口。通过端口，可以在一个主机上运行多个网络应用程序。   传输协议 UDP  不面向连接的，不可靠的协议。    只负责把数据发出去，不在意数据是否能被接收。   适用于要求速度，不要求质量的场景。     音视频聊天。         数据报的大小限制在64k内。  效率较高，不安全，容易丢包。   TCP  面向连接的，可靠的协议。    连接双方会建立起一个稳定的通道，用于传输数据。   三次握手        原因      为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。    假设只有两次握手。        客户端第一次发送的请求报文段丢失了，第二次发送的请求报文段被服务端成功收到，两者建立连接传输数据然后断开了。过了一段时间后第一次丢失的请求报文段被服务端收到了，服务端开始等待与客户端建立连接。但此时客户端已经不想要建立连接了。                   四次挥手        第四次分手： 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。   原因      TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。         为什么要等待2MSL？      MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。    原因        保证TCP协议的全双工连接能够可靠关闭，防止主机2没收到Fin。     保证这次连接的重复数据段从网络中消失。                     Socket套接字 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 Java中使用Socket完成TCP程序的开发，使用此类可以方便的建立可靠的、双向的、持续性的、点对点的通讯连接。 在Socket的程序开发中，服务器端使用ServerSocket等待客户端的连接。 对于java的网络程序来讲，每一个客户端都使用一个Socket对象表示。 基于TCP协议的Socket编程 进行网络通信时，Socket需要借助数据流来完成数据的传递工作 代码示例：用户登录功能  Udp的测试 一个小测试：通过udp发送数据  启动服务器——&gt;启动客户端——&gt;客户端发送数据包    成功     启动客户端——&gt;启动服务器——&gt;客户端发送数据包    成功     启动客户端——&gt;客户端发送数据包——&gt;启动服务器    失败     结论    udp通信双方的启动顺序没有要求，但是必须双方都启动后再传输数据     注意 在通过socket传输对象时，发送和接收的对象包名应该保持一致，否则会出现java.lang.ClassNotFoundException的异常！ 源码链接 本文源码链接 https://github.com/kky970614/javase/tree/main/code/netdemo TCP通信  客户端向服务端单方向通信  客户端与服务端双向通信  通过Socket复制图片  登录功能，包括重复登录和用线程实现服务器与客户端之间一对多   UDP通信  客户端向服务端单方向通信  ",
      "url"      : "https://kekaiyuan.github.io//2021/06/08/12-net/",
      "keywords" : "Java, net"
    } ,
  
    {
      "title"    : "设计模式之——组合 Composite",
      "category" : "DesignPatterns",
      "content": "设计模式之——组合 Composite 组合模式 组合模式是一种将一组相似的对象组合成单一对象的模式。 典型就是文件系统。 文件组合成文件夹，但是文件夹并没有脱离文件的范畴。 文件夹依然与文件一样，可以与其他的文件或文件夹组成新的文件夹。 组合模式是一个对应树状结构的设计模式。 组合模式很简单，“组合” 和 “个体” 都继承于某个类，而 “组合” 只比 “个体” 多了个 add 方法和 remove 方法。 比如说。 人是对象，一群人就是一组人的组合。作为个体的“人”和作为组合的“一群人”都继承于人这个概念。 人能做什么，一群人也能做什么，组合无法脱离个体的属性范畴。 “你给我认真听讲！” “你给赶紧吃饭！” 把 “你” 换成 “你们” ，这些话依然是合理的。 组合唯一多出来的，就是增加和删除。 一群人中加入一个人或是一群人中踢掉某个人。 仅此而已。 概念 以下内容引用自 菜鸟教程 组合模式 组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。 这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。 介绍 意图  将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。  主要解决  它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。  何时使用  您想表示对象的部分-整体层次结构（树形结构）。  您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。  如何解决  树枝和叶子实现统一接口，树枝内部组合该接口。  关键代码  树枝内部组合该接口，并且含有内部属性 List，里面放 Component。  应用实例  算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数。  在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。  优点  高层模块调用简单。  节点自由增加。  缺点  在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。  使用场景  部分、整体场景，如树形菜单，文件、文件夹的管理。  注意事项  定义时为具体类。 案例 如何用组合模式模拟一个只有文件名的简单文件系统？ 该文件系统有文件和文件夹两种成员，文件夹下可以添加任意个文件夹和文件。  UML图  抽象类  文件夹和文件都继承于这个抽象类   abstract class Node {  //打印该节点的内容  abstract public void print(); }     文件  在树状结构中，没有子节点的节点称为叶子节点   //叶子节点 class LeafNode extends Node {  //文件名  String content;  public LeafNode(String content) {this.content = content;}  @Override  public void print() {   System.out.println(content);  } }     文件夹  在树状机构中，有子节点的节点叫做分支节点   //分支节点 class BranchNode extends Node {  //该文件夹下的列表，包括文件夹和文件  List&lt;Node&gt; nodes = new ArrayList&lt;&gt;();  //文件夹名  String name;  public BranchNode(String name) {this.name = name;}  @Override  public void print() {   System.out.println(name);  }  //添加子节点  public void add(Node n) {   nodes.add(n);  } }     使用方法  首先定义根目录。   BranchNode root = new BranchNode(root);     在根目录下添加文件。   Node r1 = new LeafNode(r1); root.add(r1);     在根目录下添加文件夹。   BranchNode chapter1 = new BranchNode(chapter1); root.add(chapter1);     子文件夹的操作雷同。   遍历 树状结构的遍历建议使用递归。  //遍历node下的所有内容，depth为该节点的高度 static void tree(Node node, int depth) {  //为了美观，打印-为文件分级  for(int i=0; i&lt;depth; i++) {   System.out.print(-);  }  //打印节点  node.print();  //遍历节点下的子节点  if(node instanceof BranchNode) {   for (Node n : ((BranchNode)node).nodes) {   tree(n, depth + 1);   }  } }   结果  root -chapter1 --c11 --c12 -chapter2 --section21 ---c211 ---c212 -r1   注意 遍历树状结构时最好使用递归，虽然会增加资源消耗，但是编程简单，不易出错。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/09/composite/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "socket 通信时 read 方法阻塞问题",
      "category" : "Java",
      "content": "socket通信用的是InputStream和OutputStream这两个Io流，其中InputStream的read方法会有阻塞的风险  原因  read方法在读完所有的数据，检测到流的末尾时，会返回值-1。这往往作为我们结束循环的标志。   while (read() != -1) {  read(); }     在读取文件时，文件的长度是可知的，流的末尾是可见的。  但在socket通信时，流的末尾却是不可见的。接受方并不知道发送方是否还会继续发送数据，这时read方法就会阻塞。    这很容易理解，假设现在有两个人通过socket传输一份文件，在一份文件传输完毕后，人脑知道已经没有下一份文件了，可以结束通信。但是电脑并不知道，它觉得可能还会有第二份文件、第三份文件…所以它就会阻塞地等待下一个数据的到来。     解决方案  接收方    设置超时，会在设置的超时时间到达后抛出SocketTimeoutException异常而不再阻塞。   在头部约定好数据的长度。当读取到的长度等于这个长度时就不再继续调用read方法。   约定结束标志，当读到该结束标志时退出不再read。     发送方    调用socket的shutdownOutput方法关闭输出流，该方法的文档说明为，将此套接字的输出流置于“流的末尾”，这样另一端的输入流上的read操作就会返回-1。不能调用socket.getInputStream().close()。这样会导致socket被关闭。   调用socket.close()，该方法的文档说明为，任何线程当前被阻塞在这个套接字上的I / O操作将会抛出一个socket Exception。   上面两种方案都能使read方法返回-1     ",
      "url"      : "https://kekaiyuan.github.io//2021/06/09/socket-read-block/",
      "keywords" : "Java, socket"
    } ,
  
    {
      "title"    : "Java 学习笔记之 13 —— lambda表达式",
      "category" : "Java",
      "content": "Java 学习笔记之 13 —— lambda表达式 代码进化之路[1] 通过下文来一看为什么jdk8会有lambda表达式的诞生 现在有一个Student类 public class Student {  private String name;  private int age;  private int score;  t//无参构造方法、有参构造方法、对应的get和set方法省略  t... } 我们现在需要将Student类的对象根据不同的要求输出，假设现在需要输出age &gt; 14的对象和score&gt;75的对象 基础版 age &gt; 14  public static void findByAge(ArrayList&lt;Student&gt; students) {  ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();  for (Student stu : students) {   if(stu.getAge() &gt; 14) {   list.add(stu);   }  }  for (Student student : list) {   System.out.println(student);  } }   score&gt;75  public static void findByScore(ArrayList&lt;Student&gt; students) {  ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();  for (Student stu : students) {   if(stu.getScore() &gt; 75) {   list.add(stu);   }  }  for (Student student : list) {   System.out.println(student);  } }   直接编写对应的方法，这是最基础也最容易理解的。  有多少个要求就编写多少个对应的方法，代码量大，程序臃肿   策略模式版 引进策略模式，策略模式的链接enter description here 抽象策略角色  public interface StudentFilter {  boolean compare(Student student); }   具体策略角色  public class AgeFilter implements StudentFilter{  @Override  public boolean compare(Student student) {   return student.getAge()&gt;14;  } }  public class ScoreFilter implements StudentFilter{  @Override  public boolean compare(Student student) {   return student.getScore()&gt;75;  } }   如何调用  public static void main(String[] args) {  ArrayList&lt;Student&gt; list = new ArrayList&lt;Student&gt;();  list.add(...);  list.add(...);  ...  getByFilter(list, new AgeFilter());  getByFilter(list, new ScoreFilter()); } public static void getByFilter(ArrayList&lt;Student&gt; students, StudentFilter filter){  ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();  for (Student student : students) {   if (filter.compare(student)) {   list.add(student);   }  }  for (Student student : list) {   System.out.println(student);  } }    先编写一个抽象的策略角色接口，里面声明了策略方法，然后根据要求编写具体的策略角色，实现具体的策略方法，最后根据要求调用不同的策略角色就可以。  比起基础版的进化之处    优点     提高了代码复用性，简化了代码。       缺点     策略类数量会增多，每个策略都是一个类。         匿名内部类版 enter description here 继承了策略模式中的StudentFilter接口和getByFilter方法，但是并没有编写任何一个具体的策略角色，而是根据需要编写匿名内部类  getByFilter(list, new StudentFilter() {  @Override  public boolean compare(Student student) {   return student.getAge()&gt;14;  } }); getByFilter(list, new StudentFilter() {  @Override  public boolean compare(Student student) {   return student.getScore()&gt;75;  } });   比起策略模式版的进化之处  不需要编写具体的策略角色类，类的数量大大减少   终极无敌之lambda版 依然继承了策略模式中的StudentFilter接口和getByFilter方法，但是使用时代码量极少  getByFilter(list, (e) -&gt; e.getAge() &gt; 14); getByFilter(list, (e) -&gt; e.getScore() &gt; 75);   比起匿名内部类版的进化之处  代码量极大的降低，程序十分简洁   源码链接 该文章源码链接。。。。。 1.^代码进化之路的具体代码 ",
      "url"      : "https://kekaiyuan.github.io//2021/06/09/13-lambda/",
      "keywords" : "Java，lambda"
    } ,
  
    {
      "title"    : "设计模式之——享元 Flyweight",
      "category" : "DesignPatterns",
      "content": "设计模式之——享元 Flyweight 享元模式 重复利用现有对象，避免创建新对象，减少对系统资源的使用。 像各类游戏的场景就十分适合使用享元模式。 树木、汽车、路人这一类重复性非常高的对象，如果每一个都是一个独立的对象，多大的内存都吃不消。 这时候就应该使用享元，让它们指向同一个对象。 概念  以下内容引用自 菜鸟教程 享元模式 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 Circle 对象。 介绍 意图  运用共享技术有效地支持大量细粒度的对象。  主要解决  在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。  何时使用  系统中有大量对象。  这些对象消耗大量内存。  这些对象的状态大部分可以外部化。  这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。  系统不依赖于这些对象身份，这些对象是不可分辨的。  如何解决  用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。  关键代码  用 HashMap 存储这些对象。  应用实例  JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。  数据库的数据池。  优点  大大减少对象的创建，降低系统的内存，使效率提高。  缺点  提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。  使用场景  系统有大量相似对象。  需要缓冲池的场景。  注意事项  注意划分外部状态和内部状态，否则可能会引起线程安全问题。  这些类必须有一个工厂对象加以控制。 使用  享元模式最常用的方式是缓存池，线程池、常量池都属于享元模式。   现在有类A，组建一个类A的缓存池APool。 当我们需要使用一个A的对象时，不要使用A a = new A(XXX); 而是使用A a = APool.getA(XXX) 池会查找有没有符合要求的A对象，如果有的话，返回该对象的引用。 如果没有的话，那就return new A(XXX); 在返回新对象的同时，可以考虑将新对象存入缓存池，也可以不存。 这个取决于该新对象之后是否会被重复使用。 在Java中String str = abc;这条语句执行之前常量池里是没有abc的。 在这条语句执行后，常量池里就有了abc 之后再执行String str2 = abc;，str2就会和str1指向常量池中的abc，而不会创建新对象。   int的包装类Integer也使用了享元模式。 Integer类里有个数组存放了值为-128~127的int类型。 当我们使用int a = new Integer(x);时。 如果x的值在-128~127的闭区间，返回数组里的成员。 只有当超出范围后，Integer类才会创建一个新对象。   uml图  享元模式还可以与组合模式搭配使用。 圆是图元，正方形也是图元。当圆和正方形的搭配使用次数非常多时，就可以把这个搭配作为新的图元存入缓存池。 ppt中就有这个功能，把多个图元框选在一起设置为组合。 设置之后这个组合就成了新的图元，可以执行移动、缩放、复制等操作。 缓存池中也多了一个由圆和正方形组成的图元。 ",
      "url"      : "https://kekaiyuan.github.io//2021/06/10/flyweight/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "Java 学习笔记之 14 —— Stream API",
      "category" : "Java",
      "content": "Stream 是一组用来处理数组和集合的 API，属于函数式编程。 也是 Java 8 引入的，Java 8 之所以引入函数式编程，原因有二： 代码简洁函数式编程写出的代码简洁且意图明确，使用 Stream 接口让你从此告别 for 循环。 多核友好，Java 函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下 parallel() 方法。 Stream 特性 不是数据结构，没有内部存储 不支持索引访问 延迟计算 支持并行 很容易生成数组或集合（List，Set） 支持过滤，查找，转换，汇总，聚合等操作  例子： // 创建一个 List 对象 List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 创建：从 List 对象直接创建 Stream Stream&lt;Integer&gt; stream0 = list.stream(); // 中间操作：过滤能被 2 整除的数 Stream&lt;Integer&gt; stream1 = stream0.filter(x -&gt; x % 2 != 0); // 中间操作：过滤能被 3 整除的数 Stream&lt;Integer&gt; stream2 = stream1.filter(x -&gt; x % 3 != 0); // 中间操作：过滤能被 5 整除的数 Stream&lt;Integer&gt; stream3 = stream2.filter(x -&gt; x % 5 != 0); // 终止操作：生成一个新的 List 对象 List&lt;Integer&gt; result = stream3.collect(Collectors.toList()); // 输出结果：1，7 result.forEach(System.out::println); 这是一个很简单的 Stream 应用。 创建了一个 List 对象 通过 List 对象直接创建 Stream 对象 Stream 就是为了以一种更好的方式操作集合的，所以集合类都有 stream() 方法用于直接生成一个 Stream 对象 对 Stream 进行操作，filter() 是一个过滤器，当返回值为 true 时会被过滤掉  stream0: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10  stream1: 1, 3, 5, 7, 9  stream2: 1, 5, 7  stream2: 1, 7   然后将 Stream 对象转为 List 对象，并输出其中的元素：1, 7 可以看到，操作确实很方便。 那么接下来，就要探究一些原理性的问题了： Stream 到底是什么？ 是以下的方式吗？ classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal: +int age Animal: +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } flowchart TD  Start --&gt; Stop A--&gt;B class BankAccount{  t+String owner  t+BigDecimal balance  t+deposit(amount) bool  t+withdrawl(amount) int } class Car Driver - Car : drives &gt; Car *- Wheel : have 4 &gt; Car -- Person : &lt; owns pie title Pets adopted by volunteers Dogs : 386 Cats : 85 Rats : 35   Stage  Direct Products  ATP Yields     Glycolysis  2 ATP       ^^  2 NADH  3–5 ATP    Pyruvaye oxidation  2 NADH  5 ATP    Citric acid cycle  2 ATP       ^^  6 NADH  15 ATP    ^^  2 FADH  3 ATP    30–32 ATP         a Stream 特性 1： 2： 3： 4： 5： 6： http://mashibing.com 北京马士兵教育 公众号：马士兵 《 Java系列课程》 Stream运行机制 Stream分为 源source，中间操作，终止操作 流的源可以是一个数组、一个集合、一个生成器方法，一个I/O通道等等。 一个流可以有零个和或者多个中间操作，每一个中间操作都会返回一个新的流，供下一个操作使用。一个流只会有一个终止操作 Stream只有遇到终止操作，它的源才开始执行遍历操作 http://mashibing.com 北京马士兵教育 公众号：马士兵 《 Java系列课程》 Stream的创建 1、通过数组 2、通过集合来 3、通过Stream.generate方法来创建 4、通过Stream.iterate方法来创建 5、其他API创建 http://mashibing.com 北京马士兵教育 公众号：马士兵 《 Java系列课程》 Stream常用API 中间操作 过滤 filter 去重 distinct 排序 sorted 截取 limit、skip 转换 map/flatMap 其他 peek http://mashibing.com 北京马士兵教育 公众号：马士兵 《 Java系列课程》 Stream常用API 终止操作 循环 forEach 计算 min、max、count、 average 匹配 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny 汇聚 reduce 收集器 toArray collect ———- Content here Stream 的使用方法 Stream 的生成 通过数组 String[] strs = {a,b,c,d}; Stream&lt;String&gt; strs1 = Stream.of(strs); strs1.forEach(System.out::println); 通过集合 List&lt;String&gt; list = Arrays.asList(1,2,3,4); Stream&lt;String&gt; stream = list.stream(); stream.forEach(System.out::println); 通过 Stream 的 generate() 方法 Stream&lt;Integer&gt; generate = Stream.generate(()-&gt;1); generate.forEach(System.out::println); 打印无数个 1 Stream&lt;Integer&gt; generate = Stream.generate(()-&gt;1); generate.limit(10).forEach(System.out::println); 打印 10 个 1 通过 Stream 的 iterator() 方法 Stream&lt;Integer&gt; iterate = Stream.iterate(1, x -&gt; x + 1); iterate.forEach(System.out::println); 1 2 3 4 5 6 ……无限打印 Stream&lt;Integer&gt; iterate = Stream.iterate(1, x -&gt; x + 1); iterate.limit(10).forEach(System.out::println); 1 2 3 4 5 6 7 8 9 10 通过其他的 API 创建 String str = abcdefg; IntStream stream =str.chars(); stream.forEach(System.out::println); Stream 的中间操作 过滤操作 过滤操作 filter Stream&lt;Integer&gt; stream = Arrays.asList(1, 2, 3, 4, 5).stream(); stream.filter((x)-&gt;x%2==0).forEach(System.out::println); 取出数组中的偶数 求和操作 int count = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9).stream().mapToInt(x -&gt; x).sum(); System.out.println(count); 求最大值 List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6); Optional&lt;Integer&gt; max = list.stream().max((a, b) -&gt; a - b); System.out.println(max.get()); 求最小值 List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6); Optional&lt;Integer&gt; min = list.stream().min((a, b) -&gt; a - b); System.out.println(min.get());  public static&lt;T&gt; Builder&lt;T&gt; builder() { 终止操作 判断 allMatch boolean allMatch(Predicate&lt;? super T&gt; predicate); 判断是否所有元素都满足表达式 Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9); boolean match1 = stream.allMatch(x -&gt; x &gt; 0); boolean match2 = stream.allMatch(x -&gt; x &gt; 5);  所有的元素都大于 0，match1 = true 只有部分元素大于 5，match2 = false anyMatch boolean anyMatch(Predicate&lt;? super T&gt; predicate); 判断是否有任意元素满足表达式 Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9); boolean match = stream.anyMatch(x -&gt; x == 9); stream 中存在元素 9，match = true+++ + ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++6++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ++++++++ ++++ +++++ 聚合 collect collect 将 Stream 流聚合为集合类 直接聚合，常用  &lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);    List&lt;?&gt; collect = stream.collect(Collectors.toList());  Set&lt;?&gt; collect = stream.collect(Collectors.toSet());  Map&lt;?, ?&gt; collect = map.entrySet().stream().collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));   自定义，使用较少  &lt;R&gt; R collect(Supplier&lt;R&gt; supplier,    BiConsumer&lt;R, ? super T&gt; accumulator,    BiConsumer&lt;R, R&gt; combiner);  ",
      "url"      : "https://kekaiyuan.github.io//2021/06/10/14-stream-api/",
      "keywords" : "Java, Stream"
    } ,
  
    {
      "title"    : "设计模式之——代理 Proxy",
      "category" : "DesignPatterns",
      "content": "设计模式之——代理 Proxy 代理模式 考虑这样一件事。 现在有一个写好的类，其中有各种各样的方法和属性。 有一天，我想给这个类添加权限控制，有权限的才能调用这个类。 于是我去改改改…… 又有一天，我想给这个类添加日志控制，打印各种信息。 于是我又去改改改…… 又又有一天，我觉得这两个控制都很麻烦，我不想要了！ 于是我又又去改改改…… 突然，有个智者告诉我，为什么不找个代理替我做这些事呢？ 就像明星和经纪人。 明星不知道哪些厂商值得合作，哪些不值得。 但是他可以找个懂这个的经纪人帮他做。 明星不知道时下什么东西最流行，经纪人会帮他收集。 …… 明星有很多事情不会，但是他不需要去学，去改变自己。 他只需要找到合适的经纪人作为他的代理就好了。 在编程中，代理模式就是在不改变类的前提下，添加一些功能。 概念  以下内容引用自 菜鸟教程 代理模式 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。 在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 介绍 意图  为其他对象提供一种代理以控制对这个对象的访问。  主要解决  在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。  何时使用  想在访问一个类时做一些控制。  如何解决  增加中间层。  关键代码  实现与被代理类组合。  应用实例  Windows 里面的快捷方式。  猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。  买火车票不一定在火车站买，也可以去代售点。  一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。  spring aop。  优点  职责清晰。  高扩展性。  智能化。  缺点  由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。  实现代理模式需要额外的工作，有些代理模式的实现非常复杂。  使用场景  按职责来划分，通常有以下使用场景  远程代理。  虚拟代理。  Copy-on-Write 代理。  保护（Protect or Access）代理。  Cache代理。  防火墙（Firewall）代理。  同步化（Synchronization）代理。  智能引用（Smart Reference）代理。  注意事项  和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。  和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 代理类型 静态代理 代码示例 public class Main { public static void main(String[] args) {  new TankTimeProxy(new Tank()).move();  System.out.println(------);   new TankLogProxy(    new TankTimeProxy(     new Tank()    )  ).move();  System.out.println(------);  new TankTimeProxy(    new TankLogProxy(     new Tank()    )  ).move();  } } //时间代理，计算程序运行的时间 class TankTimeProxy implements Movable {  Movable movable; public TankTimeProxy(Movable movable) {  this.movable = movable;  } @Override  public void move() {  long start = System.currentTimeMillis();  movable.move();  long end = System.currentTimeMillis();  System.out.println(end - start);  } } //日志代理，输出日志 class TankLogProxy implements Movable {  Movable movable; public TankLogProxy(Movable movable) {  this.movable = movable;  } @Override  public void move() {  System.out.println(start moving...);  movable.move();  long end = System.currentTimeMillis();  System.out.println(stopped!);  } } class Tank implements Movable {  /** * 模拟坦克移动了一段儿时间 */  @Override  public void move() {  System.out.println(Tank moving claclacla...);  try {   Thread.sleep(new Random().nextInt(1000));  } catch (InterruptedException e) {   e.printStackTrace();  }  } } interface Movable {  void move(); } 结果 Tank moving claclacla... 322 ------ start moving... Tank moving claclacla... 598 stopped! ------ start moving... Tank moving claclacla... stopped! 465 静态代理的关键时代理类和被代理类实现同一个接口。 然后代理类在方法中可以调用被代理类的方法，并且加入一些操作。 比如该案例就是输出程序运行时间的时间代理和打印日志的日志代理。 由于静态代理实现了接口，所以静态代理可以嵌套。 越外层的代理越晚实现，类似于递归。 动态代理 在静态代理中，代理类只能代理实现了 Movable 接口的类，也就是只能代理单一接口。 但是在动态代理中，代理类可以代理所有接口。 Java中所谓的动态，指的是在执行的时候改变类的属性和方法。 JDK自带的动态代理 JDK 自带的动态代理是通过 Proxy 类实现的。 动态生成 $Proxy0.class 文件，将代理类和被代理类关联到一起。 然后通过反射调用 .class 文件的内容。 被代理类需要实现接口 代码示例 public class Tank implements Movable { /** * 模拟坦克移动了一段时间 */  @Override  public void move() {  System.out.println(Tank moving claclacla...);  try {   Thread.sleep(new Random().nextInt(10000));  } catch (InterruptedException e) {   e.printStackTrace();  }  } public static void main(String[] args) {   System.getProperties().put(jdk.proxy.ProxyGenerator.saveGeneratedFiles,true);  Tank tank = new Tank();  Movable movable = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader(),    new Class[]{Movable.class},   new TimeProxy(tank)  );  movable.move(); } } class TimeProxy implements InvocationHandler {  Object object; public TimeProxy(Object object) {  this.object = object;  } public void before() {  System.out.println(method start..);  } public void after() {  System.out.println(method stop..);  } @Override  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  before();  Object o = method.invoke(object, args);  after();  return o;  } } interface Movable {  void move(); } 结果 method start.. Tank moving claclacla... method stop.. 仔细阅读源码会发现，明明没有调用 TimeProxy 类，但是 TimeProxy 类的 invoke 方法却被调用了 这就是动态代理。 通过正确地使用Java自带的Proxy类，JVM会自动地帮我们把被代理类和代理类关联起来。 原理  Proxy.newProxyInstance  以下内容引用自JDK1.8 API public static Object newProxyInstance(ClassLoader loader,                                                               类&lt;?&gt;[] interfaces,                                                               InvocationHandler h) 参数 loader - 类加载器来定义代理类 interfaces - 代理类实现的接口列表 h - 调度方法调用的调用处理函数 loader 是类加载器，一般设置为被代理类的类加载器。 interfaces 是接口列表，这就要求必须为被代理类实现一个接口，就像 Tank 的接口是 Movable。 h 是处理函数，这个才是我们真正需要编写的东西。   代理类 只需要照模板编写即可，Object o = method.invoke(object, args);为调用被代理类的方法。 所以在 before() 和 after() 里编写在被代理类执行前后需要代理类处理的东西。 可以看到，代理类中使用的是 Object 类，这是 Java 中所有类的父类。 因此我们使用这个类代理所有的类。 生成动态代理文件  System.getProperties().put(sun.misc.ProxyGenerator.saveGeneratedFiles,true);  该行代码很容易理解，英译汉就能够明白。 系统.获得配置文件.设置(“sun.misc.代理生成类.存储生成文件”,”true”); 像这种见名知意的代码都没有必要点进去看，这是让系统把我们代理中产生的文件保存下来。 加入该行代码后，系统会生成一个 com 目录，目录下有一个 $Proxy0.class 文件，这个就是我们动态代理的动态二字含义。 动态代理指的是，程序运行后会动态地生成一个 .class 文件，然后通过反射完成代理功能。 如果没有生成该目录，可能是路径名的原因。 老版本用的是System.getProperties().put(sun.misc.ProxyGenerator.saveGeneratedFiles,true);比如 Jdk 1.8 新版本用的是System.getProperties().put(jdk.proxy.ProxyGenerator.saveGeneratedFiles,true);比如 Jdk 12 如果不清楚，可以查找 ProxyGenerator 这个类，找到 saveGeneratedFiles 这个属性，看看他取的是哪个系统属性。  private static final boolean saveGeneratedFiles = (Boolean)AccessController.doPrivileged(new GetBooleanAction(sun.misc.ProxyGenerator.saveGeneratedFiles));  而在阅读 $Proxy0.class 文件后会发现，在 move() 方法中会加入 invoke() 方法。 这也就是为什么明明源码中没有调用代理类，却成功调用代理类的原因。  JDK动态代理执行过程 其中 Proxy 类生成 $Proxy0.class 文件的源码非常长，就不在本文中讲述了 通过 Cglib 实现动态代理 通过 cglib 实现动态代理，不仅不需要实现接口，而且实现更加简单。 只是需要额外的导包，可采用 Maven 的方式。 如何使用 IDEA 和 Maven 导入 Jar 包？通过 Maven 导入 Jar 包 import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; import java.util.Random; /** * CGLIB实现动态代理不需要接口 */ public class Main {  public static void main(String[] args) {  Enhancer enhancer = new Enhancer();  enhancer.setSuperclass(Tank.class);  enhancer.setCallback(new TimeMethodInterceptor());  Tank tank = (Tank)enhancer.create();  tank.move();  } } class TimeMethodInterceptor implements MethodInterceptor { void before(){  System.out.println(before);  } void after(){  System.out.println(after);  } @Override  public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {  t tSystem.out.println(o.getClass().getSuperclass().getName());  before();  Object result = methodProxy.invokeSuper(o, objects);  after();  return result;  } } class Tank {  public void move() {  System.out.println(Tank moving claclacla...);  try {   Thread.sleep(new Random().nextInt(10000));  } catch (InterruptedException e) {   e.printStackTrace();  }  } } 结果 com.kky.dp.proxy.dynamic.cglib.Tank before Tank moving claclacla... after 可以看到， cglib 创建了被代理类的子类，所有当被代理类是 Final 类时，无法使用 cglib 进行动态代理，但是 Jdk 方式可以代理 Final 类，因为它是使用了被代理类的接口。 区别 Jdk 方式  需要实现接口  操作繁琐  可以代理 Final 类   Cglib 方式  不需要实现接口  需要额外导包  操作简单  不可以代理 Final 类   源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/11/proxy/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "license",
      "category" : "Github",
      "content": "如何为代码选择开源许可证，这是一个问题。 世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种—-GPL、BSD、MIT、Mozilla、Apache和LGPL—-之中做选择，也很复杂。 乌克兰程序员Paul Bagwell，画了一张分析图，说明应该怎么选择。这是我见过的最简单的讲解，只用两分钟，你就能搞清楚这六种许可证之间的最大区别。 比较宽松的许可证是 MIT 许可证，只要用户在项目副本中包含了版权声明和许可声明，他们就可以拿你的代码做任何想做的事情，你也无需承担任何责任。 Apache 许可证类似 MIT 许可证，但它同时还包含了贡献者向用户提供专利授权相关的条款。 还有 GPL 许可证，这是一种copyleft许可证，要求修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。V3版本与V2类似，但其进一步约束了在某些限制软件更改的硬件上的使用范围。 https://zhuanlan.zhihu.com/p/51331026 github上的license ",
      "url"      : "https://kekaiyuan.github.io//2021/06/11/license/",
      "keywords" : "Github,license"
    } ,
  
    {
      "title"    : "设计模式之——迭代器 Iterator",
      "category" : "DesignPatterns",
      "content": "设计模式之——迭代器 Iterator 迭代器是一个专门用于遍历集合元素的工具，在Java中各种集合框架都已经实现了自身的迭代器。 概念  以下内容引用自 菜鸟教程 迭代器模式 迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 迭代器模式属于行为型模式。 介绍 意图  提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。  主要解决  不同的方式来遍历整个整合对象。  何时使用  遍历一个聚合对象。  如何解决  把在元素之间游走的责任交给迭代器，而不是聚合对象。  关键代码  定义接口：hasNext, next。  应用实例  JAVA 中的 iterator。  优点  它支持以不同的方式遍历一个聚合对象。  迭代器简化了聚合类。  在同一个聚合上可以有多个遍历。  在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。  缺点  由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。  使用场景  访问一个聚合对象的内容而无须暴露它的内部表示。  需要为聚合对象提供多种遍历方式。  为遍历不同的聚合结构提供一个统一的接口。  注意事项  迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。 案例 实现 ArrayList 和 LinkedList ，并实现各自的 Iterator UML 图 Colletion_  public interface Collection_&lt;T&gt; {  void add(T object);  int size();  Iterator_ iterator(); }   Iterator_  public interface Iterator_&lt;T&gt; {  //是否存在下一个元素  boolean hasNext();  //取出当前元素并指向下一个元素  T next(); }   ArrayList_  class ArrayList_&lt;T&gt; implements Collection_&lt;T&gt; {  T[] objects = (T[]) new Object[10];  //数组中第一个空余的位置，等同于数组的长度  private int index = 0;  public void add(T object) {   //如果数组已满   if (index == objects.length) {   //拓展一个两倍长度数组   T[] newObjects = (T[]) new Object[objects.length * 2];   //把原数组数据复制到新数组中   System.arraycopy(objects, 0, newObjects, 0, objects.length);   //返回新数组   objects = newObjects;   }  objects[index] = object;   index++;  }  public int size() {   return index;  }  @Override  public Iterator_&lt;T&gt; iterator() {   return new ArrayListIterator();  }  private class ArrayListIterator&lt;T&gt; implements Iterator_&lt;T&gt; {  //当前元素下标   private int currentIndex = 0;  //是否存在下一个元素   @Override   public boolean hasNext() {   if (currentIndex &gt;= index) {    return false;   } else {    return true;   }   }  //取出当前元素，并指向下一个元素   @Override   public T next() {   T object = (T) objects[currentIndex];   currentIndex++;   return object;   }  } }   LinkedList_  class LinkedList_&lt;T&gt; implements Collection_&lt;T&gt; {  //头结点  Node head = null;  //尾结点  Node tail = null;  //目前容器中有多少个元素  private int size = 0;  public void add(T object) {   Node node = new Node(object);   node.next = null;  if (head == null) {   head = node;   tail = node;   }  tail.next = node;   tail = node;   size++;  }  private class Node {   private T object;   Node next;  public Node(T object) {   this.object = object;   }  }  public int size() {   return size;  }  @Override  public Iterator_ iterator() {   return new LinkedListIterator();  }  private class LinkedListIterator implements Iterator_&lt;T&gt; {  //当前结点   Node node = head;  //是否存在下一个元素   @Override   public boolean hasNext() {   if (node != null) {    return true;   }else{    return false;   }  }  //取出当前元素，并指向下一个元素   @Override   public T next() {   T object = node.object;   node = node.next;   return object;   }  } }   测试  public class Main {  public static void main(String[] args) {   Collection_&lt;String&gt; list = new ArrayList_&lt;&gt;();   for(int i=0; i&lt;15; i++) {   list.add(new String(s + i));   }   System.out.println(list.size());  //使用迭代器遍历   Iterator_&lt;String&gt; it = list.iterator();   while(it.hasNext()) {   String string = it.next();   System.out.print(string+ );   }  System.out.println(  --------------);  Collection_&lt;String&gt; linkedList = new LinkedList_&lt;&gt;();   for(int i=0; i&lt;15; i++) {   linkedList.add(new String(s + i));   }   System.out.println(linkedList.size());  //使用迭代器遍历   Iterator_&lt;String&gt; it2 = linkedList.iterator();   while(it2.hasNext()) {   String string = it2.next();   System.out.print(string+ );   }  } }   结果  15 s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 s12 s13 s14 -------------- 15 s0 s1 s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 s12 s13 s14  源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/12/iterator/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "设计模式之——访问者 Visitor",
      "category" : "DesignPatterns",
      "content": "设计模式之——访问者 Visitor 在结构不变的情况下动态改变对于内部元素的动作 结构固定 语法树、文件解析 源码链接 该文章源码链接 url ",
      "url"      : "https://kekaiyuan.github.io//2021/06/13/visitor/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "设计模式之——建造者 Builder",
      "category" : "DesignPatterns",
      "content": "设计模式之——建造者 Builder 序言 建造者是一个用于建造复杂对象的模式，用于分离复杂对象的构建和表示。 就像电脑是一个非常复杂的对象，我们可以把它拆分为 CPU, GPU, 主板…… 然后分别建造这些部件，最后组合到一起。 而且这样的设计我们可以很灵活地替换其中的某个部件。 这是一个无需死记硬背的设计模式，只需要在创建复杂对象把创建过程拆分就可以自然地使用。 概念 建造者模式 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 介绍 意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。 何时使用：一些基本部件不会变，而其组合经常变化的时候。 如何解决：将变与不变分离开。 关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。 应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。 优点： 1、建造者独立，易扩展。 2、便于控制细节风险。 缺点： 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。 使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。 注意事项：与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 案例 电脑是一个非常复杂的类，属性非常的多。 现在使用建造者模式实现一个简单的电脑类： 只包含 CPU, GPU, 主板，而且这些部件也比较简单。 Computer 类 public class Computer {  CPU cpu;   //CPU  GPU gpu;   //GPU  MainBoard mainBoard; //主板 @Override  public String toString() {  return cpu.toString() +   + gpu.toString() +   + mainBoard.toString();  } } class CPU {  String producer; //制造商  String model;  //型号  String frequency; //主频  Integer coreNum; //核心数 public CPU(String producer, String model, String frequency, Integer coreNum) {  this.producer = producer;  this.model = model;  this.frequency = frequency;  this.coreNum = coreNum;  } @Override  public String toString() {  return CPU{ +    producer=' + producer + '  '' +    , model=' + model + '  '' +    , frequency=' + frequency + '  '' +    , coreNum= + coreNum +    '}';  } } class GPU {  String producer; //制造商  String model;  //型号  String memory; //内存大小 public GPU(String producer, String model, String memory) {  this.producer = producer;  this.model = model;  this.memory = memory;  } @Override  public String toString() {  return GPU{ +    producer=' + producer + '  '' +    , model=' + model + '  '' +    , memory=' + memory + '  '' +    '}';  } } class MainBoard {  String producer;  //制造商  String model;   //型号  String interfaceType; //接口类型 public MainBoard(String producer, String model, String interfaceType) {  this.producer = producer;  this.model = model;  this.interfaceType = interfaceType;  } @Override  public String toString() {  return MainBoard{ +    producer=' + producer + '  '' +    , model=' + model + '  '' +    , interfaceType=' + interfaceType + '  '' +    '}';  } }  定义建造者的接口，包括各部分的建造方法和总的建造方法 public interface ComputerBuilder {  //返回类型为 ComputerBuilder 是为了链式编程  ComputerBuilder buildCPU(String producer, String model, String frequency, Integer coreNum); ComputerBuilder buildGPU(String producer, String model, String memory); ComputerBuilder buildMainBoard(String producer, String model, String interfaceType); Computer build(); }  实现一个建造者类 ComplexComputerBuilder public class ComplexComputerBuilder implements ComputerBuilder {  Computer computer = new Computer(); @Override  public ComputerBuilder buildCPU(String producer, String model, String frequency, Integer coreNum) {  computer.cpu = new CPU(producer, model, frequency, coreNum);  return this;  } @Override  public ComputerBuilder buildGPU(String producer, String model, String memory) {  computer.gpu = new GPU(producer, model, memory);  return this;  } @Override  public ComputerBuilder buildMainBoard(String producer, String model, String interfaceType) {  computer.mainBoard = new MainBoard(producer, model, interfaceType);  return this;  } @Override  public Computer build() {  return computer;  } }  测试 public class Test {  public static void main(String[] args) {  //链式编程  Computer computer = new ComplexComputerBuilder()    .buildCPU(intel, i5-8600K, 3.6GHZ, 6)    .buildGPU(NVIDIA, GTX 1060, 6G)    .buildMainBoard(华硕, B250M-PLUS, LGA 1151)    .build();  System.out.println(computer);  } } 之前接口中把 CPU, GPU, 主板 的建造方法的返回值定义为 ComputerBuilder 就是为了 在调用时能够像这样链式编程，最后通过 build() 方法返回一个完整的 Computer 对象。 结果 CPU{producer='intel', model='i5-8600K', frequency='3.6GHZ', coreNum=6} GPU{producer='NVIDIA', model='GTX 1060', memory='6G'} MainBoard{producer='华硕', model='B250M-PLUS', interfaceType='LGA 1151'} 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/14/builder/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "设计模式之——适配器 Adapter",
      "category" : "DesignPatterns",
      "content": "设计模式之——适配器 Adapter 适配器 我们生活中处处可见适配器，其中电线是最常见的。 家用插座的电压是 220V ，很多电器都无法直接承受这个电压。 所以会有电压转换器。 手机充电器都分为充电线和充电头。 充电头就是充电线和插座之间的适配器。 在 Java 中，以下都是适配器 java.io jdbc-odbc bridge（不是桥接模式） ASM transformer 概念  以下内容引用自 菜鸟教程 适配器模式 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。 介绍 意图  将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  主要解决  主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。  何时使用  系统需要使用现有的类，而此类的接口不符合系统的需要。  想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。  通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）  如何解决  继承或依赖（推荐）。  关键代码  适配器继承或依赖已有的对象，实现想要的目标接口。  应用实例  美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。  JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。  在 LINUX 上运行 WINDOWS 程序。  JAVA 中的 jdbc。  优点  可以让任何两个没有关联的类一起运行。  提高了类的复用。  增加了类的透明度。  灵活性好。  缺点  过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。  由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。  使用场景  有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。  注意事项  适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 误区 常见的 Adapter 类反而不是 Adapter WindowAdapter KeyAdapter Java自带的 Adapter 类是为了方便编程的 假如现在需要监听窗口，并且只关心窗口关闭这个操作。 如果直接 new WindowListener() ，那么 WindowListener 的所有方法都需要我们实现，因为 WindowsListener 是一个接口。 WindowListener windowListener = new WindowListener() {   @Override   public void windowOpened(WindowEvent e) {     }   @Override   public void windowClosing(WindowEvent e) {   }   @Override   public void windowClosed(WindowEvent e) {   }   @Override   public void windowIconified(WindowEvent e) {   }   @Override   public void windowDeiconified(WindowEvent e) {   }   @Override   public void windowActivated(WindowEvent e) {   }   @Override   public void windowDeactivated(WindowEvent e) {   }  }; 但如果我们 new WindowAdapter() , 我们可以只重写想要的方法 WindowListener windowListener = new WindowAdapter() {   @Override   public void windowClosed(WindowEvent e) {    super.windowClosed(e);   }  }; 查看 WindowAdapter 的源码，发现其中所有的方法都有空的实现。 所以在继承 WindowAdapter 的时候，语法上不要求我们重写所有的方法。 public abstract class WindowAdapter  implements WindowListener, WindowStateListener, WindowFocusListener {  public void windowOpened(WindowEvent e) {}  public void windowClosing(WindowEvent e) {}  public void windowClosed(WindowEvent e) {}  public void windowIconified(WindowEvent e) {}  public void windowDeiconified(WindowEvent e) {}  public void windowActivated(WindowEvent e) {}  public void windowDeactivated(WindowEvent e) {}  public void windowStateChanged(WindowEvent e) {}  public void windowGainedFocus(WindowEvent e) {}  public void windowLostFocus(WindowEvent e) {} } Java 中自带的 Adapter 更多的是类似于 WindowAdapter 这种方便编写的类。 它的本意是从复杂到简单的适配器。 但设计模式中的适配器指的是实现类型转换的适配器。 代码示例 现在有电流类 Electricity，成员属性为电压 voltage。 public class Electricity {  private int voltage; public Electricity(int voltage) {  this.voltage = voltage;  } public int getVoltage() {  return voltage;  } } 有电视机类 TV1。 当电压 &lt; 110 V 时，电视无法工作。 当电压 = 110 V 时，电视正常工作。 当电压 &gt; 110 V 时，电视爆炸！  public class TV1 { public void work(Electricity electricity) {  if (electricity.getVoltage() &gt; 110) {   System.out.println(boom!!!);  } else if (electricity.getVoltage() == 110) {   System.out.println(normal work);  } else if (electricity.getVoltage() &lt; 110) {   System.out.println(can't work);  } } }}   如果直接让电视机通上家用电流 Electricity electricity = new Electricity(220); TV1 tv1 = new TV1(); tv1.work(electricity); 结果 boom!!!  很明显，我们不应该让电视机直接和家用电流连接，必须加入变压器 public class Adapter {  Electricity electricity; public Adapter(Electricity electricity) {  this.electricity = electricity;  } public int getVoltage() {  if (electricity.getVoltage() &gt; 110) {   return 110;  } else {   return electricity.getVoltage();  }  } } 同时改写电视机类的 work() 方法，把参数改为 Adapter public class TV2 {  public void work(Adapter adapter) {  if (adapter.getVoltage() &gt; 110) {   System.out.println(boom!!!);  } else if (adapter.getVoltage() == 110) {   System.out.println(normal work);  } else if (adapter.getVoltage() &lt; 110) {   System.out.println(can't work);  }  } } 测试 TV2 tv2 = new TV2(); Adapter adapter = new Adapter(electricity); tv2.work(adapter); 结果 normal work 因为 TV2 的 work() 方法的参数是 Adapter，所以 Electricity 类是无法直接传入电视机类的。 这样就保证了电视机不会爆炸。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/15/adapter/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "设计模式之——桥接 Bridge",
      "category" : "DesignPatterns",
      "content": "设计模式之——桥接 Bridge 桥接模式 桥接模式将对象从两个维度拓展，即抽象维度和具体维度。 比如说家具的风格就是抽象维度。 现代、古典、欧式、中式…… 而家具的类型是具体维度。 桌子、椅子、书柜、衣柜…… 当对象有抽象和具体双重维度时，该如何定义？ 如果是以下的设计： 现代桌子、古典桌子、欧式桌子、中式桌子…… 现代椅子、古典椅子…… …… 这种设计肯定是不行的。 如果有 m 种抽象定义， n 种具体定义。 那么会组合出 m*n 种对象。 这会引起巨大的类爆炸。 所以这时候就需要使用桥接模式。 分离抽象与具体。 用聚合方式（桥）连接抽象与具体。 概念  以下内容引用自 菜鸟教程 桥接模式 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。 我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。 介绍 意图  将抽象部分与实现部分分离，使它们都可以独立的变化。  主要解决  在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。  何时使用  实现系统可能有多个角度分类，每一种角度都可能变化。  如何解决  把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。  关键代码  抽象类依赖实现类。  应用实例  猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。  墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。  优点  抽象和实现的分离。  优秀的扩展能力。  实现细节对客户透明。  缺点  桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。  使用场景  如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。  对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。  一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。  注意事项  对于两个独立变化的维度，使用桥接模式再适合不过了。 代码示例 桌子有抽象维度和具体维度双重维度。 抽象维度有现代风格和古典风格。 具体维度有椅子和桌子。 使用桥接模式创建现代椅子、古典椅子、现代桌子、古典桌子四种对象。 具体维度  接口  public class FurnitureType {  //家具的类型  String name = null;  @Override  public String toString() {   return name;  } }   椅子  public class Chair extends FurnitureType{  public Chair() {   super.name = Chair;  } }   桌子  public class Table extends FurnitureType{  public Table(){   super.name = Table;  } }   抽象维度  接口 在接口中，把具体维度定义成其成员。  public abstract class Furniture {  String name = null;  FurnitureType furnitureType;  public Furniture(FurnitureType furnitureType){   this.furnitureType = furnitureType;  }  @Override  public String toString() {   return name + + furnitureType.name;  } }   现代风格  public class ModernFurniture extends Furniture{  public ModernFurniture(FurnitureType furnitureType) {   super(furnitureType);   super.name = ModernFurniture;  } }   古典风格  public class ClassicalFurniture extends Furniture{  public ClassicalFurniture(FurnitureType furnitureType) {   super(furnitureType);   super.name = ClassicalFurniture;  } }   测试 public class Main {  tpublic static void main(String[] args) {  t tSystem.out.println(new ModernFurniture(new Chair()));  t tSystem.out.println(new ClassicalFurniture(new Chair()));  t tSystem.out.println(new ModernFurniture(new Table()));  t tSystem.out.println(new ClassicalFurniture(new Table()));  t} } 结果 ModernFurniture Chair ClassicalFurniture Chair ModernFurniture Table ClassicalFurniture Table 总结 在抽象维度中，具体维度是成员属性。 当抽象维度需要和哪个具体维度时，只需要在构造方法中传入具体维度。 就可以实现抽象维度和具体维度的桥接 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/16/bridge/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "Command",
      "category" : "",
      "content": " ",
      "url"      : "https://kekaiyuan.github.io//2021/06/17/command/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "设计模式之——原型 Prototype",
      "category" : "DesignPatterns",
      "content": "设计模式之——原型 Prototype 序言 原型模式是 Java 中自带的模式。 用于从一个固定的对象中克隆出多个相同的对象。 概念  以下内容引用自 菜鸟教程 原型模式 原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。 介绍 意图  用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。  主要解决  在运行期建立和删除原型。  何时使用  当一个系统应该独立于它的产品创建，构成和表示时。  当要实例化的类是在运行时刻指定时，例如，通过动态装载。  为了避免创建一个与产品类层次平行的工厂类层次时。  当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。  如何解决  利用已有的一个原型对象，快速地生成和原型对象一样的实例。  关键代码  实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。  原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。  应用实例  细胞分裂。  JAVA 中的 Object clone() 方法。  优点  性能提高。  逃避构造函数的约束。  缺点  配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。  必须实现 Cloneable 接口。  使用场景  资源优化场景。  类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。  性能和安全要求的场景。  通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。  一个对象多个修改者的场景。  一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。  在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。  原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。  注意事项  与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。 案例 浅克隆 实现 实现克隆有三步： 继承 Cloneable 接口 重写 clone() 方法 调用 clone() 方法 事实上，不继承 Cloneable 接口也可以重写 clone() 方法。 因为 Cloneable 是一个空接口（里面什么都没有）。 而 clone() 方法是 Object 类（所有类共同的父类）的方法。 但是，不继承 Cloneable 接口编译可以通过，调用 clone() 方法时会报 java.lang.CloneNotSupportedException 异常！ @AllArgsConstructor @ToString class Person implements Cloneable{  int age;  int score;  Location loc; @Override  public Object clone() throws CloneNotSupportedException {  return super.clone();  } } @AllArgsConstructor @ToString class Location {  String street;  int roomNo; } 需要克隆对象时直接调用 clone() 方法。 public static void main(String[] args) throws Exception {  Person p1 = new Person(18, 100, new Location(bj, 22));  System.out.println(p1);  Person p2 = (Person) p1.clone();  System.out.println(p2);  System.out.println(p1 == p2);  } 结果 Person(age=18, score=100, loc=Location(street=bj, roomNo=22)) Person(age=18, score=100, loc=Location(street=bj, roomNo=22)) false 可以看到 p1 和 p2 内容一样，且是两个不同的对象。 什么是浅克隆？ public static void main(String[] args) throws Exception {  Person p1 = new Person(18, 100, new Location(bj, 22));  Person p2 = (Person) p1.clone();  t t  System.out.println(p1.loc == p2.loc);  } 结果 true 这意味着 p1.loc 和 p2.loc 是同一个对象！ 这就是浅克隆，新对象和旧对象的值完全一致。  protected native Object clone() throws CloneNotSupportedException; clone() 是个 native 方法，本地找不到其实现，可以简单地将 Person 类的 clone() 视为这样的： @Override public Object clone() throws CloneNotSupportedException {  tPerson clone = new Person();  tclone.age = this.age;  tclone.score = this.score;  tclone.loc = this.loc;  treturn clone; } 于是会出现以下情形 public static void main(String[] args) throws Exception {  Person p1 = new Person(18, 100, new Location(bj, 22));  Person p2 = (Person) p1.clone();  p1.age = 8;  System.out.println(p2.age);  p1.loc.street = sh;  System.out.println(p2.loc.street);  } 结果 18 sh 修改 p1.age ，p2.age 没有变。 但是修改 p1.loc ，p2.loc 也变了。 深克隆 深克隆可以解决浅克隆中引用类型指向同一个对象的问题。 办法很简单，使所有的引用类型都继承 Cloneable 接口并重写 clone() 方法。 @AllArgsConstructor @ToString class Person implements Cloneable {  int age;  int score;  Location loc; @Override  protected Object clone() throws CloneNotSupportedException {  Person person = (Person) super.clone();  person.loc = (Location) this.loc.clone();  return person;  } } @AllArgsConstructor @ToString class Location implements Cloneable {  String street;  int roomNo; @Override  protected Object clone() throws CloneNotSupportedException {  return super.clone();  } } 测试 public static void main(String[] args) throws Exception {  Person p1 = new Person(18, 100, new Location(bj, 22));  Person p2 = (Person) p1.clone();  System.out.println(p1.loc == p2.loc);  p1.loc.street = sh;  System.out.println(p2.loc.street);  } 结果 false bj p1.loc 和 p2.loc 不再指向同一个对象。 修改 p1.loc ， p2.loc 不会受影响。 反序列化 还可以通过序列化和反序列化的方式实现深克隆。 将对象序列化为字节流，然后再反序列化为对象。 反序列化创建的是新对象，并没有复制现有对象。 CloneUtil 工具类，通过序列化和反序列化克隆对象 /** * 通过序列化和反序列化克隆对象 */ public class CloneUtil { public static &lt;T extends Serializable&gt; T clone(T object) {  T result = null;  try (ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();   ObjectOutputStream objectOutput = new ObjectOutputStream(byteOutput)) {   objectOutput.writeObject(object);   try (ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOutput.toByteArray());   ObjectInputStream objectInput = new ObjectInputStream(byteInput);   ) {    result = (T) objectInput.readObject();   }  } catch (IOException | ClassNotFoundException e) {   e.printStackTrace();  }  return result;  } } 对象不需要实现 Cloneable 接口，而是需要实现 Serializable 接口 @AllArgsConstructor @ToString class Person implements Serializable {  private static final long serialVersionUID = -280939426127136800L;  int age;  int score;  Location loc; } @AllArgsConstructor @ToString class Location implements Serializable {  private static final long serialVersionUID = 5934373144430208588L;  String street;  int roomNo; } 测试  public static void main(String[] args) throws Exception {  Person p1 = new Person(18, 100, new Location(bj, 22));  Person p2 = CloneUtil.clone(p1);  System.out.println(p2);  System.out.println(p1.loc == p2.loc);  p1.loc.street = sh;  System.out.println(p2.loc.street);  } 结果 Person(age=18, score=100, loc=Location(street=bj, roomNo=22)) false bj 性能测试 深克隆与反序列化 克隆十万个对象 深克隆：  11 ms  10 ms  11 ms   反序列化：  1309 ms  1223 ms  1233 ms   深克隆比反序列化快了百倍 直接创建对象与深克隆 一千万个对象    Jdk 版本  直接创建时间（ms）  深克隆时间（ms）     Jdk 8  78, 61, 61  163, 153, 156    Jdk 11  122,97,100  39, 39, 39    Jdk 13  125, 106, 98  40, 48, 44    Jdk 15  11, 10, 9  93, 101, 97    Jdk 17  10, 12, 12  97, 111, 101   可以看到，时间对比的结果很神奇。 经典的 Jdk 8 是直接创建比较快 Jdk 8 之后一些中版本，是深克隆快 新版本是直接创建比较快 99% 的对象都是通过 new 关键字生成的，所以 Jdk 肯定是会着重针对此做优化的。 这样的结果不知道是 BUG 或是其他原因，将来有时间了研究一下。 网上的通用结论是：直接创建对象比较快，除非构造函数里面有复杂的运算。 哪些变量不需要深克隆？ 常量不需要深克隆 八种基本类型没有深浅克隆的说法：  byte  short  int  long  float  double  char  boolean   八种包装类型不需要深克隆：  Byte  Short  Integer  Long  Float  Double  Character  Boolean   String 不需要深克隆 修改以上 17 种类型的变量的值时，并不是修改常量，而是将其指向了新的常量。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/18/prototype/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "Memento",
      "category" : "",
      "content": " ",
      "url"      : "https://kekaiyuan.github.io//2021/06/19/memento/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "设计模式之——模板方法 Template Method",
      "category" : "DesignPatterns",
      "content": "设计模式之——模板方法 Template Method 序言 模板方法，又叫钩子函数或回调函数（Callback Function）。 考虑现实生活： 学校为所有学生定义了一个模板： 上学(); 学习(); 放学(); 模板中 上学() 和 放学() 是空方法，要求学生们自己实现： 公交车 单车 步行 家长接送 …… 这就是模板方法： 在父类中定义所有子类必须实现的方法。 子类自定义地具体实现这些方法。 概念  以下内容引用自 菜鸟教程 模板模式 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 介绍 意图  定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。  主要解决  一些方法通用，却在每一个子类都重新写了这一方法。  何时使用  有一些通用的方法。  如何解决  将这些通用算法抽象出来。  关键代码  在抽象类实现，其他步骤在子类实现。  应用实例  在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。  西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。  spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。  优点  封装不变部分，扩展可变部分。  提取公共代码，便于维护。  行为由父类控制，子类实现。  缺点  每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。  使用场景  有多个子类共有的方法，且逻辑相同。  重要的、复杂的方法，可以考虑作为模板方法。  注意事项  为防止恶意操作，一般模板方法都加上 final 关键词。 案例 父类定义模板：方法和执行顺序 abstract class Superclass {  public void templateMethod(){  method1();  method2();  } abstract void method1();  abstract void method2(); } 子类具体实现 class Subclass1 extends Superclass{  @Override  void method1() {  System.out.println(subclass1 method1);  } @Override  void method2() {  System.out.println(subclass1 method2);  } } class Subclass2 extends Superclass{  @Override  void method1() {  System.out.println(subclass2 method1);  } @Override  void method2() {  System.out.println(subclass2 method2);  } }  调用 public static void main(String[] args) {  tSuperclass aClass1 = new Subclass1();  taClass1.templateMethod();  tSystem.out.println(------);  tSuperclass aClass2 = new Subclass2();  taClass2.templateMethod(); } 结果 subclass1 method1 subclass1 method2 ------ subclass2 method1 subclass2 method2 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/06/20/templatemethod/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "State",
      "category" : "",
      "content": " ",
      "url"      : "https://kekaiyuan.github.io//2021/06/21/state/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "Intepreter",
      "category" : "",
      "content": " ",
      "url"      : "https://kekaiyuan.github.io//2021/06/22/intepreter/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "Java 之——使用 Netty 实现 CS 模型",
      "category" : "Java",
      "content": "Netty 实现了对 NIO 的封装，使用起来更加方便 需要导入 io.netty 包 案例 使用 Netty 实现基本的 CS 通信。 包括两种通讯方式： 客户端和服务器一对一通信 服务器将某客户端的消息转发给所有客户端，实现客户端之间的同步 Client public class Client {  public static void main(String[] args) throws Exception {  /*  * 事件处理的线程池，无论是连接还是读写都由线程池中的线程处理  * 参数为线程池的大小，无参默认为CPU的核心数*2  * 客户端一般一个线程就够了  */  EventLoopGroup group = new NioEventLoopGroup(1);  //复制启动类  Bootstrap bootstrap = new Bootstrap();  try {   //设置线程池   ChannelFuture channelFuture = bootstrap.group(group)    //设置连接类型    .channel(NioSocketChannel.class)    //channel上有事件时传给谁处理    .handler(new ChannelInitializer&lt;SocketChannel&gt;() {     @Override     protected void initChannel(SocketChannel ch) throws Exception {      ch.pipeline().addLast(new ClientHandler());     }    })    .connect(localhost, 8890);   //设置监听器，监听连接的返回   channelFuture.addListener(new ChannelFutureListener() {    @Override    public void operationComplete(ChannelFuture future) throws Exception {    if (future.isSuccess()) {     System.out.println(connected);    } else {     System.out.println(not connected);    }    }   });   //会永远等待close()方法的调用,实现长时间启动   channelFuture.channel().closeFuture().sync();  } finally {   group.shutdownGracefully();  }  } } class ClientHandler extends ChannelInboundHandlerAdapter{  @Override  public void channelActive(ChannelHandlerContext ctx) throws Exception {  //channel第一次连上可用，写出一个字符串  ByteBuf buf = Unpooled.copiedBuffer(hello.getBytes());  ctx.writeAndFlush(buf);  } @Override  public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {  ByteBuf buf = null;  try{   buf = (ByteBuf) msg;   byte[] bytes = new byte[buf.readableBytes()];   buf.getBytes(buf.readerIndex(),bytes);   System.out.println(new String(bytes));  }finally {   //关闭资源   if(buf!=null){    ReferenceCountUtil.release(msg);   }  }  } } Server public class Server { //开启一个客户端通道组，用一个默认的线程处理事件，实现转发  public static ChannelGroup clients = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE); public static void main(String[] args) throws Exception{  //只负责客户端的连接  EventLoopGroup bossGroup = new NioEventLoopGroup(1);  //负责每个Socket上的事件的处理  EventLoopGroup workerGroup = new NioEventLoopGroup(2);  try{   ServerBootstrap serverBootstrap = new ServerBootstrap();   ChannelFuture channelFuture = serverBootstrap.group(bossGroup,workerGroup)    .channel(NioServerSocketChannel.class)    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {     @Override     protected void initChannel(SocketChannel ch) throws Exception {      ChannelPipeline channelPipeline = ch.pipeline();      channelPipeline.addLast(new ServerChildHandler());     }    })    .bind(8890)    .sync();   System.out.println(server started);   //会永远等待close()方法的调用,实现长时间启动   channelFuture.channel().closeFuture().sync();  }finally {   workerGroup.shutdownGracefully();   bossGroup.shutdownGracefully();  }  } } class ServerChildHandler extends ChannelInboundHandlerAdapter{ //把通道加入通道组  @Override  public void channelActive(ChannelHandlerContext ctx) throws Exception {  Server.clients.add(ctx.channel());  } @Override  public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {  ByteBuf buf = null;  try{   buf = (ByteBuf) msg;   byte[] bytes = new byte[buf.readableBytes()];   buf.getBytes(buf.readerIndex(),bytes);   System.out.println(new String(bytes));   //该函数会自动释放资源   //把消息群发给所有客户端   Server.clients.writeAndFlush(buf);   //把消息返回给发送消息的客户端   //ctx.writeAndFlush(buf);  }finally {   if(buf!=null){    //writeAndFlush会自动关闭资源，无需手动关闭    //ReferenceCountUtil.release(msg);   }  }  } //异常处理  @Override  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {  //打印异常  cause.printStackTrace();  //关闭资源  ctx.close();  } } 要点 netty 的读写都是使用的 ByteBuf 类，这是对 NIO 的 ByteBuffer 类的封装，更加方便使用。 ByteBuf 需要关闭资源，但是 writeAndFlush 方法会自动关闭 ByteBuf  只读数据不写数据时，要手动关闭 ByteBuf  有写数据时，不需要手动关闭 ByteBuf   Netty 中一切操作都是异步的，如果需要使用同步等待另一端的消息时，需要调用 ChannelFuture.sync() 方法  ChannelFuture.channel().closeFuture().sync() 方法会将程序一直运行，直到调用 close() 方法，用这个可以使客户端或服务器的长时间启动    不要在 UI 里执行 ChannelFuture.channel().closeFuture().sync() 方法，因为 UI 会被这个方法永久阻塞，最好在 main 方法的末尾调用。因为 main 方法和 UI 是两个线程。     一对一通信和转发的区别  客户端没区别  服务器      public static ChannelGroup clients = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);     开辟一个通道组，存储所有客户端的通道       //把通道加入通道组 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception {  Server.clients.add(ctx.channel()); }     在客户端与服务器的通道初始化时，调用该方法，将该通道加入通道组    把消息群发给所有客户端 Server.clients.writeAndFlush(buf);   把消息返回给发送消息的客户端 ctx.writeAndFlush(buf);     如何启动多个客户端https://kekaiyuan.github.io//wiki/intellij-idea/#%E5%B9%B6%E5%8F%91%E5%90%AF%E5%8A%A8%E4%BB%A3%E7%A0%81 乱七八糟 main 方法和 UI 是两个线程 自定义协议，序列化数据太大，效率低 netty自动编码 TCP 拆包  TCP 的传输会把数据分成多个包   黏包  服务器把收到的数据包合成为数据   如何判断？  事先约定数据的大小，当服务器收到的数据包的大小总和达到多少时，黏包  定义消息头，告诉对方我的消息有多长    消息头，数据长度，数据，校验码     使用 EmbeddedChannel 测试 encoder 和 decoder EmbeddedChannel 是一个虚假的 Channel ，并没有通过网络连接，是 netty 自带的测试工具 单元测试的好处  复用测试 我现在写好了一个程序，编写了单元测试。 一测，有BUG。 去改，改完还是用这个单元测试去测试。 如果没有单元测试，改一遍，自己测一遍   nagle算法 不会发送小包，而是把小包合成大包发送出去 对游戏不适合，禁用nagle算法 自定义协议 源码链接 该文章源码链接 https://github.com/kekaiyuan/javaquestion/tree/main/nettydemo ",
      "url"      : "https://kekaiyuan.github.io//2021/06/22/netty-demo/",
      "keywords" : "Java, Netty"
    } ,
  
    {
      "title"    : "设计模式之总谈",
      "category" : "DesignPatterns",
      "content": "设计模式之总谈  创建型  Abstract Factory  Builder  Factory Method  Prototype  Singleton   结构型  Adapter  Bridge  Composite  Decorate  Facade  Flyweight  Proxy   行为型  Chain Of Responsibility  Command  Interpreter  Iterator  Mediator  Memento  Observer  State  Strategy  Template Method  Visitor   设计模式更多的是学习思想，而不是套用模板。死板地套用模板，很可能会让程序出现BUG。 不要乱用设计模式，每个设计模式都有它适合的场景。 不要叠加设计模式。活用设计模式，能让程序变得简洁。但是模式数量越多，反而会让程序变得复杂。在单一模块，尽量只使用一两个适合的模式。 设计模式里很多模式的思想、设计都是及其接近的，接近程度能达到程序上并无区别，只是我们人类主观上在语义进行区分。  中介者和外观，语义不同，其核心都是对多个模块的联系的封装，该核心对内是中介者，对外是外观。  观察者和责任链    在很多系统中，Observer模式往往和责任链共同负责对于事件的处理，其中的某一个observer负责是否将事件进一步传递。   观察者将同时接收到观察的事件并进行处理。   但是责任链则是顺序地处理，但责任链的某一环完成对事件的处理后，可不将事件不传入下一环处理，直接断开链条。     代理模式和装饰者模式语法、uml类图都很像，语义不一样   Content here 源码链接 该文章源码链接 url ",
      "url"      : "https://kekaiyuan.github.io//2021/06/23/summary/",
      "keywords" : "Java，设计模式"
    } ,
  
    {
      "title"    : "Io",
      "category" : "",
      "content": " layout: post title: template page categories: [cate1, cate2] description: some word here keywords: keyword1, keyword2 NIO NIO 中一切都是异步的，但是网络传输是需要时间的。 如果不调用 sync() 方法，那么程序会发出一个网络请求就会直接往下执行。 如果需要等待得到网络回复，就调用 sync() 方法，它会同步阻塞地等待网络 bossGroup：大管家，只负责开门迎接客人 workerGroup：服务员，服务每一桌的客人  ChannelPipeline 管道  责任链模式，可以添加 Handler   源码链接 该文章源码链接 url ",
      "url"      : "https://kekaiyuan.github.io//2021/06/23/io/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "Oracle 11g 安装教程",
      "category" : "Oracle",
      "content": "Oracle 11g 安装教程 数据库的目的不是“存数据”，这个说法过于业余。 因为数组也能够存数据，只是数组中存的数据重启程序后会消失。 数据库的目的是数据持久化，把数据保存在本地硬盘。 数据库介绍 关系型数据库  MySQL    用的最多     Oracle    最安全   软件贵   有些问题需要请 Oracle 公司的人来解决，支出高     Sql server    .net     Db2    金融，银行     非关系型数据库  Hbase  Redis  mongodb   Oracle介绍 数据库的版本  Oracle 8及8i  i 表示的 internet ，向网络发展，过渡版本，只有一张 vcd 。 8i 是过渡性产品。  Oracle9i 是之前使用最广泛版本， 8i 的升级版。1CD  Oracle10g 700M 过渡性产品，其中 g 表示的是网格计算。以平面网格，以中心查找。  Oracle11g 完整性产品，最新版本 2G 。  Oracle12c the world’s first database designed for the cloud   用户  sys 超级管理员  system 普通管理员  scott 普通的用户   实例 –&gt;数据库 数据库实例名 统一使用orcl 安装教程 软件链接：百度网盘 提取码：lier 其中包括本文章所使用的各种安装包和文档。 查看 oracle的安装.pdf ，按照教程进行安装。 当 Oracle 发生某种错误使得我们不得不卸载它时。 我们必须把关于 Oracle 的一切都卸载删除干净。 否则我们的下一次安装极有可能失败。 安装完成后 打开 cmd ， 运行 services.msc 。找到 Oracle 的相关服务。 当 Oracle 安装完成之后，会出现如下服务： 其中 OracleServiceORCL OracleOraDb11g_home1TNSListener 是最关键的服务，如果安装完成之后发现只有两个服务。 那意味着安装过程中存在问题，需要将 Oracle 完整删除重新安装。 Oracle 服务作用 在成功安装 Oracle 11g 后，会生成 7 个服务： Oracle ORCL VSS Writer Service  Oracle 卷映射拷贝写入服务  非必须启动  VSS（Volume Shadow Copy Service）能够让存储基础设备（比如磁盘，阵列等）创建高保真的时间点映像，即映射拷贝（shadow copy）。 它可以在多卷或者单个卷上创建映射拷贝，同时不会影响到系统的系统性能。   OracleDBConsoleorcl  Oracle数据库控制台服务  非必须启动  orcl 是 Oracle 的实例标识，默认的实例为 orcl 。 在运行 Enterprise Manager（企业管理器OEM）的时候，需要开启这个服务。   OracleJobSchedulerORCL  Oracle作业调度（定时器）服务  非必须启动  ORCL是Oracle实例标识。   OracleMTSRecoveryService  服务端控制。  非必须启动  该服务允许数据库充当一个微软事务服务器MTS、COM/COM+对象和分布式环境下的事务的资源管理器。   OracleOraDb11g_home1ClrAgent  Oracle数据库.NET扩展服务的一部分。  非必须启动   OracleOraDb11g_home1TNSListener  监听器服务，服务只有在数据库需要远程访问的时候才需要。  必须启动，下面有详解   OracleServiceORCL  数据库服务(数据库实例)，  必须启动  Oracle 的核心服务，是数据库启动的基础。 只有该服务启动，Oracle数据库才能正常启动。   可以选择关闭不需要的服务，降低对系统资源的花费： OracleServiceORCL 是基础，必须启动。 如果使用了 PL / SQL Developer 等第三方工具，启动 OracleOraDb11g_home1TNSListener。 这个服务用于数据库的远程访问。 OracleDBConsoleorcl 是进入基于 web 的 EM 必须开启的。 而其他服务很少用。 注：ORCL 是数据库实例名，默认的数据库是 ORCL ，你可以创建其他的，即 OracleService + 数据库名。 很多人能找到第 8 个服务 OracleRemExecService ，这是 Oracle 在安装过程中产生的一个服务，没有任何影响。 在安装完成后，该服务器会被 remove 掉。 因此，在reboot之前，该服务的值为disabled。 在reboot之后，该服务会消失（gone）。 请忽略该服务，并leave this service untouched。 操作 所有的服务改成”手动” 启动两个  监听服务：OracleOraDb10g_home1TNSListener 监听客户端的连接  数据库服务：OracleServiceORCL 命名规则：OracleService+实例名   账号管理 使用scott用户登录,第一次登录的时候会显示账户锁定，需要将账户解锁： 使用 DBA 登录 运行命令行工具 sqlplus /nolog; conn sys/密码@orcl as sysdba; 解锁命令 alter user scott account unlock|lock; 测试 conn scott/密码@orcl; 要求重新输入密码，确认你自己的密码即可。 当个人使用时建议设置成简单的密码。 如何连接至 Oracle 运行 cmd sqlplus /nolog; conn scott/密码@orcl; Oracle 常用指令 查看所有表 select * from tab; 查看表中数据 `select * from 表名; 设置页面大小 set pagesize 50; set linesize 200; 在 Oracle 中，假如普通用户 scott 拥有表 emp。 超级管理员 sys 无法通过 select * from emp; 来访问表中数据。 必须通过select * from scott.emp;来访问。 这就是 Oracle 中所谓的表归属某个用户。 创建新的数据库 打开 Database Configuration Assistant 然后根据资料中的 创建新的数据库.pdf 进行操作 当安装新的数据库之后，会多出几个跟此数据库相关的服务 意味着安装完成 当创建数据库出现如下错误时。 点击 确定 点击 口令管理 取消锁定账户 scott，并设置密码 常用命令 sqlplus  sqlplus /nolog  conn scott/tiger@orcl  show user  set linesize 150  set pagesize 20  passw  conn sys/abc123456@orcl as sysdba  select * from emp where ename=‘&amp;ename’   alter user scott account unlock 统一密码：tiger PL/SQL PL/SQL 是一款用于 Oracle 数据库的第三方图形化软件 下载资料中的 plsqldev11_chs.zip，解压并按照里面的教程进行安装 当 PL/SQL 连接出现以下问题时 解决方案： 第一种  打开 cmd  打开 serveices.msc  重启监听服务   第二种  打开 Net Configuration Assistant   监听程序配置  重新配置   第三种  下载资料中的 配置文件.zip 并解压  把以下三个文件复制到 .  Oracle  product  11.2.0  dbhome_1  NETWORK  ADMIN    listener.ora   sqlnet.ora   tnsnames.ora     并做出以下修改    修改 listenner.ora 中的路径   修改 tnsnames.ora 中的数据库名     PL/SQL 中有多种窗口，某些语句只能在 Command Window 运行。 ",
      "url"      : "https://kekaiyuan.github.io//2021/06/27/v11gsetup/",
      "keywords" : "Oracle"
    } ,
  
    {
      "title"    : "Oracle SQL 之——查询",
      "category" : "Oracle",
      "content": "SQL 语言指的是结构化查询语言 (Structured Query Language)，具有定义、查询、更新和控制等多种功能，是关系数据库的标准语言。 SQL分类 DML  Data Manipulation Language 数据操纵语言  针对数据  关键字    SELECT   INSERT   UPDATE   DELETE     DDL  Data definition language 数据定义语言  针对表  关键字    CREATE   ALTER   DROP   RENAME     DCL  Data Control Language 数据控制语言  权限、事务  关键字    GRANT   REVOKE     Transaction  commit  rollback  savepoint   实验用数据表 本文使用的数据库为 oracle 11g 自带的 scott 其结构为： emp表——&gt;雇员表(employee)  Empno: 雇员工号  Ename: 雇员名字  Job: 工作。（秘书、销售、经理、分析员、保管）  Mgr(manager): 经理的工号  Hiredate: 雇用日期  Sal: 工资  Comm: 津贴  Deptno: 所属部门号   dept表——&gt;部门表（department）  Deptno: 部门号  Dname: 部门名字  Loc: 地址   salgrade表——&gt;一个公司是有等级制度的，用此表表示一个工资的等级  Grade: 等级  losal: 最低工资  hisal: 最高工资   bonus表——&gt; 奖金表：表示一个雇员的工资及奖金。  Ename: 雇员名字  job: 工作  sal: 工资  comm: 津贴   基本查询 select Select-from-where句型  SELECT [DISTINCT] {*,column alias,..} FROM table alias Where 条件表达式    alias 指别名，我们可以更改表或列的名字，以方便我们操作    Column alias   Column “alias”     当别名中带有空格时，必须使用引号       Column as alias   别名可以是中文     检索单个列  select col from tableName;  检索多个列  select col1, col2,col3 from tableName;  检索所有列    select * from tableName;   * 称为通配符     优点 书写方便、可以检索未知列   缺点 降低检索的性能   当只检索固定列的数据时，不要使用 * ，效率低   表过大，越要避免使用 * ，否则很容易卡死         给检索出的列起个别名    select job gong zuo from emp;   select job as gong zuo from emp;     表别名    Select e.* from emp e;   Select e.empno,e.deptno from emp e;     distinct    可将检索结果去重。   当检索多个列，有一个字段不一样都不会被去重。     where where 后面跟的是条件表达式 条件比较 ＝ , !＝ , &lt;&gt; , &lt; , &gt; , &lt;= , &gt;= , any , some , all != 和 &lt;&gt; 都表示不等于 any , some , all 后面跟的是一堆数值  any 取其中任意一个 select sal from emp where sal &gt; any(1000 , 1500 , 3000); sal 只要大于 1000,1500,3000 中任意一个值即可。 可以将 any 理解为最小值  some 和 any 一样，取最小值 select sal from emp where sal &gt; some(1000 , 1500 , 3000);  all 表示所有，即最大值 select sal from emp where sal &gt; some(1000 , 1500 , 3000); 检索大于 3000 的 sal   is null , is not null 在 SQL 语法中， null 表示一个特殊的含义，不能使用 = 和 != 进行比较 判断某字段是否为空，必须使用 is null 或 is not null between x and y 找到大于等于 x 的值和小于等于 y 的值 包含 x 和 y 的值 以下语句等价  select sal from emp where sal between 1500 and 3000;  select sal from emp where sal &gt;= 1500 and sal &lt;= 3000;   in（list）, not in（list） 需要进行某些值的等值判断的时候使用 in 和 not in 会从后面的 list 列表中逐一比对 select * from emp where deptno in (10,20);等价于 select * from emp where deptno = 10 or deptno = 20; select * from emp where deptno not in (10,20);等价于 select * from emp where deptno != 10 or deptno != 20; exists（sub－query） 相关子查询 现在要查询部门编号为10和20的员工，要求使用exists实现  在 SQL 中，select 等同于一次循环，使用相关子查询等于使用双重循环  在相关子查询中，要将外层循环和内层循环联系到一起，否则容易输出整张表   select *  from emp e  where exists (select deptno     from dept d     where (d.deptno = 10 or d.deptno = 20)     and e.deptno = d.deptno)     exists 等同于逻辑判断 对于外层的 select 语句的每一个结果，exists 都会使用内层的语句进行一次判断：是否存在满足条件的语句    若存在，则为 true ，外层 select 有效。   若不存在，则为 false ，外层 select 无效。 所以相关子查询必须把 外层select 和 内层select 联系起来，否则 内层select 的结果将恒定为固定值。     同时使用 or 和 and，要用 () 把 or 语句括起来保证执行顺序。   like , escape 模糊查询 在 like 的语句中，需要使用占位符或通配符  _ 占位符，可替换为一个任意字符  % 通配符，可替换为无数个任意字符  不能过度使用通配符。如果其他操作符能达到目的，就不要使用通配符。  确实需要使用通配符时，除非绝对必要，否则不要把通配符用到搜索模式最开始处，因为这样搜索起来是最慢的。   查询名字以 S 开头的用户 select * from emp where ename like('S%'); 查询名字以 S 开头且倒数第二个字符为 T 的用户 select * from emp where ename like('S%T_'); escape 自定义转义字符 查询名字中带 % 的用户 select * from emp where ename like ('%a%%') escape ('a') 此时的 a 被定义为转义字符，等同于 Java 中的 ‘'，’a%’ 表示 ‘%’ 这个符号，不再是通配符。 使用 like 时要注意，因为效率比较低。 使用 like 可以参考使用索引，但是要求不能以 % 开头，查询次数会爆炸。  我现在要查询含有 “Java” 的文章。 如果使用 “%Java%”。 每篇文章程序都要从头读到尾进行匹配。 如果有一万篇文章，每篇一千字。 那么程序就要遍历整整一千万字。   涉及到大文本的检索的时候，可以使用某些框架。  luence  solr  elastic search   order by 进行排序操作 按照单个列排序 select * from XXX where XXX order by col 升序排序 order by col (asc) 默认情况下升序，asc 可省略。 降序排序 order by col desc 按照多个列排序（优先级） order by col1 desc(asc), col2 desc(asc) 先根据 col1 进行排序，当有数据 col1 字段相等时，再根据 col2 进行排序。 不同字段可以使用不同的排序顺序。 排序按照自然顺序进行  如果是数字，比较数值  如果是字符串，比较字典序   每次在执行 order by 的时候是做了全排序，效率很低，需要耗费大量的内存。 如果数据量很大，慎用 order by 。 可以在凌晨进行 order by 的操作，因此此时服务器访问量很低。 以前很多网站凌晨关闭，其一个目的就是整理数据。 使用计算字段 当我们需要对数据进行转换、计算或格式化时，往往直接在数据库检索时就完成这些操作。 而不是先检索出原始数据，然后在客户机应用程序中对数据进行操作。 比如数据库中存储了员工的月薪，现在需要检索年薪。 那么我们会直接在检索时就完成月薪 *12 的操作。 而不是先检索拿到月薪，然后在应用程序中完成 *12 。  计算字段并不实际存在于数据库表，而是临时数据。 Sql 允许 select 子句中出现 + , - , * , / 以及列名和常数的表达式 拼接字段 || , concat()  拼接字符串  select 'my name is ' || ename from emp;等价于 select concat('my name is ',ename) from emp; 结果   'MYNAMEIS'||ENAME --------------------- my name is SMITH my name is ALLEN my name is WARD my name is JONES my name is MARTIN     首选 || ( MySQL 中 || 表示 or ，一般用 concat() )   数学计算  通过月薪计算年薪。 select ename , sal*12 as 年薪 from emp;  做数学计算时一定要注意，100 + null 的结果是 null   通用函数 nvl Sql 中允许列值为空，空值用保留字 NULL 表示。 NULL 不同于 0 或者空格，它就是代表了一个不确定的内容。 任何含有 null 值的数学表达式最后的结果都为空值。 当进行数学计算时，我们希望能够把 null 视为 0 。 此时就需要使用 nvl 函数。 nvl ( arg1 , arg2 ) 如果 arg1 为 null ，返回 arg2 。 如果 arg1 不为 null，返回 arg1 。 现有该语句： select ename , (sal+comm) * 12 as annual salary from emp; ename 是员工名字，sal 是月薪，comm 是月度津贴，现需要计算年薪。 但是因为有部分员工的 comm 是 null，所以计算结果如下： ENAME   年薪 ---------- ---------- SMITH  ALLEN   22800 WARD  21000 JONES  MARTIN  31800 BLAKE  此时我们想要将 null 视为 0 。 select ename , (sal + nvl(comm ,0)) * 12 as annual salary from emp; 结果正常 ENAME annual salary ---------- ------------- SMITH   9600 ALLEN   22800 WARD   21000 JONES   35700 MARTIN   31800 并集，全集，交集，差集 在下文中使用 A , B 代指： A = select * from table1 where 条件1 B = select * from table2 where 条件2 集合类型 并集 A union B; 将两个集合中的所有数据都进行显示，去重 全集 A union all B; 将两个集合的数据全部显示，不去重 交集 A intersect B; 两个集合中交叉的数据集，只显示一次 差集 A minus B; 包含在A集合而不包含在B集合中的数据，跟A和B的集合顺序相关 查看表 Select * from tab; 查看用户下的所有表 Select * from user_tables; 详细查询当前用户下的所有表 desc 表名; 或 describe dept; 查看表结构 select table_name from user_tables; 查看所有表 comment on table emp is ‘雇员表'; 为表添加注释 comment on column emp.Empno is '雇员工号';  为列添加注释 注意 SQL 中关系运算符的优先级：not &gt; and &gt; or 当在同一条语句中使用不同的运算符时，最好用 () 括起来。 保证语句的执行顺序，减少出错概率。 SQL 中的单行注释为 -- 相关优化 AND: 把检索结果较少的条件放到后面 OR: 把检索结果较多的条件放到后面 SQL 函数 函数一般是在数据上执行的，它给数据的转换和处理提供了方便。 函数只是将取出的数据进行处理，不会改变数据库中的值。 Sql函数可以分为组函数和单行函数。 组函数又被称作聚合函数，用于对多行数据进行操作，并返回一个单一的结果 组函数仅可用于选择列表或查询的 having 子句 单行函数对单个数值进行操作，并返回一个值。 oracle 函数大全 oralce 函数大全 单行函数 分类 在oracle中存在数值的隐式转换和显式转换 隐式转换指的是字符串可以转换为数值或者日期 而显式转换则是使用 oracle 的转换函数 单行函数的嵌套 单行函数可被嵌入到任何层 嵌套函数从最深层到最低层求值 组函数 组函数基于多行数据返回单个值 常用的组函数 avg() 返回某列的平均值 min() 返回某列的最小值 max() 返回某列的最大值 sum() 返回某列值的和 count() 返回某列的行数 用法 AVG and SUM 适用于数字类型数据 MIN and MAX 适用于任何数据类型 COUNT 返回某列的行数，默认统计所有行，如果需要统计不重复的行，使用 distinct 关键字 select count(distinct deptno) from emp; COUNT 一般用来获取表中的记录条数，获取条数的时候可以使用 * 或者某一个具体的列 甚至可以使用纯数字来代替，但是从运行效率的角度考虑，建议使用数字或者某一个具体的列，而不要使用 *  count ( * )  count (1)  count (arg) 最好使用主键的列名，因为 count 会跳过空值，而主键是非空的。   组函数一律跳过空值，如果需要将空值代入计算，使用 NVL 函数。 数据分组 组函数处理的是 “一组数据”，如果没有分组操作的话，组函数处理的是整张表。 例如select avg(sal) from emp;输出是整张表的所有 sal 的平均值。 但加入分组操作后 select avg(sal) from emp group by deptno; 该语句会将 deptno 相同的行归为一组，然后分别求每个组的 sal 的平均值。 步骤 SELECT column, group_function FROM table [WHERE condition] [GROUP BY group_by_expression] [ORDER BY column]; [having condition] 使用 group by 子句将表分成小组 结果集隐式按降序排列，如果需要改变排序方式可以使用 order by 子句  创建分组  group by 子句。    group by arg1 按照 arg1 进行分组，arg1 相同的为一组     group by 子句可以包含任意数目的列。    group by arg1 , arg2 按照 arg1 和 arg2 进行分组，arg1 相同并且 arg2 也相同的为一组   除组函数语句外，select 语句中的每个列都必须在 group by 子句中给出。     如果分组列中具有 null 值，则 null 将作为一个分组返回。如果列中有多行 null 值，他们将分为一组。  group by 子句必须出现在 where 子句之后，order by 子句之前。   过滤分组（ having 子句)  where 过滤行，having 过滤分组。  having 支持所有 where 操作符。   分组和排序  一般在使用 group by 子句时，应该也给出 order by 子句。   注意 出现在 select 列表中的字段，如果出现的位置不是在组函数中，那么必须出现在 group by 子句中  select deptno,avg(sal) from emp group by deptno 该语句合法，select 列表中有两个字段：deptno 和 sal  - deptno 字段出现在 group by 子句中  - sal 出现在组函数 avg() 中  select deptno,avg(sal),ename from emp group by deptno 该语句不合法，无法执行。 因为 ename 字段即不存在于 group by 子句中，也不存在于组函数中。   group by 列可以不在 select 列表中  select avg(sal) from emp group by deptno group by 子句中的 deptno 不在 select 列表中   不能在 where 子句中使用组函数。不能在 where 子句中限制组。使用 having 对分组进行限制。  where 子句只能使用表中存在的数据。 组函数只是将取出的数据进行了一系列的处理，但是并没有写回数据库，所以 where 子句无法使用。 如果需要将组函数处理的结果作为判断依据，使用 having 子句。  例如现在有语句select avg(sal) from emp group by deptno; 想要输出 avg(sal) &gt; 1000 的分组    select avg(sal) from emp group by deptno where avg(sal) &gt; 1000 该语句错误，where 子句无法使用组函数处理的结果   select avg(sal) from emp group by deptno having avg(sal) &gt; 1000 该语句正确，使用 having 子句对分组进行限制。     where 子句和 having 子句都可用于执行判断操作。    where 子句只能使用表中存在的属性，而不能使用组函数。   having 子句可以使用组函数。     组函数仅在 选择列表 和 having 子句中有效。 select 子句顺序    子句  说明  是否必须使用     select  要返回的列或表达式  是    from  从中检索数据的表  仅在从表选择数据时使用    where  行级过滤  否    group by  分组说明  仅在按组计算聚集时使用    having  组级过滤  否    order by  输出排序顺序  否   Sql语句执行过程： 读取 from 子句中的基本表、视图的数据，[执行笛卡尔积操作]。 选取满足 where 子句中给出的条件表达式的元组 按 group 子句中指定列的值分组，同时提取满足 having 子句中组条件表达式的那些组 按 select 子句中给出的列名或列表达式求值输出 order by 子句对输出的目标表进行排序。 多表查询 有时我们需要读取多个表中的数据 现有表 employee ，其中有雇员的ID，名字，部门ID 有表 department ，其中有部门的ID，名字，地点 现需查询雇员的ID以及雇员的部门名字。 这分别在两张表上。 此时需要将两张表合并。 1992语法 92语法共有五种连接方式： 等值连接 非等值连接 外连接 自连接 笛卡尔积 下文将通过表A和表B说明五种连接的区别。 表 A    X  Y  S     1  2  2    1  2  3    1  2  4   表 B    S  Z     3  3    4  4    5  5   等值连接 根据 where子句 中的等式连接两张表 例：select * from A,B where A.S = B.S;    A.X  A.Y  A.S  B.S  B.Z     1  2  3  3  3    1  2  4  4  4   语法规则：  SELECT table1.column, table2.column FROM table1, table2 WHERE table1.column1 = table2.column2;  将 table1 中的 column1 与 table2 中的 column2 相等的记录连接到一起。 一般而言 column1 为 table1 的外键，column2 为 table2 的主键。 非等值连接 使用 &lt; , &gt; , &lt;= , &gt;= , != , between and 等关系符号连接时称为非等值连接 例：select * from A,B where A.S &gt; B.S;    A.X  A.Y  A.S  B.S  B.Z     1  2  4  3  3   表A只有记录 (1,2,4) 中的S大于表B中记录 (3,3) 中的S 外连接 在前两种连接中，如果表中存在无法连接的记录，该记录会被舍弃。 为了在操作时能保持这些将被舍弃的元组，提出了外连接的概念，使用外连接可以看到不满足连接条件的记录。 外连接运算符是 (+) 有左外连接和右外连接 左外连接 显示左表的全部数据 在右表添加 (+) select * from A,B where A.S = B.S(+);    A.X  A.Y  A.S  B.S  B.Z     1  2  2          1  2  3  3  3    1  2  4  4  4   右外连接 显示右表的全部数据 在左表添加 (+) select * from A,B where A.S(+) = B.S;    A.X  A.Y  A.S  B.S  B.Z     1  2  3  3  3    1  2  4  4  4             5  5   自连接 和自己进行连接 select * from A A1,A A2 where A1.Y = A2.S;    A1.X  A1.Y  A1.S  A2.X  A2.Y  A2.S     1  2  2  1  2  2    1  2  3  1  2  2    1  2  4  1  2  2   笛卡尔积 当连接时不指定连接方式时，将默认进行笛卡尔积计算。 将左表的每一条记录和右表的每一条记录进行连接。 检索出的行的数目将是左表的行数乘以右表的行数 检索出的列的数目将是左表的列数加上右表的列数 select * from A,B;    A.X  A.Y  A.S  B.S  B.Z     1  2  2  3  3    1  2  2  4  4    1  2  2  5  5    1  2  3  3  3    1  2  3  4  4    1  2  3  5  5    1  2  4  3  3    1  2  4  4  4    1  2  4  5  5   注意 连接时可以给表起别名，方便操作。 有时必须使用别名  自连接  不同的表中有同名列   可以连接两张以上的表，但是要注意设置连接条件。 多表连接几乎不使用笛卡尔积连接，因为生成的数据太多。 当有 n 张表进行连接时，至少需要 n-1 个条件，否则一定会发生笛卡尔积。 1999语法 在 92语法 中，多张表的连接条件放在 where子句 中，同时 where子句 需要对表进行条件过滤。 where子句 需要完成两个功能，这就使得 92语法 中的 where子句 格外的臃肿。 1999语法 解决了这个问题，并且提出了一些新的连接方式。 语法规则 99语法 中共有八种连接方式，其中有部分连接原理等同于 92语法 。 只是为了方便书写，更改了书写方式。 交叉连接 自然连接 on子句 using子句 左外连接 右外连接 全外连接 内连接 使用三个表来说明 99语法 的连接方式。 表 A    X  Y  S     1  2  2    1  2  3    1  2  4   表 B    S  Z     3  3    4  4    5  5   表 C    S  Y  Z     2  2  3    4  2  5    6  2  7   交叉连接 select * from table1 cross join table2; 等同于 92语法 的笛卡尔积。 将左表的每一行和右表的每一行都进行连接。 自然连接 select * from table1 natural join table2; NATURAL JOIN子句基于两个表中列名完全相同的列产生连接  两个表有相同名字的列  数据类型相同  从两个表中选出连接列的值相等的所有行   类似于 92语法 中的 等值连接 但是 自然连接 会去除重复的列，而 等值连接 不会。  自然连接会将两张表中所有的同名列作为连接条件。 例：select * from A natrual join C;      Y   S   A.X   C.Z        2   2   1   3      2   4   1   5     当两张表中没有列名相同的列时，做笛卡尔积。 on 子句 自然连接的条件是基于表中所有同名列的等值连接 为了设置任意的连接条件或者指定连接的列，需要使用ON子句 连接条件与其它的查询条件分开书写 使用ON 子句使查询语句更容易理解  包括等值连接和非等值连接 select * from table1 join table2 on table1.column1 = table2.column2; 等同于 92语法 的等值连接 select * from table1 join table2 on table1.column1 &gt; table2.column2; 等同于 92语法 的非等值连接 使用 on子句 实现两张以上的多表连接 select * from table1 join table2 on 连接条件1 join table3 on 连接条件2; using 子句 using子句 和 on子句 一样，都可以表示连接条件 select * from table1 join table2 using(column1); 等同于select * from table1 join table2 on table1.column1 = table2.column1; 注意 using子句 的连接条件是同名列，而且不能使用表名或别名进行修饰。 select * from table1 join table2 using(table1.column1); 该语句是错误的。 using子句 类似于自然连接，使用同名列进行连接，同样地会去除重复的同名列。 而 on子句 不会去除重复的同名列。  当两张表存在 n 个同名列时，自然连接会将所有的同名列进行连接。 而 using子句 则根据指定的同名列进行连接。 例：select * from A join C using(S);      S   A.X   A.Y   C.Y   C.Z        2   1   2   2   3      4   1   2   2   5     select * from A join C using(S,Y);      Y   S   A.X   C.Z        2   2   1   3      2   4   1   5     外连接 左外连接 select * from table1 left outer join table2 on 连接条件; 等同于 92语法 的左外连接。 返回所有左边表中的行，即使在右边的表中没有可对应的列值。 右外连接 select * from table1 right outer join table2 on 连接条件; 等同于 92语法 的右外连接。 返回所有右边表中的行，即使在左边的表中没有可对应的列值。 全外连接 99语法 的新特性 能显示左表和右表的全部数据，兼顾了左外连接和右外连接。 select * from table1 full outer join table2 on 连接条件; 例：select * from A full outer join B on A.S = B.S;    A.X  A.Y  A.S  B.S  B.Z     1  2  3  3  3    1  2  4  4  4             5  5    1  2  2         内连接 select * from table1 inner join table2 on 连接条件; 等同于select * from table1 join table2 on 连接条件; 没有什么特殊意义，on子句 默认就是内连接。 总结 在实际开发中，92语法 和 99语法 都能够运行，并没有限制。 但是最好使用 99语法 。 因为 99语法 更美观，功能更强大。 子查询 嵌套在其他 sql 语句中的完整 sql 语句，可以称之为子查询。 理解子查询的关键在于把子查询当作一张表来看待。 外层的语句可以把内嵌的子查询返回的结果当成一张表使用。 子查询要用括号括起来 将子查询放在比较运算符的右边（增强可读性） 子查询的种类 按照子查询返回的记录数，子查询可以分为单行子查询和多行子查询： 单行子查询 多行子查询 单行子查询 子查询返回一行记录 使用单行记录比较运算符 案例： 查询有哪些人的薪水是在整个雇员的平均薪水之上的： 首先求所有雇员的平均薪水 select avg(sal + nvl(comm, 0)) from emp 然后求：  select ename, empno, sal, sal + nvl(comm, 0)  from emp where sal + nvl(comm, 0) &gt; (select avg(sal + nvl(comm, 0)) from emp);   此处嵌套的子查询在外层查询处理之前执行 多行子查询 子查询返回多行行记录 使用集合比较运算符 使用方法： 在多行子查询中使用 in 例：我们要查在雇员中有哪些人是经理人 也就是说，有哪些人的empno号在mgr这个字段中出现过 这个时候，应当首先查询mgr中有哪些号码 然后再看看有哪些人的雇员号码在此出现： select empno, ename from emp where empno in (select distinct mgr from emp); 在多行子查询中使用 some all 例：找出部门编号为20的所有员工中收入最高的职员  select *  from emp where sal &gt;= all (select sal from emp where deptno = 20) and deptno = 20;   在 from子句 中使用子查询 例：我们要求每个部门平均薪水的等级。 可以这样考虑，首先将每个部门的平均薪水求出来，然后把结果当成一张表。 再用这张结果表和salgrade表做连接，以此求得薪水等级。  先求出每个部门平均薪水的表 t 。  将 t 和 salgrade 进行关联查询就可以了。   select * from salgrade s,  (select deptno, avg(sal) avg_sal from emp group by deptno) t where t.avg_sal between s.losal and s.hisal;     限制输出 现在有这样一个问题：输出薪水最高的5个人，怎么做？ 这就需要我们限制输出的数量。 在 MySQL 中，限制输出的关键字是 limit ，非常的见名知意，而且使用非常的简单方便。 但是在 oracle 中，限制输出的关键字是 rownum ，这个的使用比较繁琐。 rownum 指的是行号，在 oracle 中，每一条数据都有对应的行号，我们需要显式地使用行号来完成限制输出的功能。 注意：rownum 不能直接使用，需要嵌套使用。 输出工资最高的5个人 select * from (select * from emp order by sal desc) where rownum &lt;= 5; 为什么说 rownum 必须嵌套使用？ 如果这样使用 select * from emp where rownum&lt;=5 order by sal desc; 这条语句的执行顺序是：先查询 emp 表中的前5条数据，然后排序。 这样显然是错的。 而select * from (select * from emp order by sal desc) where rownum &lt;= 5; 的执行顺序是：先将 emp 表按照工资降序，然后输出前5条数据。 这样的结果才是正确的。 因为我们必须先将数据处理好，然后再限制输出。 如果不嵌套的话，那么结果是先限制输出，再处理数据。 输出工资最高的第6到10名的人 在 oracle 中，rownum 只能 &lt; 或 &lt;= 某个值，而不能 &gt; 或 &gt;= 某个值 select * from (select * from emp order by sal desc) where rownum &gt; 5; 的执行结果是空表。 这是因为 rownum 指的是行号，它是动态改变的。 我们使用rownum &gt; 5是为了去除前5条语句。 而 oracle 的原理是 rownum &gt; 5的执行流程： 去除前5条语句。 更新语句的 rownum。  类似于现实中的排队。 你排在第六位。 前五位走了，你就是第一位。   重新执行。 只有当 rownum &gt;= 0 时才不会输出空表，但是这毫无意义。 那么这个问题如何实现呢？ select * from (select e1.*, rownum rn from (select * from emp order by sal desc) e1) where rn &gt; 5 and rn &lt;= 10; 把 rownum 加入表中成为属性。 注意： select * , rownum rn会报错 必须使用select e1.*, rownum rn ",
      "url"      : "https://kekaiyuan.github.io//2021/06/28/sql-query/",
      "keywords" : "Oracle，SQL"
    } ,
  
    {
      "title"    : "Oracle 之——行转列",
      "category" : "Oracle",
      "content": "Oracle 之——行转列 在实际开发中，行转列是一个非常常用的技术点。 因为在实际中数据库的数据越少越好，这样便于管理、成本低、备份快、查询快…… 所以除了必要的数据，大部分能够通过计算得到的数据都不会存在数据库中。 有时我们需要对数据库的表进行转换。 这就是行转列。 例1：中国移动sql面试题 原表 test    ID  TYPE  T_ID  VALUE     100  1  1  张三    200  2  1  男    300  3  1  50    101  1  2  刘二    201  2  2  男    301  3  2  30    102  1  3  刘三    202  2  3  女    302  3  3  10   目标    姓名  性别  年龄     张三  男  50    刘二  男  30    刘三  女  10   解答 先筛选出需要的数据 select decode(type, 1, value) as 姓名,  decode(type, 2, value) as 性别,  decode(type, 3, value) as 年龄 from test;       姓名   性别   年龄        张三                  男                  50      刘二                  男                  30      刘三                  女                  10     使用聚合函数完成行转列 合并空行时，使用 max 或 min select max(decode(type, 1, value)) as 姓名,  max(decode(type, 2, value)) as 性别,  max(decode(type, 3, value)) as 年龄 from test group by T_ID;       姓名   性别   年龄        张三   男   50      刘二   男   30      刘三   女   10     例2 原表 tmp    RQ  SHENGFU     2005-05-09  胜    2005-05-09  胜    2005-05-09  负    2005-05-09  负    2005-05-10  胜    2005-05-10  负    2005-05-10  负   目标 | RQ | 胜 | 负 | | ———- | ———- | ———- | | 2005-05-09 | 2 | 2 | | 2005-05-10 | 1 | 2 | 解答 筛选 select rq,  decode(shengfu, '胜', 1) as 胜,  decode(shengfu, '负', 1) as 负 from tmp;       RQ   胜   负        2005-05-09   1          2005-05-09   1          2005-05-09       1      2005-05-09       1      2005-05-10   1          2005-05-10       1      2005-05-10       1     统计时使用 sum 或 count select rq,  sum(decode(shengfu, '胜', 1)) as 胜,  sum(decode(shengfu, '负', 1)) as 负 from tmp group by rq order by rq;       RQ   胜   负        2005-05-09   2   2      2005-05-10   1   2     例3 原表 student_score    NAME  SUBJECT  SCORE     张三  语文  78.0    张三  数学  88.0    张三  英语  98.0    李四  语文  89.0    李四  数学  76.0    李四  英语  90.0    王五  语文  99.0    王五  数学  66.0    王五  英语  91.0   3.1 实现    NAME  语文  数学  英语     王五  99  66  91    李四  89  76  90    张三  78  88  98   解答 使用 decode  select name,  max(decode(subject, '语文', score)) as 语文,  max(decode(subject, '数学', score)) as 数学,  max(decode(subject, '英语', score)) as 英语  from student_score group by name;   使用 case when  select name,  max(case subject   when '语文' then    score   end) 语文,  max(case subject   when '数学' then    score   end) 数学,  max(case subject   when '英语' then    score   end) 英语  from student_score group by name;   使用 join  select ss1.name, ss1.score 语文, ss2.score 数学, ss3.score 英语  from (select name, score from student_score where subject = '语文') ss1  join (select name, score from student_score where subject = '数学') ss2  on ss1.name = ss2.name  join (select name, score from student_score where subject = '英语') ss3  on ss1.name = ss3.name;   使用 union all  create view v_ss as select name, score 语文, 0 数学, 0 英语  from student_score where subject = '语文'  union all  select name, 0 语文, score 数学, 0 英语  from student_score where subject = '数学'  union all  select name, 0 语文, 0 数学, score 英语  from student_score where subject = '英语'; select name, sum(语文) 语文, sum(数学) 数学, sum(英语) 英语  from v_ss group by name;   总结： 实现行转列的方式有很多，但是 decode 最实用。 3.2 实现    NAME  语文  数学  英语     王五  优秀  及格  优秀    李四  优秀  及格  优秀    张三  及格  优秀  优秀   解答 create view v_ss02 as select name,  subject,  case  when score &gt;= 80 then   '优秀'  when score &gt;= 60 then   '及格'  else   '不及格'  end as 等级  from student_score;  select name,  max(decode(subject, '语文', 等级)) 语文,  max(decode(subject, '数学', 等级)) 数学,  max(decode(subject, '英语', 等级)) 英语 from v_ss02 group by name; 例4 原表 表 yj01    MONTH  DEPTNO  YJ     一月份  1  10    一月份  2  10    二月份  3  5    二月份  2  8    三月份  4  9    三月份  3  8   表 yjdept    DEPTNO  DNAME     1  国内业务一部    2  国内业务二部    3  国内业务三部    4  国际业务部   目标    部门  一月份  二月份  三月份     国内业务一部  10  0  0    国内业务二部  10  8  0    国内业务三部  0  5  8    国际业务部  0  0  9   解答 create view v_yj01 as select deptno,  sum(decode(month, '一月份', yj)) Jan,  sum(decode(month, '二月份', yj)) Feb,  sum(decode(month, '三月份', yj)) Mar  from yj01 group by deptno; select dname 部门, nvl(Jan, 0) 一月份, nvl(Feb, 0) 二月份, nvl(Mar, 0) 三月份 from v_yj01, yjdept where v_yj01.deptno = yjdept.deptno order by yjdept.deptno; 源码链接 该文章源码链接 Github 包括例题中原表的创建语句 ",
      "url"      : "https://kekaiyuan.github.io//2021/06/30/rowtocol/",
      "keywords" : "Oracle"
    } ,
  
    {
      "title"    : "Oracle 之——序列",
      "category" : "Oracle",
      "content": "序列是 oracle 专有的对象，它用来产生一个自动递增的数列。 序列 在数据库中，我们有时会需要自动递增的数列。 比如说用户表，必须有用户ID作为唯一标识，但是由我们指定用户ID不仅麻烦，而且容易冲突。 在 MySQL 中，可以将用户ID的字段设置为自动递增的。 这样我们插入新的用户数据就不需要输入用户ID了，数据库会自动地帮我们填写用户ID。 其数值是自动递增的。 假设将初值设置为1，那么就是 1 , 2 , 3 , 4 , 5 …… 在 oracle 中也有同样的设计，叫做序列。 定义 create sequence seq_name increment by n    每次增长几 start with n    从哪个值开始增长 maxvalue n|nomaxvalue 10^27 or -1 最大值 minvalue n|no minvalue   最小值 cycle|nocycle     是否有循环 cache n|nocache    是否有缓存  循环  开启循环后，当序列的值超过最大值时，重置为初始值，开始新一轮的自增。  不开启循环，当序列的值超过最大值时，程序报错——无法实例化。   缓存  放置序列接下来的 n 个值。   除了 increment by 和 start with ，其余四个属性均有默认值，“|” 后面的就是默认值，即 系统默认最大值、没有最小值、不循环、没有缓存。 create sequence my_sequence start with 1 increment by 1; 这就是最简单的序列，从 1 开始，每次递增 1 。其余四个属性为默认值。 使用 序列名.nextval 取出序列的当前值，并且使序列递增。 序列名.currval 获得序列的当前值。 select my_sequence.currval from dual 删除序列 drop sequence 序列名; 案例：实现用户ID的自增  create sequence my_sequence start with 1 increment by 1;  t create table testuser(  userid number(10) primary key,  username varchar(100) ); insert into testuser(userid,username) values (my_sequence.nextval,'kky'); insert into testuser(userid,username) values (my_sequence.nextval,'kky'); insert into testuser(userid,username) values (my_sequence.nextval,'kky'); insert into testuser(userid,username) values (my_sequence.nextval,'kky'); insert into testuser(userid,username) values (my_sequence.nextval,'kky');  t select * from testuser;       USERID   USERNAME        1   kky      2   kky      3   kky      4   kky      5   kky      6   kky      7   kky      8   kky     源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/01/sequence/",
      "keywords" : "Oracle"
    } ,
  
    {
      "title"    : "Oracle SQL 之——数据更新",
      "category" : "Oracle",
      "content": "在实际项目中，使用最多的是读取操作，但是插入数据和删除数据同等重要，而修改操作相对较少。 插入 元组值的插入 最基本的插入方式 insert into tablename values (val1, val2, ...., valn); 如果表名之后没有列，那么只能将所有的列都插入 例：insert into emp values(2222,'haha','clerk',7902,to_date('2019-11-2','YYYY-MM-dd'),1000,500,10); insert into tablename (col1, col2, ...colm) values (val1, val2, .. ., valm); 可以指定向哪些列中插入数据 例：insert into emp(empno,ename) values(3333,'wangwu');  省略的列必须满足以下条件之一：    该列定义为允许Null值。   在表定义中给出默认值，这表示如果不给出值，将使用默认值。     一次插入操作只插入一行 查询结果的插入 可以用 insert 语句把一个 select 语句的查询结果插入到一个基本表中，语法如下： Insert into tablename(column,..) select * from tablename2 表 A    X  Y  S     1  1  1    2  2  2    3  3  3   表 B | S | Z | | – | – | | 4 | 4 | | 5 | 5 | 执行语句 insert into B select X,Y from A ; 结果 表 B    S  Z     1  1    2  2    3  3    4  4    5  5   复制表 Q&amp;A Q：如果有一个集合的数据，把集合中的所有数据都挨条插入的话，效率如何？ A：一般在实际的操作中，很少一条条插入，更多的是批量插入 删除 SQL的删除操作是指从基本表中删除元组。 语法如下： DELETE [FROM] tablename [WHERE condition];  其语义是从基本表中删除满足条件表达式的元组 Delete from tablename; 表示从表中删除一切元组  truncate table 语句也是删除表中一切元组。 delete 有事务，truncate 没有事务。 所以 turncate 直接永久删除，无法回滚，但是速度快。 效率高，但是容易发生误操作，不建议使用。   修改 update tablename set col = val1 , col2 = val2 , ... where condition; 可以更新或者修改满足条件的一个列或者多个列 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/01/sql-update/",
      "keywords" : "Oracle，SQL"
    } ,
  
    {
      "title"    : "Oracle 之——视图",
      "category" : "Oracle",
      "content": "Oracle 之——视图 视图 视图(view)，也称虚表。 视图生成的表不占用物理空间，本身的定义语句存储在数据字典里，占用少量空间。 视图只有逻辑定义。 每次使用的时候， 只是重新执行SQL。 视图是从一个或多个实际表中获得的，这些表的数据存放在数据库中。 那些用于产生视图的表叫做该视图的基表。 一个视图也可以从另一个视图中产生。 视图的定义存在数据库中，与此定义相关的数据并没有再存一份于数据库中。 通过视图看到的数据存放在基表中。 视图看上去非常象数据库的物理表，对它的操作同任何其它的表一样。 当通过视图修改数据时，实际上是在改变基表中的数据； 相反地，基表数据的改变也会自动反映在由基表产生的视图中。 由于逻辑上的原因，有些Oracle视图可以修改对应的基表，有些则不能（仅仅能查询）。 物化视图 物化视图是 Oracle 的特性，即生成一张物理表而非虚拟表。 虚拟表的数据都来自于基表，每次执行语句都是从基表中取数据，虚拟表和基表是同步的。 但是物化视图有自己的物理表，所以需要刷新操作来更新物化视图，保持和基表数据一致。 其更新方式有两种： On Demand 仅在需要“被刷新”时才刷新。 On Commit 一旦基表有 Commit 操作，立刻刷新物化视图。 视图的使用 授权 当普通用户第一次创建视图提示没有权限时，需要管理员去授予权限。 打开 cmd sqlplus /nolog conn sys/kky@orcl as sysdba; kky 为数据库名 grant create view to scott; scott 为普通用户名 提示 授权成功 即可  如果要回收用户的视图权限 revoke create view from scott; 创建视图 在 CREATE VIEW 语句后加入子查询 CREATE [OR REPLACE] VIEW view [(alias[, alias]...)] AS  tsubquery [WITH READ ONLY]; 例 create or replace view v$_emp_dept as select emp.deptno, ename, dname  from emp  join dept  on emp.deptno = dept.deptno with read only; 当视图添加了 with read only 后，该视图将变为只读视图。 即只可以通过该视图进行读操作，而不能进行增、删、改的操作。 撤销视图 当视图不再需要的时候，用 drop view 撤销。 删掉视图不会导致数据的丢失，因为视图是基于数据库的表之上的一个查询定义。 drop view v$_emp_dept； 其他操作 视图是一张虚拟表，其增、删、改、查的操作和实际的数据表没有什么不同。 但是要 注意： 当视图依赖于多个基表时： 无法执行增加操作 修改操作每次只能修改一个基表的数据 update 视图名 set table1.column1 = ? , table2.column2 = ? where 条件; 这条语句是错误的，因为它同时修改了两张基表的数据。 每次只能修改一个基表中的数据。 删除操作不会报错，但是只会删除其中一个基表中的数据 根据简单测试，只会删除第一个表的数据，可能并不严谨。  create view 视图名 as  select * from table1 join table2 on 连接条件;  这个视图连接时是 table1 在前。 所以删除视图中的数据时，table1 的相关数据会被删除，但是 table2 的不会。 可以看到，视图的增、删、改操作有诸多问题。 这是因为视图本身就是为了方便数据库的查询操作而提出的。 尽管视图拥有增、删、改的功能，但是最好不要使用。 而是对基表进行增、删、改的操作。 视图的好处 例题：求平均薪水的等级最低的部门的部门名称 注：题目所使用的数据库来源于 oracle 自带的 scott 用户  如果使用完全子查询  求平均薪水 select deptno, avg(sal) from emp group by deptno;  求平均薪水的等级  select e.deptno, sg.grade from (select deptno, avg(sal) avg_sal from emp group by deptno) e join salgrade sg on e.avg_sal between sg.losal and sg.hisal ;     求平均薪水的等级最低的部门  select deptno from (select e.deptno, sg.grade gd  from (select deptno, avg(sal) avg_sal from emp group by deptno) e  join salgrade sg   on e.avg_sal between sg.losal and sg.hisal) t where t.gd =  (select min(sg.grade)  from (select deptno, avg(sal) avg_sal from emp group by deptno) e  join salgrade sg   on e.avg_sal between sg.losal and sg.hisal);     求平均薪水的等级最低的部门名称  select dname from (select deptno  from (select e.deptno, sg.grade gd    from (select deptno, avg(sal) avg_sal     from emp     group by deptno) e    join salgrade sg    on e.avg_sal between sg.losal and sg.hisal) t   where t.gd =    (select min(sg.grade)    from (select deptno, avg(sal) avg_sal     from emp     group by deptno) e    join salgrade sg    on e.avg_sal between sg.losal and sg.hisal)) d join dept on d.deptno = dept.deptno;     查看sql语句能够发现，sql中有很多的重复的sql子查询 可以通过视图将重复的语句给抽象出来  create view v_deptno_grade as  select e.deptno , sg.grade  from (select deptno, avg(sal) avg_sal from emp group by deptno) e  join salgrade sg  on e.avg_sal between sg.losal and sg.hisal; select dname  from dept d  join v_deptno_grade v  on d.deptno = v.deptno where v.grade = (select min(grade) from v_deptno_grade);   总结  使用视图可以增加代码的可读性。  视图类似于 Java 中的类和方法，体现了封装的程序思想。 在使用视图定义了某查询语句后。 当什么地方需要使用该查询语句时，直接使用视图，而不是复制粘贴。 增加了代码的复用性。   源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/01/view/",
      "keywords" : "Oracle"
    } ,
  
    {
      "title"    : "Oracle 之——约束",
      "category" : "Oracle",
      "content": "Oracle 之——约束 约束 constraint 当我们创建表的时候，同时可以指定所插入数据的一些规则，比如说 某个字段不能为空值，某个字段的值（比如年龄）不能小于零…… 这些规则称为约束。 约束是在表上强制执行的数据校验规则。 在添加约束之前，插入语句只需要合法：即满足表结构的数据类型。 在添加约束之后，插入语句还需要合理：即满足建表人所定义的规范。 约束用于确保数据库数据满足特定的商业逻辑或者企业规则。 如果定义了约束，并且数据不符合约束，那么DML操作（INSERT、UPDATE、DELETE）将不能成功执行。 Oracle 支持下面五类完整性约束: NOT NULL 非空约束 插入数据的时候某些列不允许为空。 UNIQUE Key 唯一键约束 可以限定某一个列的值是唯一的，唯一键的列一般被用作索引列。 PRIMARY KEY 主键 非空且唯一，任何一张表一般情况下最好有主键，用来唯一的标识一行记录。 FOREIGN KEY 外键 当多个表之间有关联关系（一个表的某个列的值依赖于另一张表的某个值）的时候，需要使用外键。 CHECK 自定义检查约束 可以根据用户自己的需求去限定某些列的值。  注意： Oracle使用SYS_Cn格式命名约束，也可以由用户命名  命名规则 约束_表名_字段 可以保证唯一性。 如果太长，可用缩写。   同一字段可以有多个约束，但是约束之间不要冲突 创建约束的时机  在建表的同时创建。 建议使用。 如果包含外键约束的话，最好先把外键关联表的数据优先插入。  建表后创建。   约束从作用上分类，可以分成两大类：  列级约束 在定义列的同时声明约束。 列名 [CONSTRAINT 约束名] 约束类型 只能约束其所在的某一列。 可以定义任何约束。  表级约束 先定义列，然后再定义约束。   列1 , 列2 , ... [CONSTRAINT 约束名] 约束类型(列1 , 列2 , ...)   可以约束表中的任意一列或多列。 可以定义除了 not null 以外的任何约束。   有些时候，列级约束无法实现某种约束的定义，比如联合主键的定义，就要用到表级约束：   create table test(  id1 number,  id2 number,  primary key(id1, id2) );     非空约束 not null 确保字段值不允许为空 只能在字段级定义 CREATE TABLE employees(  tname VARCHAR2(25) not null,  thire_date DATE CONSTRAINT emp_hire_date_nn not null ) 唯一性约束 unique 唯一性约束条件确保所在的字段或者字段组合不出现重复值 唯一性约束条件的字段允许出现空值 Oracle将为唯一性约束条件创建对应的唯一性索引 定义方式  CREATE TABLE employees(  name VARCHAR2(25) not null unique,  email VARCHAR2(25),  CONSTRAINT emp_email_uk unique(email) );   主键约束 primary key 主键约束是数据库中最重要的一种约束。 在关系中，主键值不可为空，也不允许出现重复，即关系要满足实体完整性规则。 主键从功能上看相当于非空且唯一 一个表中只允许一个主键 主键是表中能够唯一确定一个行数据的字段 主键字段可以是单字段或者是多字段的组合 Oracle 为主键创建对应的唯一性索引 定义方式  create table t3(  id number(4) primary key ) 或 create table t3(  id number(4),  CONSTRAINT t3_pk primary key(id) )   外键约束 foreign key 现在有学生表和成绩表。 学生表中有字段学生ID，成绩表中也有字段学生ID。 在给成绩表的学生ID设置外键约束后（参照为学生表的学生ID）。 成绩表想要插入成绩，其学生ID必须是学生表中存在的学生ID。 也就是说，并不能插入不存在的学生的成绩。 然后当学生毕业了，或者退学了，当把该学生从学生表中删除时（删除了学生ID）。 那么成绩表中对应的成绩也会被一起清空。 这就是外键约束。 成绩表依赖于学生表，成绩表是依赖表，学生表是主表。 成绩表中的学生ID是外键，学生表中的学生ID是主键。  外键是表中的一个列，其值必须在另一表的主键或者唯一键中列出 作为主键的表称为“主表”，作为外键的关系称为“依赖表” 外键参照的是主表的主键或者唯一键 声明外键时，外键的列和依赖的列数据类型必须一致。 对于主表的删除和修改主键值的操作，会对依赖关系产生影响。 以删除为例：当要删除主表的某个记录为例，即删除一个主键值，有 3 种做法  restrict 方式    只有当依赖表中没有一个外键值与要删除的主表中主键值相对应时，才可执行删除操作。   需要手动地修改依赖表，否则无法删除主表中的数据。     cascade 方式    将依赖表中所有外键值与主表中要删除的主键值相对应的记录一起删除。   自动执行。     set null 方式    将依赖表中所有与主表中被删除的主键值相对应的外键值设为空值。   自动执行。     外键的声明 foreign key (列名) references 主表(主键或唯一键) [on delete [cascade|set null]] 如果省略 on 短语，缺省将使用 restrict 方式 check约束 check 约束用于对一个属性的值加以限制 在 check 中定义检查的条件表达式，数据需要符合设置的条件  create table emp3(  age number(2) check(age &gt; 0 and age &lt; 100),  salary number(7,2),  constraint salary_check check(salary &gt; 0) )   在这种约束下，插入记录或修改记录时，系统要测试新的记录的值是否满足条件 约束的添加和撤销 可增加或删除约束，但不能直接修改。 增加约束 alter table 表名 add constraint 约束名 约束类型(列名); 删除约束 alter table 表名 drop constraint 约束名 [cascade]; 查看约束 查看某表的约束  select constraint_name, constraint_type  from user_constraints where table_name = upper(表名);   查看某表的约束及列名  select constraint_name, column_name  from user_cons_columns where table_name = upper(表名);   查看某数据库所有表的约束  select constraint_name, constraint_type  from user_constraints where owner = 用户名;   关系模型的三类完整性规则 为了维护数据库中的数据与现实世界的一致性，关系数据库的数据与更新操作必须遵循下列三类完整性规则： 实体完整性规则 这条规则要求关系中在组成主键的属性上不能有空值。 参照完整性规则 这条规则要求“不引用不存在的实体”。 例如：deptno是dept表的主键，而相应的属性也在表emp中出现，此时deptno是表emp的外键。 在emp表中，deptno的取值要么为空，要么等于dept中的某个主键值。 用户定义的完整性规则 用户定义的完整性规则反应了某一具体的应用涉及的数据必须满足的语义要求。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/02/constraint/",
      "keywords" : "Oracle"
    } ,
  
    {
      "title"    : "Oracle 之——数据类型",
      "category" : "Oracle",
      "content": "Oracle 之——数据类型 常用数据类型 number (x) x 位整数 number(x,y) 数字类型，最长x位，其中包含y位小数（整数部分最大 x-y 位）。 varchar2（maxlength） 变长字符串，这个参数的上限是32767字节 声明方式如下 VARCHAR2 ( L ) , L 为字符串长度，没有缺省值，必须显式声明。 char(max_length) 定长字符串，最大2000字节。 DATE 日期类型，只能精确到秒。 TIMESTAMP 时间戳，精确到微秒。 long 长字符串，最长2GB。  非常用类型 CLOB 最大长度4G 虽然可用于存储大对象，但是极少使用。 更多地是存储文件地址（地址为程序所在应用服务器的相对路径）。 BLOB 存二进制文件。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/02/datatype/",
      "keywords" : "Oracle"
    } ,
  
    {
      "title"    : "Oracle 之——索引",
      "category" : "Oracle",
      "content": "Oracle 之——索引 索引 索引是为了加快对数据的搜索速度而设立的。 索引是方案（schema）中的一个数据库对象，与表独立存放。 索引的作用： 在数据库中用来加速对表的查询，通过使用快速路径访问方法快速定位数据，减少了磁盘的 I/O。 Sql 中的索引是非显示索引。 也就是在索引创建以后，在用户撤销它之前不会在用到该索引的名字，但是索引在用户查询时会自动起作用。 索引的创建有两种情况  自动： 当在表上定义一个 primary key 或者 unique 约束条件时，Oracle 数据库自动创建一个对应的唯一索引。  手动： 用户可以创建索引以加速查询   开发中使用索引的要点 索引改善检索操作的性能，但降低数据插入、修改和删除的性能。 在执行这些操作时，DBMS 必须动态地更新索引。 索引是存储在硬盘中的，索引表太大是会占用大量的存储空间。 并非所有的数据都适合于索引。 唯一性不好的数据（如省）从索引得到的好处不比具有更多可能值的数据（如姓名）从索引得到的好处多。 索引用于数据过滤和数据排序。 如果你经常以某种特定的顺序排序数据，则该数据可能是索引的备选。 可以在索引中定义多个列（如省加城市），这样的索引只在以省加城市的顺序排序时有用。 如果想按城市排序，则这种索引没有用处。 语法 在一列或者多列上创建索引 create index 索引名 on 表名 (列1 ,列2); 删除索引 drop index 索引名; ",
      "url"      : "https://kekaiyuan.github.io//2021/07/02/index/",
      "keywords" : "Oracle， 索引"
    } ,
  
    {
      "title"    : "Oracle SQL 之——建表",
      "category" : "Oracle",
      "content": "Oracle SQL 之——建表 创建表 标准的建表语法 CREATE TABLE [schema.]tablename (column datatype [DEFAULT expr] , … ); 注意 在创建新表时，指定的表名必须不存在，否则将出错。 使用默认值： 当插入行时如果不给出值，dbms将自动采用默认值。 在用 Create 语句创建基本表时，最初只是一个空的框架。 用户可以使用 insert 命令把数据插入表中。 案例： 建立一张用来存储学生信息的表，表中的字段包含了学生的学号、姓名、年龄、入学日期、年级、班级、email等信息。 并且为 grade 指定了默认值为1，如果在插入数据时不指定 grade 的值，就代表是一年级的学生。 解答： create table student(  tid number(6),  tname varchar2(20),  tsex number(1),  tage number(3),  tsdate date,  tgrade number(2) default 1,  tclass number(4),  temail varchar2(50) ); 使用子查询建表 CREATE TABLE table [column(, column...)]AS subquery; 新表的字段列表必须与子查询中的字段列表匹配 字段列表可以省略  复制表结构和数据 create table table2 as select * from table1; 只复制表结构，不复制数据 create table table2 as select * from table1 where 1=2; 因为 select * from table1 where 1=2 是一张空表 无论是哪种复制，都无法复制表的约束（外键、主键等） 当表没有主键时，oracle 将默认使用 rownum 作为主键 修改表结构 在基本表建立并使用一段时间后，可以根据实际需要对基本表的结构进行修改 增加新的列 用“alter table 表名 add 列名 数据类型; 新增加的类不能定义为“not null” 因为基本表在增加一列后，原有元组在新增加的列上的值都是空值。 删除原有的列 alter table 表名 drop 列名; 删除表  删除普通表 drop table student_infor;  删除带约束的表 drop table 表名 cascade constraints;  在基本表不需要时，可以使用“drop table”语句撤消。 在一个基本表撤消后，所有的数据都丢弃，所有相关的索引被删除。   重命名列 alter table 表名 rename column 旧列名 to 新列名; 重命名表或视图 rename 旧表名 to 新表名; 可以使用RENAME语句改变表名（视图）。 要求必须是表（视图）的所有者 修改列的数据类型 alter table 表名 modify ( 列名 新的数据类型 ); ",
      "url"      : "https://kekaiyuan.github.io//2021/07/02/table/",
      "keywords" : "Oracle, SQL"
    } ,
  
    {
      "title"    : "Oracle 之——事务",
      "category" : "Oracle",
      "content": "Oracle 之——事务 事务共分为： 最基本的数据库事务 声明式事务 分布式事务 其中所有关系型数据库 ( Oracle , MySQL ) 的事务机制都是一样的。 事务 事务（Transaction）是一个操作序列。 这些操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位。 事务是为了保证数据库的完整性 事务不能嵌套 在 oracle 中，没有事务开始的语句。 一个 Transaction 起始于一条 DML ( Insert , Update , Delete ) 语句 结束于以下的几种情况：  用户显式执行 Commit 语句 提交操作或执行 Rollback语句 回退。  当执行 DDL ( Create , Alter , Drop ) 语句事务自动提交。  用户正常断开连接时， Transaction 自动提交。  系统崩溃或断电时事务自动回退。   增，删，改是数据库的常用操作，在进行操作的时候都需要 事务 的保证。 也就是说每次在 PL/SQL 中执行 sql 语句之后都需要完成 commit 的操作。 事务的关键性在于保持数据一致性。 如果同一份数据，在同一个时刻只能有一个人访问，就不会出现数据错乱的问题，但是在现在的项目中，更多的是并发访问。 并发访问很容易造成数据的不安全，即不一致。 如果要保证数据的安全，最主要的方式就是加锁的方式，例如 MVCC 。 如果不保证事务的话，会造成脏读，不可重复读，幻读。 Oracle 的提交和回滚 Commit 表示事务成功地结束。 此时告诉系统，数据库要进入一个新的正确状态，该事务对数据库的所有更新都以交付实施。 每个 Commit 语句都可以看成是一个事务成功的结束，同时也是另一个事务的开始。 Rollback 表示事务不成功的结束。 此时告诉系统，已发生错误，数据库可能处在不正确的状态。 该事务对数据库的更新必须被撤销，数据库应恢复该事务到初始状态。 每个 Rollback 语句同时也是另一个事务的开始。 一旦执行了 commit 语句，将目前对数据库的操作提交给数据库（实际写入 DB ），以后就不能用 rollback 进行撤销。 执行一个 DDL ，DCL 语句或从 PL  SQL 正常退出，都会自动执行 commit 命令。 提交或回滚前数据的状态 以前的数据可恢复 当前的用户可以看到 DML操作 的结果 其他用户不能看到 DML操作 的结果 被操作的数据被锁住，其他用户不能修改这些数据 提交后数据的状态 数据的修改被永久写在数据库中。 数据以前的状态永久性丢失。 所有的用户都能看到操作后的结果。 记录锁被释放，其他用户可操作这些记录。 回滚后数据的状态 语句将放弃所有的数据修改 修改的数据被回退。 恢复数据以前的状态。 行级锁被释放。 savepoint 语句 savepoint 指保存点。 当一个操作集合中包含多条SQL语句，但是只想让其中某部分成功，某部分失败，此时可以使用保存点。 此时如果需要回滚到某一个状态的话使用 rollback to 保存点。 例如 SQL语句1 SQL语句2 savepoint sp1; SQL语句3 rollback to sp1; commit; 的结果是 语句1 和 语句2 被提交 语句3 不会被提交 事务的四个特性：ACID 事务有四个特性，ACID 是四个特性的首字母 原子性 Atomicity 事务不可分割，要么全部提交成功，要么全部失败回滚，不能只执行一部分操作。 一个原子事务要么完整执行，要么干脆不执行。 这意味着，工作单元中的每项任务都必须正确执行。 如果有任一任务执行失败，则整个工作单元或事务就会被终止。 即此前对数据所作的任何修改都将被撤销。 如果所有任务都被成功执行，事务就会被提交，即对数据所作的修改将会是永久性的。 原子性通过 Undo Log 实现。 一致性 Consistency 事务的执行不能破坏数据库数据的一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。 一致性代表了底层数据存储的完整性。 一致性是四个特性中最关键的特性，是最终的追求。 它必须由事务系统和应用开发人员共同来保证。 事务系统通过保证事务的原子性，隔离性和持久性来满足这一要求。 应用开发人员则需要保证数据库有适当的约束(主键，引用完整性等)。 并且工作单元中所实现的业务逻辑不会导致数据的不一致(即，数据预期所表达的现实业务情况不相一致)。  银行系统中 A 给 B 转账，A 少了 100 元，那么 B 就一定多了 100 元。 不能出现 A 少了 100 元，但是 B 没有加 100 元的情况。  A 给 B 转账 300 元，但是 A 只有 298 元，那么 A 就只能转 298 元。 不能出现 A 变成 -2 元，而 B 加了 300 元的情况。   隔离性 Isolation 事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能不被其他事务干扰。 不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间。 即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。 共有四个隔离级别： 读未提交 read uncommitted 读已提交 read committed 可重复读 repeatable read 序列化 serializable 隔离级别越高，效率越低。 隔离性通过 锁 来实现 读未提交 read uncommitted 脏读 可以读取其他事务中尚未提交的数据。 不可重复读 幻读 读已提交 read committed 只能读取已经提交的数据。 脏读 不可重复读 一个事务范围内，多次查询某个数据，却得到不同的结果。 事务A 读取了某数据后，其他事务修改了该数据并提交。 事务A 再次读取该数据读到的是修改后的数据，两次数据不匹配。 针对 update 和 delete。 幻读 可重复读 repeatable read 保证事务处理的过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的。 脏读 不可重复读 幻读 事务 A 在开始时读到 3 条记录，然后其他事务插入了第 4 条数据并提交。 此时事务 A 通过 select 语句依然只能读到 3 条记录。 但是如果使用 insert , update , delete 语句就会发现第 4 条语句的存在。 这就是 幻读。 针对 insert 。  原因？ 行锁只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。  如何解决？    升级锁的级别，但是效率会大大下降，不推荐。   加入间隙锁，与行锁配合。 将两行记录间的空隙加上锁，阻止新记录的插入，这个锁称为间隙锁。     序列化 serializable 是最严格的事务隔离级别，它要求所有事务被串行执行。 即事务只能一个接一个的进行处理，不能并发执行。 脏读 不可重复读 幻读 持久性 Durability 一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。 即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态。 持久性通过 Redo Log 实现 锁 为了解决在并发访问的时候，数据不一致的问题，需要给数据加锁 加锁的同时需要考虑 粒度 的问题，即操作对象的单位 数据库 表 行 我可以选择锁住整个数据库，锁住整张表，或者仅仅锁住我操作的那一行数据。 上锁后其他事务无法访问被上锁的数据。 一般情况下，锁的粒度越小，效率越高，粒度越大，效率越低。 在实际的工作环境中，大部分的操作都是行级锁 。 ",
      "url"      : "https://kekaiyuan.github.io//2021/07/02/transaction/",
      "keywords" : "Oracle，事务"
    } ,
  
    {
      "title"    : "Java 之——数据库类型对照表",
      "category" : "Java",
      "content": "Java 之——数据库类型对照表    SQL数据类型  JDBC类型代码  标准的Java类型  Oracle扩展的Java类型        1.0标准的JDBC类型:          CHAR  java.sql.Types.CHAR  java.lang.String  oracle.sql.CHAR    VARCHAR2  java.sql.Types.VARCHAR  java.lang.String  oracle.sql.CHAR    LONG  java.sql.Types.LONGVARCHAR  java.lang.String  oracle.sql.CHAR    NUMBER  java.sql.Types.NUMERIC  java.math.BigDecimal  oracle.sql.NUMBER    NUMBER  java.sql.Types.DECIMAL  java.math.BigDecimal  oracle.sql.NUMBER    NUMBER  java.sql.Types.BIT  boolean  oracle.sql.NUMBER    NUMBER  java.sql.Types.TINYINT  byte  oracle.sql.NUMBER    NUMBER  java.sql.Types.SMALLINT  short  oracle.sql.NUMBER    NUMBER  java.sql.Types.INTEGER  int  oracle.sql.NUMBER    NUMBER  java.sql.Types.BIGINT  long  oracle.sql.NUMBER    NUMBER  java.sql.Types.REAL  float  oracle.sql.NUMBER    NUMBER  java.sql.Types.FLOAT  double  oracle.sql.NUMBER    NUMBER  java.sql.Types.DOUBLE  double  oracle.sql.NUMBER    RAW  java.sql.Types.BINARY  byte[]  oracle.sql.RAW    RAW  java.sql.Types.VARBINARY  byte[]  oracle.sql.RAW    LONGRAW  java.sql.Types.LONGVARBINARY  byte[]  oracle.sql.RAW    DATE  java.sql.Types.DATE  java.sql.Date  oracle.sql.DATE    DATE  java.sql.Types.TIME  java.sql.Time  oracle.sql.DATE    TIMESTAMP  java.sql.Types.TIMESTAMP  javal.sql.Timestamp  oracle.sql.TIMESTAMP       2.0标准的JDBC类型:          BLOB  java.sql.Types.BLOB  java.sql.Blob  oracle.sql.BLOB    CLOB  java.sql.Types.CLOB  java.sql.Clob  oracle.sql.CLOB    用户定义的对象  java.sql.Types.STRUCT  java.sql.Struct  oracle.sql.STRUCT    用户定义的参考  java.sql.Types.REF  java.sql.Ref  oracle.sql.REF    用户定义的集合  java.sql.Types.ARRAY  java.sql.Array  oracle.sql.ARRAY       Oracle扩展:          BFILE  oracle.jdbc.OracleTypes.BFILE  N/A  oracle.sql.BFILE    ROWID  oracle.jdbc.OracleTypes.ROWID  N/A  oracle.sql.ROWID    REF CURSOR  oracle.jdbc.OracleTypes.CURSOR  java.sql.ResultSet  oracle.jdbc.OracleResultSet    TIMESTAMP  oracle.jdbc.OracleTypes.TIMESTAMP  java.sql.Timestamp  oracle.sql.TIMESTAMP    TIMESTAMP WITH TIME ZONE  oracle.jdbc.OracleTypes.TIMESTAMPTZ  java.sql.Timestamp  oracle.sql.TIMESTAMPTZ    TIMESTAMP WITH LOCAL TIME ZONE  oracle.jdbc.OracleTypes.TIMESTAMPLTZ  java.sql.Timestamp  oracle.sql.TIMESTAMPLTZ   源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/03/datatype-to-database/",
      "keywords" : "Java"
    } ,
  
    {
      "title"    : "Oracle 之——范式",
      "category" : "Oracle",
      "content": "为了消除数据库中的冗余，英国人 E.F.Codd（关系数据库的鼻祖）在上个世纪70年代提出关系数据库模型后总结出了范式。 目前有迹可寻的共有8种范式，依次是：1NF，2NF，3NF，BCNF，4NF，5NF，DKNF，6NF。 范式等级越高，数据库的冗余越小。 其中最常用的是第一范式（1NF），第二范式（2NF），第三范式（3NF）。 在实际开发中，数据库的设计能满足 3NF 就足够了。 第一范式 1NF 在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 强调的是列的原子性，即列不能够再分成其他几列。 案例：    编号  姓名  性别，年龄     1  张三  男，21    2  王五  男，22    3  李四  女，23   该表的第三列就很明显可以拆分，应该设计成这样    编号  姓名  性别  年龄     1  张三  男  21    2  王五  男  22    3  李四  女  23   有时候列应该划分到何程度应该视具体情况而定。 有些数据库中姓名是一列。 而有些数据库中姓是一列，名是一列。 有些数据库中地址是一列。 而有些数据库中省份是一列，城市是一列，市区是一列…… 这个取决于数据库实际运用于哪种场景。 第二范式 2NF 满足 2NF 首先得满足 1NF。 其次有两个要求： 表必须有主键。 表中的非主属性必须完全依赖于主键，不能存在部分依赖。  案例：    学号  学生姓名  教师编号  教师姓名     023145  张三  988010  张老师    023146  李四  988010  张老师    023147  王五  988011  李老师    023145  张三  988011  李老师    023258  赵六  988010  张老师   这是一张学生和教师的关系表。 学生和教师是多对多的关系： 一个学生有多个教师。 而一个教师又有多个学生。 在多对多关系中，只使用一个字段作为主键是不够的，必须使用联合主键，即主键由多个字段组成。 例如这张表的联合主键是：{ 学号，教师编号 }，只有同时使用这两个字段作为主键才能唯一地确定表中的数据。 此时仔细看表中的两个非主属性  学生姓名只与主键中的学号有关，与教师编号无关。  教师姓名只与主键中的教师编号有关，与学号无关。  这就是部分依赖，非主属性只由主属性的一部分决定。  与之对应的完全依赖指的就是非主属性由主属性的所有部分共同决定，少任何一部分都不行。   将表进行分解： 学生表    学号(主键)  学生姓名     023145  张三    023146  李四    023147  王五    023258  赵六   教师表    教师编号(主键)  教师姓名     988010  张老师    988011  李老师   联系表    学号(主键)  教师编号(主键)     023145  988010    023146  988010    023147  988011    023145  988011    023258  988010   分解后三个表均不存在部分依赖，满足 2NF 。 第二范式（2NF）要求实体的属性完全依赖于主关键字。 所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。 为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。 简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。 第三范式 3NF 满足 3NF 必须先满足 2NF。 3NF 的关键在于不能存在 传递依赖。 案例：    学号(主键)  学生姓名  班级编号  班级名称  班级信息     023145  张三  987654  3班  特招班    023146  李四  987231  3班  特招班    023147  王五  987654  4班  普通班    …  …  …  …  …    023258  赵六  987654  3班  特招班   该表中主键是学号，学号决定了学生的班级编号。 但是班级名称和班级信息并不是由学号决定的。 而是由班级编号决定。 也就是说，它们之间的关系是这样的。 这就是传递依赖： 非主属性（班级信息和班级名称）并不是直接依赖于主键（学号）的。 而是通过某个非主属性（班级编号）间接依赖于主键（学号）。 分解： 把和主键没有直接联系的属性提取到新表中。 学生表    学号(主键)  学生姓名  班级编号     023145  张三  987654    023146  李四  987231    023147  王五  987654    …  …  …    023258  赵六  987654   班级表    班级编号  班级名称  班级信息     987654  3班  特招班    987231  3班  特招班    987654  4班  普通班    …  …  …    987654  3班  特招班   总结 第一范式  关键 列的原子性  解决办法 根据需要，把列进行拆分。   第二范式  关键 列必须完全依赖主键  解决办法 把表进行拆分，把存在部分依赖的列和它们依赖的主键独立出去，并建立一张联系表。   第三范式  关键 传递依赖  解决办法 把表进行拆分，让表中不要出现其他表的非主键字段。   2NF 和 3NF 很容易混淆，其关键在于： 2NF 直接依赖于主键的一部分。 3NF 传递依赖于主键。 ",
      "url"      : "https://kekaiyuan.github.io//2021/07/03/nf/",
      "keywords" : "Oracle, 范式"
    } ,
  
    {
      "title"    : "Java 之—— JDBC",
      "category" : "Java",
      "content": "Java 之—— JDBC JDBC介绍 JDBC (Java Database Connectivity) 是基于JAVA语言访问数据库的一种技术。 JDBC是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。 JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。 同时，JDBC也是个商标名。 JDBC的设计思想：由SUN公司(JCP)提供访问数据库的接口，由数据库厂商提供对这些接口的实现，程序员编程时都是针对接口进行编程的。 JDBC包括一套JDBC的API和一套程序员和数据库厂商都必须去遵守的规范。  java.sql包：提供访问数据库基本的功能  javax.sql包：提供扩展的功能   数据库中间件 JDBC可以做些什么？  连接到数据库  在Java app中执行SQL命令  处理结果。   java.sql.* 所有的数据库产商如果要与 Java 接轨，必须自定义实现以下的类 java.sql.Driver 驱动 java.sql.Connection 连接 java.sql.Statement 静态处理块 java.sql.PreparedStatement 预处理块 java.sql.ResultSet 结果集 java.sql.ResultSetMetaData 结果集元数据 JDBC 访问数据库的过程 Java.sql.DriverManager用来装载驱动程序，并且为创建新的数据库联接提供支持。 Java.sql.Connection完成对某一指定数据库的联接 Java.sql.Statement在一个给定的连接中作为SQL执行声明的容器，他包含了两个重要的子类型。  Java.sql.PreparedSatement用于执行预编译的sql声明  Java.sql.CallableStatement用于执行数据库中存储过程的调用   Java.sql.ResultSet对于给定声明取得结果的途径 JDBC 的使用方法 0. 导入 jar 包 在开始之前首先得导入所使用数据库的 jar 包。 可以通过 maven 或 gradle 自动导入。 也可以手动导入。  oracle 11g 的 jar 包    .  Oracle  product  11.2.0  dbhome_1  jdbc  lib  ojdbc6.jar   .  Oracle  product  11.2.0  dbhome_1  oui  jlib  classes12.jar   以上两个都可以，如果其中某个报错可以换一个试试。     1. 加载驱动 选择加载哪一个数据库的驱动程序。  MySQL  旧版   Class.forName(com.mysql.jdbc.Driver);     新版   Class.forName(com.mysql.cj.jdbc.Driver);     Oracle  Class.forName(oracle.jdbc.driver.OracleDriver);   PostgreSQL  Class.forName(org.postgresql.Driver);   DB2  连接具有 DB2 客户端的 Provider 实例   Class.forName(com.ibm.dbjdbc.app.DBDriver);     连接不具有 DB2 客户端的 Provider 实例   Class.forName(com.ibm.dbjdbc.net.DBDriver);     Microsoft SQL Server  Class.forName(com.microsoft.sqlserver.jdbc.SQLServerDriver);   JDBC4 以后可以不装载驱动，会自动装载。 但是为了维护编程规范，建议显式地装载驱动。 2. 建立连接 连接数据库。 Connection connection = DriverManager.getConnection(URL, Username, Password); 参数： Username 用户名 Password 密码 URL 数据库的地址  MySQL   // db_name 为数据库名 String URL=jdbc:mysql://localhost:3306/db_name;     Oracle   // orcl 为数据库的 SID String URL=jdbc:oracle:thin:@localhost:1521:orcl;   有两种连接方式：    thin 连接 jdbc:oracle:thin:@&lt;主机名或IP&gt;:1521:&lt;数据库SID名&gt;； 纯粹用Java完成数据库访问， 只要有数据库驱动包就可以直接通过网络端口访问数据库。   oci 连接 java:oracle:oci@&lt;本地服务名&gt; 需要在客户端安装Oracle的客户端软件，并注册一个本地服务名。    理论上 oci 性能要好于 thin 。但是通常项目中我们使用 thin 连接方式。   PostgreSQL   // db_name 为数据库名 String URL=jdbc:postgresql://localhost/db_name;     DB2   // db_name 为数据库名 String URL=jdbc:db2://localhost:5000/db_name;     Microsoft SQL Server   // db_name 为数据库名 String URL=jdbc:sqlserver://localhost:1433;DatabaseName=db_name;     3. 测试连接是否成功 if(connection != null){  tSystem.out.println(连接成功); }else{  tSystem.out.println(连接失败); } 4. 定义 sql 语句 只要填写正常执行的sql语句即可 不要加 ; 号 String sql = select * from emp; 5. 创建静态处理块对象 静态处理块对象用于存放 sql 语句，该对象执行的时候，数据库会从中拿到 sql 语句并执行。 Statement statement = connection.createStatement(); 6. 执行sql语句 执行的返回值是一个集合。 ResultSet resultSet = statement.executeQuery(sql); 共有三种执行方式： execute 任何SQL语句都可以执行。 返回值是 boolean 型，表明执行该SQL语句是否返回了ResultSet。 executeQuery 只能执行查询语句。 返回值是一个 ResultSet，即结果集。 executeUpdate 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE。 返回值是 int 型，表示被该语句影响的行数。 对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，返回值为 7. 读取结果 遍历结果集合，读取数据库中的数据。 有两种读取方式： 通过下标索引编号，从 1 开始 推荐通过列名来获取，因为列名一般不会发生修改 while (resultSet.next()) {  t//读取第一列  tint anInt = resultSet.getInt(1);  tSystem.out.println(anInt);  t//读取 ename  tString ename = resultSet.getString(ename);  tSystem.out.println(ename);  t... } 8. 关闭连接 statement.close(); connection.close(); 预处理块 PreparedStatement 预处理块 PreparedStatement 是静态处理块 Statement 的子类。 在实际开发中，预处理块的使用更多。 例，现在需要执行 insert 操作，将实体类 Emp 插入对应的数据库中。 使用 Statement 类 public void insert1(Emp emp){  t...  tString sql = insert into emp values( +  t t t t t temp.getEmpno() + , +  t t t t t t' + emp.getEname() + ' + , +  t t t t t t' + emp.getJob() + ' + , +  t t t t t temp.getMgr() + , +  t t t t t tto_date( + emp.getHiredate() + ,'YYYY/MM/DD'), +  t t t t t temp.getSal() + , +  t t t t t temp.getComm() + , +  t t t t t temp.getDeptno() +  t t t t t t);  t//返回值表示受影响的行数  tint i = statement.executeUpdate(sql);  tSystem.out.println(受影响的行数： + i);  t... } 使用 PreparedStatement 类 public void insert2(Emp emp){  t...  tString sql = insert into emp values(?,?,?,?,?,?,?,?);  tpreparedStatement = connection.prepareStatement(sql);  t  tpreparedStatement.setInt(1, emp.getEmpno());  tpreparedStatement.setString(2, emp.getEname());  tpreparedStatement.setString(3, emp.getJob());  tpreparedStatement.setInt(4, emp.getMgr());  tpreparedStatement.setDate(5, new java.sql.Date(new SimpleDateFormat(yyyy-mm-dd).parse(emp.getHiredate()).getTime()));  tpreparedStatement.setDouble(6, emp.getSal());  tpreparedStatement.setDouble(7, emp.getComm());  tpreparedStatement.setInt(8, emp.getDeptno());  t//返回值表示受影响的行数  tint i = preparedStatement.executeUpdate();  tSystem.out.println(受影响的行数： + i);  t... } PreparedStatement 类的使用步骤： 定义 sql 语句，需要填充变量的地方用 ? 号代替。 创建 PreparedStatement 对象，并将 sql 语句闯入。 填充 ？号，下标从 1 开始。 执行时不需要传入 sql 语句，直接执行。 批处理 PreparedStatement 类除了执行 sql 语句代码更简洁。 还有一个好处是可以进行批处理。 假如你现在需要在数据库中插入 1000 条数据，应该怎么做？ 是 建立连接——插入 1 条数据——关闭连接 循环 1000 次吗？ 建立和关闭连接都是需要花费系统资源和时间的，很显然不应该这么做。 我们应该 建立连接——插入 1000 条数据——关闭连接。 这就是批处理。 如何使用批处理？ ... String sql = insert into emp(empno,ename) values (?,?); preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; 1000; i++) {  tpreparedStatement.setInt(1, ...);  tpreparedStatement.setString(2, ...);  tpreparedStatement.addBatch(); } int[] ints = preparedStatement.executeBatch(); ... addBatch()起到分隔语句的作用。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/03/jdbc/",
      "keywords" : "Java，JDBC"
    } ,
  
    {
      "title"    : "Java 之——反射",
      "category" : "Java",
      "content": "反射是 Java 最强大的技术之一，非常重要。 概述 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。 而解剖使用的就是Class类中的方法。 所以先要获取到每一个字节码文件对应的Class类型的对象。 获取 Class 对象 通过完整路径，不导包。 Class class1 = Class.forName(com.kky.entity.Emp);   通过类名，导包。 Class&lt;Emp&gt; class2 = Emp.class;   通过对象，导包，该方式需要创建对象占用内存，不推荐。 Class&lt;? extends Emp&gt; class3 = new Emp().getClass();   如果是基本数据类型，有两种方式  基本数据类型.class  Class&lt;Integer&gt; class4 = int.class;     包装类.Type  Class&lt;Integer&gt; class5 = Integer.TYPE;     通过 Class 对象获取类的成员 获取类的属性 getXXX 只能查找 public 属性，包括从父类继承到的 getDecalredXXX 能查找 所有 的属性，不包括从父类继承到的    方法  返回值  描述  范围  继承     getField(String name)  Field  查找指定名称的属性  public  是    getFields()  Field[]  查找所有的属性  public  是    getDeclaredField(String name)  Field  查找指定名称的属性  所有  否    getDeclaredFields()  Field[]  查找所有的属性  所有  否   获取类的构造器    方法  返回值  描述     getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)  Constructor&lt;T&gt;  查找带有指定形参表的构造方法    getDeclaredConstructors()  Field[]  查找返回所有的构造方法   构造器无法继承，所以不能查找父类的构造器。 获取类的方法 getXXX 只能查找 public 方法，包括从父类继承到的 getDecalredXXX 能查找 所有 的方法，不包括从父类继承到的    方法  返回值  描述  范围  继承     getMethod(String name, Class&lt;?&gt;… parameterTypes)  Method  查找指定名称和参数列表的方法  public  是    getMethods()  Method[]  查找所有的方法  public  是    getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)  Method  查找指定名称和参数列表的方法  所有  否    getDeclaredMethods()  Method[]  查找所有的方法  所有  否   使用反射调用类的方法 现在有一个 Test 类，如何通过反射调用其中的方法？ public class Test {  tpublic Test(){  t} public void Test() {  System.out.println(I'm Test1);  } public void Test(String str) {  System.out.println(I'm Test2);  } public void Test(String str, boolean b) {  System.out.println(I'm Test3);  } } 1. 创建 Class 对象 Class&lt;Test&gt; testClass = Test.class; 2. 创建实例 Object object = testClass.newInstance(); 这里使用的 newInstance 并没有传参，也就是调用类的无参构造器创建实例。 这一步非常关键。 现在很多的框架底层原理都是通过反射来生成实例。 所以在实际开发中，最好把每个类的无参构造器都写出来，而不是由 JVM 默认生成。 否则使用某些框架时会报错。 3. 查找方法并调用 无论是查找还是调用，都需要注意传入正确的参数列表。 查找 Test() 并调用  Method method = clz.getDeclaredMethod(Test); method.invoke(object);  结果  I'm Test1   查找 Test(String str) 并调用  method = clz.getDeclaredMethod(Test, String.class); method.invoke(object, helloworld);  结果  I'm Test2   查找 Test(String str,boolean b) 并调用  method = clz.getDeclaredMethod(Test, String.class, boolean.class); method.invoke(object, helloworld, true);  结果  I'm Test3   使用反射访问私有成员 使用反射可以在类的外部访问类的成员，无论该成员是什么修饰符。 即破坏 Java 的封装性。 Test2 类中有 private 属性、构造器、方法。 public class Test2 { private int id; private Test2() {  } private Test2(int id) {  this.id = id;  } private int add(int a, int b) {  return a + b;  } @Override  public String toString() {  return Test2{ +    id= + id +    '}';  } } 使用 private 构造器 Test2 的无参构造器是私有的，此时无法通过 Test2 test2 = new Test2(); 的方式来创建实例，这也是大部分单例模式的关键。 但是反射能够强制性地使用该无参构造器。 Class&lt;Test2&gt; aClass = Test2.class; Constructor&lt;Test2&gt; declaredConstructor = aClass.getDeclaredConstructor(); declaredConstructor.setAccessible(true); Test2 test2 = declaredConstructor.newInstance(); System.out.println(test2); 结果 Test2{id=0} 关键在于 declaredConstructor.setAccessible(true); 即强制性地让该构造器能够被使用。 这也就是为什么单例模式中除了枚举单例之外的单例模式在反射面前是无效的。 使用 private 属性和方法 同理，将私有成员强制性地设置为 可访问 访问 private 属性 Field id = aClass.getDeclaredField(id); id.setAccessible(true); id.set(test2,666); System.out.println(test2); 结果 Test2{id=666}  调用 private 方法 Method add = aClass.getDeclaredMethod(add, Integer.TYPE, Integer.TYPE); add.setAccessible(true); System.out.println(add.invoke(test2,6,6)); 结果 12 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/05/reflect/",
      "keywords" : "Java, 反射"
    } ,
  
    {
      "title"    : "MySQL 之——基础架构",
      "category" : "cate1",
      "content": "MySQL基础架构 二、MySQL基础架构图  MySQL基础架构可以分为两大类：Server层和存储引擎层  Server层： Server层涵盖了MySQL大部分核心业务功能，并且所有存储引擎的功能都在这一层实现  存储引擎层： 存储引擎有很多，各自有着各自的特点，可以根据场景来选择不同的存储引擎来操作数据    Server层  存储引擎层        我们可以插手的部分 在连接时使用连接池 在优化器中可以查看 sql 语句的执行计划，可以采用对应的优化点，来加快查询 graph LR; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; st=&gt;start: 开始 e=&gt;end: 结束 op=&gt;operation: 操作步骤 cond=&gt;condition: 是 或者 否? st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op 三、MySQL基础架构零件分析  连接器： 管理连接，权限验证  分析器： 词法分析，语法分析  查询缓存： 命中缓存，返回结果  优化器： 执行计划生成，索引选择  执行器： 操作引擎，返回结果  存储引擎： 存储数据，提供读写接口 四、基础零件剖析 4.1 连接器  使用MySQL数据库，第一步是要连接MySQL数据库，这时候第一个迎接的你就是连接器。连接器负责跟客户端建立连接、获取权限、管理连接等工作。我们一般是使用命令mysql -uroot -p + Enter后输入密码并登录。当输入密码提交登录时，MySQL客户端会与服务器建立连接，在完成TCP握手后，连接器就开始确认你所输入的用户名和密码。如果用户名密码正确则成功登录，如果用户名密码错误，会收到如下错误信息！   登录失败错误信息       登陆成功后，连接器会对你进行权限验证，此时权限验证都依赖于这时候读取到的权限，并根据你的权限而赋予对数据库的操作的权力。正是因为权限验证对验证时权限读取的依赖问题，也反映出了如下注意点！ 注意： 一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。 4.2 查询缓存  连接建立完成后，假设你正在使用该SQL语句查询一条数据select * from tb_user where id = 1。接下来MySQL执行逻辑就回到了查询缓存中。此时MySQL拿到一个查询请求后，先到查询缓存里看看是否执行过一这条SQL语句，在之前如果执行过这条语句，其结果大概就是以Key-Value（键值对）的形式直接缓存在内存中。这里的Key代指的是查询语句，Value代指的是查询结果。如果你所查询的语句在查询缓存中就命中缓存，它就会把该SQL语句对应的value值结果集返回，这样就并不会执行其他MySQL零部件了，大大提高了查询效率。 但是往往利弊是同时存在的，查询缓存有着一个致命的缺点，那就是查询缓存失效十分频繁。这里所说的查询缓存失效是指的只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此可能你废了很大的劲把结果存起来，还没使用呢，就被一个更新全清空了！大家都知道数据的宝贵，由于这个致命的缺点，导致查询缓存在MySQL8.0版本的时候就被抛弃了，也就是说MySQL8.0版本彻底删除了查询缓存！ 4.3 分析器  如果没有命中缓存，那就必须执行SQL语句了。这时候你所写的查询语句就到了分析器，分析器先会对SQL语句进行“词法分析”，它会分析并识别你所输入的空格、字符串和关键字都在MySQL中代表了什么，比如首先它会识别出来select关键字、表名、列名和条件。识别了SQL语句的这些后，就到了“语法分析”的阶段，它会根据MySQL的语句标准来检查你所输入的SQL语句是否符合标准。如果不符合标准就会报出一个“You have an error in your SQL syntax”的语法错误提示。 注意： 一般语法错误提示第一个你所需要关注的是紧接着“use near”的内容，因为它会告诉你哪个语法附近有错误！ 4.4 优化器  能进到优化器优化环节的SQL语句，说明在分析器分析的时候没有出现任何错误。那么优化器对该SQL语句做了些什么呢？假如一个SQL语句中是有索引的，优化器会根据优化规则选择合适的索引。或者是一个语句夺标关联时，优化器决定了各个表之间的连接顺序。这里我们看一个多表连接的SQL语句： select * from tb_user join tb_grade on tb_user.id = tb_grade.uid where tb_user.username = 'Ziph' and tb_grade.subject = 'Java';   先从tb_user表中取出username=Ziph的记录ID，再根据ID关联到tb_grade表，再判断tb_grade表中的subject是否等于Java   先从tb_grade表中取出subject=Java的记录ID，再根据ID关联到tb_user表，再判断tb_user表中的username是否等于Ziph  两种逻辑查询出的结果虽然是一样的，但是执行效率会有所不同，而优化器的作用就是根据自己的优化逻辑判断来决定使用哪一个方案 4.5 执行器  通过分析器知道了做什么，通过优化器知道了怎么做，这就遇到了一个问题，谁来做？可想而知就是执行器开始执行SQL语句。开始执行的时候，要先判断一下你对表是否有执行查询的权限，如果没有就会报出错误的提示信息。如果有权限，就打开表继续执行。执行器会根据表的引擎来调用提供的引擎接口，开始执行。 执行器调用引擎接口执行过程： 调用InnoDB引擎接口取这个表的第一行，判断是否符合查询条件，如果不符合则跳过，如果符合则将这行存在结果集中。以此类推，执行遍历所有行将所有满足条件的记录集作为结果集返回 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/08/base-infrastructure/",
      "keywords" : "keyword1, keyword2"
    } ,
  
    {
      "title"    : "MySQL 之——索引",
      "category" : "MySQL",
      "content": "索引是任何数据库中都十分重要的一个技术点。 序言  索引是帮助 MySQL 高效获取数据的数据结构。 索引存储在文件系统中，是持久化的数据，在使用时才加载到内存加快速度。 索引的文件存储形式与存储引擎有关。 索引是放在磁盘的，是持久化的数据。 只是在使用的时候为了加快速度加载到内存。 数据结构 从数据结构的层面上来说，以下四种数据结构都能作为索引文件的结构： hash 二叉树 B 树 B+ 树 但是实际中，大多数索引都是使用 B+ 树的结构。 这是因为其他数据结构都存在着着或多或少的问题。 Hash 表 hash 表适用于等值查询，而业务中更多的是范围查询。 hash 表在使用的时候需要把全部的数据加载到内存，比较耗费内存空间。 二叉树 普通二叉树 普通的二叉树适用于二分查找，但是存在左右子树不平衡的情况。 严重时二叉树会变成类似于链表的结构（只有左子树没有右子树或者只有右子树没有左子树）。 AVL 树 AVL树是一颗严格意义上的平衡树，最高子树跟最低子树高度之差不能超过1。 但是为了维护 AVL 树的平衡，在进行元素插入时经常会需要进行 1 到 N 次的旋转，严重影响插入的性能。 红黑树 红黑树是基于AVL树的一个升级，损失了部分查询的性能，来提升插入的性能。 在红黑树中最低子树跟最高子树高度之差不超过 2 倍即可。 在插入的时候，不需要进行 N 多次的旋转操作。 而且还加入了变色的特性，来满足插入和查询性能的平衡。 总结 二叉树及其 N 多的变种都不能支撑索引。 原因是树的深度无法控制或者插入数据的性能比较低。 B树 B树特点： 所有键值分布在整颗树中。 搜索有可能在非叶子结点结束，在关键字全集内做一次查找，性能逼近二分查找。 每个节点最多拥有 m 个子树。 根节点至少有 2 个子树。 分支节点至少拥有 m/2 颗子树（除根节点和叶子节点外都是分支节点）。 所有叶子节点都在同一层，每个节点最多可以有 m-1 个key，并且以升序排列。  实例图说明： 每个节点占用一个磁盘块，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。 两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。 以根节点为例，关键字为 16 和 34，P1 指针指向的子树的数据范围为小于 16，P2 指针指向的子树的数据范围为 16~34，P3 指针指向的子树的数据范围为大于 34。  查找关键字 28 过程： 根据根节点找到磁盘块 1，读入内存。【第 1 次磁盘 I/O 操作】 比较关键字 28 在区间（16,34），找到磁盘块 1 的指针 P2。 根据 P2 指针找到磁盘块 3，读入内存。【第 2 次磁盘 I/O 操作】 比较关键字 28 在区间（25,31），找到磁盘块 3 的指针 P2。 根据 P2 指针找到磁盘块 8，读入内存。【第 3 次磁盘 I/O 操作】 在磁盘块 8 中的关键字列表中找到关键字 28。   缺点： 每个节点不仅存储 key 值，还存储数据 data ，会造成以下的情况： graph LR; A[data 越大] --&gt; B[key 数量越少] B --&gt; C[树越深] C --&gt; D[索引性能越差] B 树的节点的索引数量和总索引数量是指数级的关系： 假设每个节点能够存储 x-1 个键值和 x 个指向子节点的指针。 第一层：x-1 个键值，x 个指针 第二层：x(x-1) 个键值，x·x 个指针 第三层：x·x·(x-1) 个键值，x·x·x 个指针 … 对于键值而言，数据实在是太大了，会严重减少键值的数量，加大树深。 所以提出了 B+ 树：非叶子节点不存储数据。 B+ 树 B+Tree是在BTree的基础之上做的一种优化，变化如下： B+Tree每个节点可以包含更多的节点，这个做的原因有两个，第一个原因是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快。 非叶子节点存储key，叶子节点存储key和数据。 叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高。  注意： 在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。 因此可以对 B+Tree 进行两种查找运算： 一种是对于主键的范围查找和分页查找。 另一种是从根节点开始，进行随机查找。  B+ 树的树深非常低： 假设磁盘块大小为 4k ，寻址空间为 32 位，则指针大小为 4 字节，键值暂定为 int 类型，同样是 4 字节。 第一层：500 个键值，500 个指针 第二层：25000 个键值，25000 个指针 第三层：1250 万个键值，1250 万个键值 第四层：62.5 亿个键值，62.5 亿个键值 一般的数据库最多到三层，如果超过了 1250 万条数据，那么一定是要分库分表的，不会存在一个数据库里。 这个树深，是任何二叉树，甚至 B 树都比不了的。 聚簇索引 在 InnoDB 中，数据和索引是存储在一起的，这种方式称为聚簇索引。 聚簇索引就是按照每张表的主键构造一棵B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。 这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。 InnoDB 通过主键聚集数据。 如果没有定义主键，InnoDB 会选择非空的唯一索引代替。 如果没有这样的索引，InnoDB 会使用 rowID （行号）作为隐式的主键。 rowID 是一个 6 字节的字段，随着插入新行而单调增加。 因此，按行 ID 排序的行在物理上是按插入顺序排列的。 graph LR; A[使用主键] --没有主键--&gt; B[使用唯一键] B --没有唯一键--&gt; C[使用 rowID]  回表 一般来说，除了搜索引擎帮我们自动创建的主键索引外。 我们可以自定义某些列实现辅助索引。 在 InnoDB 中，辅助索引的叶子节点存储的不是行记录数据，而是主键值。 使用辅助索引查询数据的流程是这样的： 查询辅助索引树获取主键。 在主键索引中获取数据。 也就是说，要查两棵索引树。 使用辅助索引总是要进行二次查找，所以有时也将辅助索引称为二级索引。 索引覆盖 假设现在有一张表 Table test{  tid int(11) primary key,  tname varchar(20),  tsex varchar(10),  tjob varchar(50) } 并且有主键索引 (id) ，和普通索引 (name ,sex) 当执行select sex from Test where name = 'XXX';是不需要回表的。 因为 sex 本身就在索引中，不需要到主键索引中去寻找。 但如果执行select * from Test where name = 'XXX';就需要回表。 因为 job 不在索引中，需要到主键索引中去寻找。 也就是说，在使用聚簇索引的普通索引时，能不查找索引之外的字段，就不要查找。 因为这样可以只执行一次查询。 而回表是两次查询。 索引下推 现在有这样一张表 test    id  name  age  sex     1  zhangsan  10  man    2  zhangsan  20  man    3  zhangsan  30  man    4  zhangsan  40  man   建立了联合索引 (name ,age) 现在要执行语句 select * from test where name = 'zhangsan' and age = 10; 在 MySQL 5.6 之前，是没有索引下推的，也就是说尽管这是一颗联合索引树，但是在 InnoDB 的眼里，age 字段是被忽略的 InnoDB “眼中” 的索引树    id  name  age     1  zhangsan  10    2  zhangsan  20    3  zhangsan  30    4  zhangsan  40   此时会先从 (name ,age) 索引树中找出 name = 'zhangsan' 的 4 个 id 值， 然后再去 (id) 索引树中检索age = 10 的数据。 但在 MySQL 5.6 之后，有了索引下推，此时进行搜索时，搜索引擎不会忽略 age 字段 InnoDB “眼中” 的索引树    id  name  age     1  zhangsan  10    2  zhangsan  20    3  zhangsan  30    4  zhangsan  40   此时 (name ,age) 索引树会返回符合name = 'zhangsan' and age = 10的 1 个 id 值， 然后在 (id) 索引树中直接返回数据。 索引下推就是在第一次索引时就进行条件匹配，减少第二次索引的数量。 非聚簇索引 在 Myisam 中，B+ 树的叶子节点存储的是行数据记录的地址。 这种数据和索引分开存放的方式，称之为非聚簇索引。  非聚簇索引的辅助索引的叶子节点依然是存储行数据记录的地址。 也就是说，在非聚簇索引中，主键索引和辅助索引除了键值的不同，返回值是相同的，都是行数据记录的地址。 所以在非聚簇索引中，不存在回表。 聚簇索引和非聚簇索引的区别 下图是聚簇索引和非聚簇索引的辅助索引执行过程： 索引的分类 MySQL 索引的五种类型： 主键索引 唯一索引 普通索引 全文索引 组合索引 通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。 主键索引 主键是一种唯一性索引，它必须指定为 PRIMARY KEY，每个表只能有一个主键。 主键往往使用自动递增的方式，这样索引更新的花费最低（直接插到最右边）。 唯一索引 索引列的所有值都只能出现一次，即必须唯一，值可以为空。 普通索引 基本的索引类型，值可以为空，没有唯一性的限制。 在使用聚簇索引的普通索引时尽量实现覆盖索引，提高系统性能。 全文索引 搜索全文中的某个关键字。 MyISAM支持，InnoDB 在 5.6 之后支持。 全文索引的索引类型为 FULLTEXT 。 全文索引可以在 varchar ,char ,text 类型的列上创建。 真正的全文索引一般不使用数据库实现。 使用 Lucene，Solr，ElasticSearch 等全文检索引擎实现。 组合索引 多列值组成一个索引，专门用于组合搜索。 组合索引的最左匹配原则 如果使用 (name ,age) 组合索引。 先匹配 name，name符合了再去匹配 age。 组合索引的顺序非常重要 加入现在需要建立两个索引： (name ,age) 和 (age) 如果组合索引的顺序是先 name 再 age 那么还要单独建一个 age 的索引 就需要建立两棵索引树 如果组合索引的顺序是先 age 再 name 那么不需要再单独建 age 的索引 就只需要建立一棵索引树 现在需要建立三个索引：(name ,age ) ,(name) ,(age) 有两种实现方案： 建立 (name ,age) 和 (name) 两颗索引树 建立 (age,name) 和 (age) 两颗索引树 哪种更好？ 第二种方案更好。 因为 age 字段是 int 类型，name 字段是字符串类型，age 字段所占据的空间更小。 第一种方案是 name*2 + age*1 ，而第二种方案是 name + age*2。 第二种方案所占据的空间更小。 存储引擎       InnoDB  MyISAM  Memory     索引类型  聚簇索引  非聚簇索引  默认 hash 索引支持 B 树索引    支持事务  是          支持表锁  是  是  是    支持行锁  是          支持外键  是          支持自增  是  是  4.1.0后支持    支持变长列  是  是       支持全文索引  5.6后支持  是       适合操作类型  insert delete update  select       文件结构  .frm 表结构 .idb 数据和索引  .frm 表结构.myi 索引.myd 数据  .frm 表结构    优点  支持事务支持回滚有崩溃修复能力多版本并发的事务安全  占用空间小处理速度快  速度快    缺点  读写效率比较差占用的磁盘空间较大  不支持事务的完整性和并发性  重启后数据消失    使用场景  高并发更新操作比较多需要使用事务自动灾难恢复  count 计算很多数据仓库等查询频繁的应用  高速的临时数据数据丢失后影响较小   外键 使用外键可使两个表之间存在依赖关系。 外键所在的表是子表，所依赖的表为父表，父表中被子表关联的字段必须为主键或唯一键。 当父表中被关联的字段的值被修改或删除时，子表中对应的字段也会被修改或删除。 当子表想要插入新数据时，其外键列的值必须是父表中存在的值。 自动增长列 InnoDB 和 MyISAM 都支持 auto_increament 列。 注意： 每张表中只能有一个 auto_increment 列，并且该列要么是主键要么是唯一键。 也就是说，auto_increament 列不允许重复值。 auto_increament 列的值默认从 1 开始，不能为空。 如果在插入时省略了 auto_increament 列或者值为 0 或 null，那么会自动进行递增的操作。 如果插入时声明了 auto_increament 列的值，合法且不重复。 该值比当前的值大，插入该值，并且从该值开始递增。 该值比当前的值小，插入该值，不影响递增。  在 InnoDB 中，为了保证并发下的插入操作不会发生冲突，有一个自增锁。 即自增操作是有锁来保证的。 如果插入 10 条 sql 数据失败了回滚，但是自增锁依然往后递增了 10 次。 而在 MyISAM 中，因为使用的是表锁。 不存在并发插入操作，所以不需要自增锁这样的设计。 InnoDB 的 .idb 文件问题 一般情况下找不到 .idb文件，因为 InnoDB 默认把所有的数据和索引存放在同一个文件中 打开 mysql 命令行，输入 show variables like 'innodb_file_per_table'; 结果 +-----------------------+-------+ | Variable_name  | Value | +-----------------------+-------+ | innodb_file_per_table | OFF | +-----------------------+-------+ 这个参数的意思是要不要给 InnoDB 中的每一个表建立单独的文件，可以看到是 off ，也就是不。 如果想要单独存放每个表的 .ibd 文件，请如下设置： set global innodb_file_per_table = on; MyISAM 的存储格式 静态型 表的所有列都是静态的（定长的）。 这种情况下，维护和访问预定义格式存储的数据需要的开销很低。 但是，需要的空间会更多，因为所有数据都占用了该列的最大空间。 动态型 存在动态型的列（不定长的）。  优点 使用空间少。  缺点    更新数据时，需要移动数据，产生内部碎片的同时，也降低了维护和访问的效率。   解决办法     尽量的使用定长字段。   使用 optimize table 语句，整理表中的碎片。         压缩型 针对应用程序的声明周期中，只读的数据表。 我们可以通过 myisampack 工具转化为压缩表，以减少使用的磁盘空间。 Memory 的表结构 Memory 会将表结构以 .frm 文件的格式存在磁盘中，所以 Memory 的表结构是持久化的。 但是 Memory 的数据是存放在内存中，所以重启服务器后数据将丢失。 Mysql 指令 查看引擎 查看已安装的所有引擎  show engines;   查看某表的搜索引擎  show create table 表名;   修改引擎 修改配置文件 打开 C:  Program Files  MySQL  MySQL Server 5.5 下的 my.ini 文件 修改其中的 default-storage-engine 的值 通过命令行修改配置 SET @@storage_engine = &lt;Storage Engine&gt;;   使用create table语句指定 CREATE TABLE t (i INT) ENGINE = &lt;Storage Engine&gt;;   使用 ALTER TABLE 更改存储引擎 ALTER TABLE t ENGINE = &lt;Storage Engine&gt;;   索引维护 索引在插入新的值的时候，为了维护索引的有序性，必须要维护。 在维护索引的时候需要需要分以下几种情况： 如果插入一个比较大的值，直接插入即可，几乎没有成本 如果插入的是中间的某一个值，需要逻辑上移动后续的元素，空出位置 如果需要插入的数据页满了，就需要单独申请一个新的数据页，然后移动部分数据过去，叫做页分裂。 此时性能会受影响同时空间的使用率也会降低。 除了页分裂之外还包含页合并。 主键索引尽量使用自增主键。 索引优化 索引越少越好：  索引是需要持久化存储的，需要占用磁盘空间。  使用时还需要加载到内存，占用内存空间。  更新数据时还要维护索引。   表太小不需要建索引，速度反而会变慢  没索引 直接查。  有索引 先查索引，再查表。   主键索引尽量使用自增主键 插入新数据时维护索引的成本最低。 ",
      "url"      : "https://kekaiyuan.github.io//2021/07/08/index/",
      "keywords" : "MySQL"
    } ,
  
    {
      "title"    : "template page",
      "category" : "cate1",
      "content": "在使用 JDBC 访问数据库时，需要建立连接和关闭连接。 但是这两个操作都需要花费时间。 在高并发的环境中，为每一个操作都建立连接和关闭连接是不现实的。 于是就有了连接池的概念。 连接池中存放着多个连接，这些连接一般情况下是不会关闭的。 然后有 sql 操作时，从连接池中拿出一个连接，操作完毕把连接还给连接池。 这样 sql 操作就不需要单独地建立连接了。 连接池的设计一般要涉及以下四点： 连接池的初始大小 连接池的扩容 连接池的最大容量 连接的死亡时间 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/09/jdbc-connect-pool/",
      "keywords" : "keyword1, keyword2"
    } ,
  
    {
      "title"    : "MySQL 之——基础架构与日志系统",
      "category" : "MySQL",
      "content": "MySQL 之——基础架构与日志系统 基础架构 连接器 连接器负责跟客户端建立连接，获取权限、维持和管理连接 用户名密码验证 查询权限信息，分配对应的权限 MySQL 的权限控制比 oracle 的要宽松。 可以使用 show processlist 查看现在的连接 如果太长时间没有动静，就会自动断开，通过 wait_timeout 控制，默认 8 小时 连接可以分为两类： 长连接 推荐使用，但是要周期性的断开长连接 连接池用的就是长连接。 短连接 查询缓存 当执行查询语句的时候，会先去查询缓存中查看结果。 之前执行过的 sql 语句及其结果可能以 key-value 的形式存储在缓存中。 如果能找到则直接返回，如果找不到，就继续执行后续的阶段。 但是，不推荐使用查询缓存： 查询缓存的失效比较频繁，只要表更新，缓存就会清空 缓存对应新更新的数据命中率比较低 MySQL 8.0 之后没有缓存了，即使是 8.0 以前的版本，缓存也是默认关闭的，需要手动开启。 分析器 词法分析：MySQL 需要把输入的字符串进行识别每个部分代表什么意思 把字符串 T 识别成 表名 T 把字符串 ID 识别成 列 ID 语法分析： 根据语法规则判断这个 sql 语句是否满足 MySQL 的语法。 如果不符合就会报错 You have an error in your SQL syntax; 优化器 在具体执行SQL语句之前，要先经过优化器的处理 当表中有多个索引的时候，决定用哪个索引 当sql语句需要做多表关联的时候，决定表的连接顺序 等等 不同的执行方式对SQL语句的执行效率影响很大 RBO 基于规则的优化 CBO 基于成本的优化 现在更多的使用基于成本的优化。 日志系统 Redo Log Redo Log 是 InnoDB 专有的日志文件。 当发生数据修改的时候， InnoDB 引擎会先将记录写到 Redo Log 中，并更新内存，此时更新就算是完成了，同时 InnoDB 引擎会在合适的时机将记录操作到磁盘中。 有了 Redo Log 之后， InnoDB 就可以保证即使数据库发生异常重启，之前的记录也不会丢失，叫做 crash-safe 。 Redo Log 如何保证事务持久化 事务持久化的定义： 一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。 即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态。 MySQL 通过 WAL(Write Ahead Log) 技术来保证事务的持久性，即先写日志，再写磁盘。 在修改数据之前，先把更新后的值写入 Redo Log 中。 Redo Log 写入完毕后，再去修改数据。 当系统突然崩溃重启时，根据 Redo Log 中的值进行数据恢复。  Q：Redo Log 在磁盘中，数据库也在磁盘中，为什么不直接更新数据库？  先讲个故事： 小柯和小王都有一本书，叫 《数据库》。 有一天，他们想把 《数据库》 中所有的英文单词都变成大写。 因为不知道哪一页哪一行有英文单词，所以他们需要把 《数据库》 从头到尾读一遍，找到存在的英文单词。 任务量也很大，有很多英文单词需要改。 小王从早上改到下午，没改完，这时一个小伙伴约小王出去玩。 当小王玩到晚上回来后，小王把这件事忘得一干二净。 于是小王的是烂尾工程。 小柯也遇到了和小王一样的问题。 但他有一本私人珍藏 《日志》 。 《日志》 也很厚，小柯不知道 《日志》 中哪一页哪一行有什么。 但他直接翻开 《日志》 的最后一页，在最后一行写下了： “把所有英文单词改成大写。” 并在这句话后面打了个 × 。 小柯从早上改到下午，没改完，这时也有一个小伙伴约小柯出去玩。 当小柯玩到晚上回来后，也把这件事忘得一干二净。 但是小柯有个好习惯，回家后先看 《日志》 。 他看到了：“把所有英文单词改成大写。”和这句话后面的 × 。 于是小柯想起来了他有个任务，而且这个任务没做完。 于是他接着做，成功完成了任务。 现在把故事映射到计算机中： 刷脏是 随机 I/O ，写 Redo Log File 是 顺序 I/O ，随机 I/O 比顺序 I/O 快得多。  刷脏： 内存中的数据被修改后称之为脏数据，把脏数据同步回磁盘的过程叫做刷脏。  随机 I/O ： 指读写操作时间连续，但访问地址不连续，随机分布在磁盘的地址空间中。 就像小柯和小王的 《数据库》 中哪里都可能有英文单词一样，是随机分布的。  顺序 I/O ： 顺序 I/O 是指读写操作的访问地址连续。 在故事中小柯只是写下了 1 条日志，但如果小柯要写 10 条日志也好，100 条日志也好，都只需要顺着往下写，前面的内容跟他没关系。   刷脏很可能需要刷很多页的数据，但是写入 Redo Log File 的数据量很少。 速度快，数据少，所以先写日志，再写磁盘。 缓冲池 内存中的 Redo Log 并不是直接写入 Redo Log File 中的，这样的速度会很慢。 而是通过缓冲池的机制来实现。 Redo Log 会先写入 InnoDB 的 Log Buffer ，这个缓存位于内存中的用户区。 然后写入 OS Buffer ，该缓存位于内存中的内核区。 最终 OS Buffer 会使用 fsync() 函数 将数据同步到文件中。 Redo Log Block Redo Log Buffer 和 Redo Log File 都是被划分为一个个 Redo Log Block 的。 多条 Redo Log 可以存入一个 Block 中，而一个 Block 的大小是 512 字节，刚好是一个扇区的大小。 扇区是读写的最小单位，这样的设计有助于进一步加快 Redo Log 写入 Redo Log File 的速度。 刷新策略 在 MySQL 中，有一个变量名为 innodb_flush_log_at_trx_commit，用来控制redo log刷新到磁盘的策略。 innodb_flush_log_at_trx_commit = 0 每次 commit 直接写入 Log Buffer ，然后每秒写入 OS Buffer，并调用 fsync() 刷到磁盘。 innodb_flush_log_at_trx_commit = 1 每次 commit 直接写入 OS Buffer ，并调用 fsync() 刷到磁盘。 innodb_flush_log_at_trx_commit = 2 每次 commit 直接写入 OS Buffer ，然后每秒调用 fsync() 刷到磁盘。 MySQL 默认使用 innodb_flush_log_at_trx_commit = 1，因为该方式虽然慢，但是最安全。 另外两种方式都以秒为单位，也就是说，当系统崩溃时，我们可能会丢失一秒钟的数据。 文件结构 InnoDB 使用 ib_logfile 文件存储 Redo Log。 ib_logfile 的文件可以有多个，每一个都是同样的大小。 这些文件组成一个环状的结构。 循环写 write pos 是写指针，一边写一边向后移动。 当写到最后一个文件的末尾时（例如 ib_logfile3 ），会移动到第一个文件 (ib_logfile0) 的开头。 采用循环写的方式能够控制文件大小，加快读取速度。 check point 为了保证 Redo Log File 中的数据已经被同步到磁盘中，加入了 check point 指针。 check point 之前的内容是已经被刷入磁盘的，之后的内容并没有刷入到磁盘。 write pos 和 check point 之间的部分就是 Redo Log File 中可以写入的部分。 当 write pos 追上 check point 时，必须先等 check point 往前推进，然后 write pos 才能继续前进。 好处： 缩短数据库的恢复时间。 当系统崩溃需要恢复时，check point 前面的 Redo Log 已经刷入磁盘，不需要恢复。 只需要恢复 check point 之后的 Redo Log。 缓冲池不够用时，将脏页刷新到磁盘。 在高并发的情况下，如果使用每隔一秒写入一次文件的策略，缓冲池是有可能会满的。 此时需要使用 LRU 算法，替换最少使用的页，如果该页是脏页，强制刷新到磁盘中。 Redo Log 不可用时，将脏页刷新到磁盘。 Redo Log File 是会满的，但是其中的数据并不是全部都有用的。 事实上，只需要能够保证系统崩溃时所有未完成的事务能够继续执行即可。 所以 Redo Log 的时效性很短，每过一秒，就有大量的 Redo Log 失效，因为它们已经被同步到磁盘中去了。 write pos 和 check point 之间的部分就可以被视为无用的，当有新的 Redo Log 写入时，可以直接覆盖这部分内容。 Undo Log Undo Log 实现了事务的原子性。 在 MySQL 数据库 InnoDB 存储引擎中，还用 Undo Log 来实现多版本并发控制 (简称：MVCC)。 在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 Undo Log ），然后进行数据的修改。 如果出现了错误或者用户执行了 Rollback 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。 注意： Undo Log 是逻辑日志，可以理解为： 当 delete 一条记录时，Undo Log 中会记录一条对应的 insert 记录 当 insert 一条记录时，Undo Log 中会记录一条对应的 delete 记录 当 update 一条记录时，它记录一条对应相反的 update 记录 Bin Log Bin Log 是 Server 层的日志，主要做 MySQL 功能层面的事情。 在 MySQL 中，Bin Log 默认是不开启的，需要手动开启。 与 Redo Log 的区别: Redo Log 是 InnoDB 独有的。 Bin Log 因为是 Server 层的日志，所以是所有引擎都可以使用的。 Redo Log 是物理日志，记录的是在某个数据页上做了什么修改。 Bin Log 是逻辑日志，记录的是这个语句的原始逻辑。 Redo Log 是循环写的，空间会用完。 Bin Log 是追加写的，当 Bin Log 文件达到一定大小后写入新的文件，不会覆盖之前的日志信息。 备份系统 每个企业都必须实现属于的备份系统，用于用于恢复数据。 一般而言，备份系统会包含以下两个内容： 整库备份 存储一段时间内的所有 Bin Log 恢复数据的流程： 找到最近一次的全量备份数据 从备份的时间点开始，将备份的 Bin Log 取出来，重放到要恢复的那个时刻。 例：现在是 2021-7-11-12:38 ，我不小心把数据库删了，如何恢复？ 找到离 2021-7-11-12:38 这个时间点最近的备份，假设是 2021-7-11 凌晨 0 点的备份。 从备份系统中取出 2021-7-11-0:00 到 2021-7-11-12:38 的 Bin Log 并执行。 在设计备份系统时，应该考量以下两点： 整库备份的周期 是一天一备还是一周一备？或是…… 在备份系统中存储多长时间的所有 Bin Log  如果存储的是一周内的所有 Bin Log，那么数据可以恢复到一周内的任意时刻。  如果存储的是两周内的所有 Bin Log，那么数据可以恢复到两周内的任意时刻。  ……   Redo Log 的两阶段提交 数据更新 DML 的流程 执行流程： 执行器先从引擎中找到数据，如果在内存中直接返回，如果不在内存中，查询后返回。 执行器拿到数据之后会先修改数据，然后调用引擎接口重新吸入数据。 引擎将数据更新到内存，同时写数据到 Redo Log 中，此时的 Redo Log 的状态为 prepare，并通知执行器执行完成，随时可以操作。 执行器生成这个操作的 Bin Log 。 执行器调用引擎的事务提交接口，引擎把刚刚写完的 Redo Log 改成 commit 状态，更新完成。  Redo Log 的提交分为 prepare 和 commit 两个阶段，所以称之为两阶段提交。 为什么必须有“两阶段提交”呢？ 如果不使用两阶段提交，假设当前 ID=2 的行，字段 c 的值是 0，使用 update 语句修改该行的字段 c 的值为 1。 当写完第一个日志后，还没有写第二个日志时，发生了 crash 。 先写 Redo Log 后写 Bin Log Redo Log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1 。 但是由于 Bin Log 没写完就 crash 了，所以 Bin Log 中并没有记录这个语句。 当使用 Bin Log 恢复临时库时，由于缺失了该语句，所以临时库中这一行 c 的值为 0 ，与原库不同。 先写 Bin Log 后写 Redo Log 由于 Redo Log 还没写，所以崩溃恢复以后这个事务无效，这一行 c 的值是 0 。 而 Bin Log 中却记录了该语句，所以使用 Bin Log 来恢复时就会多一个事务，这一行 c 的值就是 1 ，与原库不同。 可以发现，如果不加入任何机制，单纯地写入 Redo Log 和 Bin Log 。 如果在写入第一个日志后 crash ，两个 Log 恢复的数据库将不同。 有了两阶段提交的 Crash Recovery    Bin Log  Redo Log  crash 情况  恢复操作     有记录  commit  正常完成的事务  不需要恢复    有记录  prepare  在 Bin Log 写完提交事务之前的 crash  提交事务    无记录  prepare  在 Bin Log 写完之前的 crash  回滚事务    无记录  无记录  在 Redo Log 写之前 crash  回滚事务  ",
      "url"      : "https://kekaiyuan.github.io//2021/07/10/framework-log/",
      "keywords" : "MySQL"
    } ,
  
    {
      "title"    : "Java 多线程与高并发之—— synchronized 锁升级",
      "category" : "Java",
      "content": "Java 多线程与高并发之—— synchronized 锁升级 序言 以前 synchronized 是直接使用重量级锁的（通过操作系统调度线程，需要进行状态切换）。 后来人们发现这种方式的开销太大了，经过研究，提出了以下的锁升级模式： graph LR; A[无锁状态] --&gt; B[偏向锁] B --&gt; C[轻量级锁（自旋锁）] C --&gt; D[重量级锁] 无锁状态 无锁状态很简单，就是资源没有被上锁。 偏向锁 HotSpot 的作者在经过大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁。 也就是说，在一段时间，某个资源往往只有一个线程在使用。 此时如果每一次访问都要上锁，会大大影响程序执行的效率。 所以提出了偏向锁。 某资源如果第一次被某线程访问，那么该资源会偏向这个线程，它会在对象头中记录该线程的 ID 。 当该线程再次访问时，经过对比，发现线程 ID 一致，那么就可以直接访问，省略加锁解锁操作。 现假设某偏向锁被线程 1 持有，当线程 2 尝试获取锁时，发现是个偏向锁，它会检查线程 1 的状态： 线程 1 存活，先将线程 1 暂停，将锁升级为轻量级锁，然后线程 1 继续执行。 线程 1 不存在，则线程 2 直接持有该偏向锁，不进行锁升级。 轻量级锁 轻量级锁又称自旋锁，由偏向锁升级而来。 现在锁已经被线程 1 持有，然后线程 2 也要竞争锁。 线程 2 会进行以下等待： while(没有获得锁){  t//什么都不做 } 这是一个循环，什么拿到锁，什么时候结束该循环，继续执行。 于是有人形象地称呼这个循环操作为自旋。 重量级锁 重量级锁需要将线程在用户态和内核态之间来回切换，这个切换过程是需要时间的。 于是轻量级锁的本质是用短时间的忙等（使用了 CPU ，但是没有执行任何有效的任务——自旋）换取线程的状态切换的开销。 所以当轻量级锁的开销大于重量级锁的开销时，进行锁升级。 一般轻量级锁在自旋 10 次后会升级为重量级锁。 切换到内核态，进入阻塞队列，等待操作系统的调度。 锁的细化与粗化 锁细化 我们在编程的时候，都会尽量把同步代码块写的很小。 因为同步代码块的执行是互斥的，同一时刻最多只能有一个线程执行同步代码块，其他线程只能等着锁被释放。 锁粗化 如果我们的程序是这样的： 对 object 1 加锁 操作1 解锁 ... 对 object 1 加锁 操作2 解锁 ... 对 object 1 加锁 操作3 解锁 也就是说对同一对象反复的加锁解锁，那么实际上这样的写法是更好的。 对 object 1 加锁 操作1 ... 操作2 ... 操作3 解锁 这就是锁粗化。 如果 JVM 虚拟机检测到对同一对象一连串的加锁解锁操作，就会自动进行锁粗化的操作。 三种锁的区别    锁  优点  缺点  适用场景     偏向锁  不需要加锁解锁，只需要对比 ID和执行非同步方法相比仅存在纳秒级的差距  如果线程间存在锁竞争，会带来额外的锁撤销的消耗  适用于只有一个线程访问同步块场景    轻量级锁  竞争的线程不会阻塞提高了程序的响应速度  自旋会消耗CPU  追求响应速度同步块执行速度非常快线程数少    重量级锁  线程竞争不使用自旋，不会消耗CPU  线程阻塞，响应时间缓慢  追求吞吐量同步块执行速度较慢线程数多   注意 为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了。 偏向锁升级为轻量级锁也不能再降级为偏向锁。 一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。 ",
      "url"      : "https://kekaiyuan.github.io//2021/07/10/lockup/",
      "keywords" : "Java"
    } ,
  
    {
      "title"    : "MySQL 之——执行计划",
      "category" : "MySQL",
      "content": "MySQL 之——执行计划 序言 在企业项目中，SQL 语句的优化是十分重要的一个点，两个 SQL 语句可能实现的内容一样，但是性能上却天差地别。 于是类似于我们 C++, Java 中的 Debug 模式一样。 在 MySQL 中可以使用 explain + SQL 语句 来查看查询语句执行的细节，从而针对性地对其优化。 MySQL 官网 执行计划中包含的信息 执行计划一共包含以下内容：    Column  Meaning     id  The SELECT identifier    select_type  The SELECT type    table  The table for the output row    partitions  The matching partitions    type  The join type    possible_keys  The possible indexes to choose    key  The index actually chosen    key_len  The length of the chosen key    ref  The columns compared to the index    rows  Estimate of rows to be examined    filtered  Percentage of rows filtered by table condition    extra  Additional information   id 一个 select 语句往往包含多个 select 语句。 id 用于表示这些语句的执行顺序。 执行顺序： 优先执行 id 大的。 id 相同，从上往下执行。 select_type 主要用来分辨查询的类型，是普通查询还是联合查询还是子查询    select_type Value  Meaning     SIMPLE  Simple SELECT (not using UNION or subqueries)    PRIMARY  Outermost SELECT    UNION  Second or later SELECT statement in a UNION    DEPENDENT UNION  Second or later SELECT statement in a UNION, dependent on outer query    UNION RESULT  Result of a UNION.    SUBQUERY  First SELECT in subquery    DEPENDENT SUBQUERY  First SELECT in subquery, dependent on outer query    DERIVED  Derived table    UNCACHEABLE SUBQUERY  A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query    UNCACHEABLE UNION  The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)   simple 简单的查询，不包含子查询和union EXPLAIN SELECT  t* FROM  temp; +----+-------------+-------+------+---------------+------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+-------+------+---------------+------+---------+------+------+-------+ | 1 | SIMPLE | emp | ALL | NULL  | NULL | NULL | NULL | 14 |  | +----+-------------+-------+------+---------------+------+---------+------+------+-------+  primary 查询中若包含任何复杂的子查询，最外层查询则被标记为Primary EXPLAIN SELECT  t* FROM  t(SELECT ename, mgr FROM emp) e; +----+-------------+------------+------+---------------+------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+------------+------+---------------+------+---------+------+------+-------+ | 1 | PRIMARY  | &lt;derived2&gt; | ALL | NULL  | NULL | NULL | NULL | 14 |  | | 2 | DERIVED  | emp  | ALL | NULL  | NULL | NULL | NULL | 14 |  | +----+-------------+------------+------+---------------+------+---------+------+------+-------+ union 若第二个或之后的select出现在union之后，则被标记为union sql EXPLAIN SELECT  * FROM  emp WHERE  deptno = 10 UNION  SELECT   *  FROM   emp  WHERE   sal &gt; 2000;  union 先执行 dependent union 跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响  EXPLAIN SELECT  * FROM  emp e WHERE  e.empno IN (   SELECT   empno   FROM   emp   WHERE   deptno = 10   UNION   SELECT    empno   FROM    emp   WHERE    sal &gt; 2000  );   union result 从union表获取结果的select  EXPLAIN SELECT  * FROM  emp WHERE  deptno = 10 UNION  SELECT   *  FROM   emp  WHERE   sal &gt; 2000;   subquery 在select或者where列表中包含子查询  EXPLAIN SELECT  * FROM  emp WHERE  sal &gt; (SELECT avg(sal) FROM emp);   dependent subquery subquery的子查询要受到外部表查询的影响  EXPLAIN SELECT  * FROM  emp WHERE  sal IN (SELECT avg(sal) FROM emp);  该 sql 语句只是把 subquery 的 sql 语句的 &gt; 改成了 IN ，就变成了 dependent subquery。 说实话，没搞懂 MySQL 的判断机制。 但是有一点是确定的，dependent subquery 在执行的时候，会先把整个外部表都查出来，然后再一一的和子查询的所有结果进行匹配。 假设外部表有 m 条数据，子查询的表有 n 条数据。 那么要进行 m * n 次匹配，次数爆炸！ 看到 dependent subquery 一定要想办法改造 sql 语句避开。 DERIVED from子句中出现的子查询，也叫做派生类，  EXPLAIN SELECT  staname,  ename supname FROM  (   SELECT   ename staname,   mgr   FROM   emp  ) t JOIN emp ON t.mgr = emp.empno;   UNCACHEABLE SUBQUERY 表示使用子查询的结果不能被缓存  EXPLAIN SELECT  * FROM  emp WHERE  empno = (   SELECT   empno   FROM   emp   WHERE   deptno =@@sort_buffer_size  );   uncacheable union 表示union的查询结果不能被缓存：sql语句未验证 table 表示对应行正在访问哪一个表，可以是表名或别名，可能是临时表或者 union 合并结果集。  如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名。 表名是 derived N 的形式，表示使用了 id 为 N 的查询产生的衍生表。 当有 union result 的时候，表名是 union n1,n2 等 的形式，n1,n2 表示参与 union 的 id。 type type 表示访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是： system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; all 一般情况下，得保证查询至少达到 range 级别，最好能达到 ref    type  说明     all  全表扫描    index  全索引扫描两种情况1. 当前查询覆盖索引，即需要的数据在索引中。2. 使用了索引进行排序。    range  使用索引查询时限定了范围，避免扫描所有索引。常用的操作符：=&lt;&gt;&gt;&gt;=&lt;&lt;=is nullbetweenlikein    index_subquery  利用索引来关联子查询    unique_subquery  与 index_subquery 类似，使用的是唯一索引    index_merge  在查询过程中多个索引组合使用    ref_or_null  查询某字段时，即查询某具体条件，也查询 null 值    fulltext       ref  使用非唯一性索引进行数据查找    eq_ref  使用唯一索引进行数据查找    const  该查询语句至多有一个匹配行    system  表只有一行记录，等于系统表，是 const 类型的特例   possible_keys 显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。 key 实际使用的索引，如果为 null ，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠. key_len 表示索引中使用的字节数，可以通过 key_len 计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。 ref 显示索引的哪一列被使用了，如果可能的话，是一个常数 explain select * from emp,dept where emp.deptno = dept.deptno and emp.deptno = 10; rows 根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好 explain select * from emp; extra 包含额外的信息。 --using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置 explain select * from emp order by sal; --using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除 explain select ename,count(*) from emp where deptno = 10 group by ename; --using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找 explain select deptno,count(*) from emp group by deptno limit 10; --using where:使用where进行条件过滤 explain select * from t_user where id = 1; --using join buffer:使用连接缓存，情况没有模拟出来 --impossible where：where语句的结果总是false explain select * from emp where empno = 7469; ",
      "url"      : "https://kekaiyuan.github.io//2021/07/11/explain/",
      "keywords" : "MySQL, 执行计划"
    } ,
  
    {
      "title"    : "MySQL 之——锁机制",
      "category" : "MySQL",
      "content": "MySQL 之——锁机制 layout: post title: MySQL 之——锁机制 categories: MySQL description: MySQL 之——锁机制 keywords: MySQL, 锁 MySQL 之——锁机制 基本介绍 锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。 如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。 从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。 相对其他数据库而言，MySQL的锁机制比较简单。 其最显著的特点是不同的存储引擎支持不同的锁机制。  MyISAM 和 MEMORY   表级锁（table-level locking）  行级锁（row-level locking）   InnoDB   表级锁（table-level locking）  行级锁（row-level locking）   默认使用行级锁        开销  加锁速度  死锁  粒度  发生锁冲突的概率  并发度     表级锁  小  快  不会  大  高  低    行级锁  大  慢  会  小  低  高   锁没有优劣之分，要根据业务场景选择合适的锁：  表级锁 适合以查询为主，只有少量按索引条件更新数据的应用。 如 Web 应用。 行级锁 适合有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。 如在线事务处理（OLTP）系统：银行。 MyISAM 表锁 MySQL的表级锁有两种模式： 表共享读锁（Table Read Lock） 表独占写锁（Table Write Lock） 对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！ 建表语句： CREATE TABLE `mylock` ( `id` int(11) NOT NULL AUTO_INCREMENT, `NAME` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8; INSERT INTO `mylock` (`id`, `NAME`) VALUES ('1', 'a'); INSERT INTO `mylock` (`id`, `NAME`) VALUES ('2', 'b'); INSERT INTO `mylock` (`id`, `NAME`) VALUES ('3', 'c'); INSERT INTO `mylock` (`id`, `NAME`) VALUES ('4', 'd'); MyISAM写锁阻塞读的案例： ​ t t当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。       session1  session2              获取表的write锁定lock table mylock write;                当前session对表的查询，插入，更新操作都可以执行select * from mylock;insert into mylock values(5,’e’);  当前session对表的查询会被阻塞select * from mylock；             释放锁：unlock tables；  当前session能够立刻执行，并返回对应结果         MyISAM读阻塞写的案例： ​ t t一个session使用lock table给表加读锁，这个session可以锁定表中的记录，但更新和访问其他表都会提示错误，同时，另一个session可以查询表中的记录，但更新就会出现锁等待。    时刻  session1  说明  session2        T1  lock table mylock read;  上锁          T2  select * from mylock;  执行成功可以查询  select * from mylock;  执行成功可以查询       select * from person;  执行失败该 session 不能查询未上锁的表  select * from mylockinsert into person values(1,’zhangsan’);  该 session 可以查询或者更新未锁定的表       insert into mylock values(6,’f’);update mylock set name=’aa’ where id = 1;  当前session插入或者更新表会提示错误  insert into mylock values(6,’f’);  阻塞等待锁的释放    T3  unlock tables;  释放锁     获得锁，更新立刻执行        写锁  读锁     上锁线程  可读可写。无法访问其他表。  可读不可写。无法访问其他表。    其他线程  不可读写。可以访问其他表。  可读不可写。可以访问其他表。   注意: MyISAM在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁，上例中的加锁时为了演示效果。 MyISAM的并发插入问题 MyISAM表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM也支持查询和插入操作的并发执行 MyISAM表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM也支持查询和插入操作的并发执行 MyISAM存储引擎有一个系统变量 concurrent_insert ，专门用来控制并发插入的行为，值分别为 0，1，2  值为 0 时 不允许并发插入   值为 1 时 如果表中间没有被删除的行（空洞），MyISAM允许一个进程读表的同时，另一个进程从表尾插入记录   值为 2 时 无论表中有没有空洞，都允许在表尾并发插入记录    session1  session2     获取表的read local锁定lock table mylock read local       当前session不能对表进行更新或者插入操作insert into mylock values(6,’f’)Table ‘mylock’ was locked with a READ lock and can’t be updatedupdate mylock set name=’aa’ where id = 1;Table ‘mylock’ was locked with a READ lock and can’t be updated  其他session可以查询该表的记录select* from mylock    当前session不能查询没有锁定的表select * from personTable ‘person’ was not locked with LOCK TABLES  其他session可以进行插入操作，但是更新会阻塞update mylock set name = ‘aa’ where id = 1;    当前session不能访问其他session插入的记录；       释放锁资源：unlock tables  当前session获取锁，更新操作完成    当前session可以查看其他session插入的记录      可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺： mysql&gt; show status like 'table%'; +-----------------------+-------+ | Variable_name  | Value | +-----------------------+-------+ | Table_locks_immediate | 352 | | Table_locks_waited | 2  | +-----------------------+-------+ --如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。 InnoDB 锁 事务及其ACID属性 事务是由一组SQL语句组成的逻辑处理单元，事务具有 4 g个属性，通常称为事务的 ACID 属性。  原子性 Actomicity 事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。   一致性 Consistent 在事务开始和完成时，数据都必须保持一致状态。   隔离性 Isolation 数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。   持久性 Durable 事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。 并发事务带来的问题 相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户的并发操作，但与此同时，会带来一下问题： 脏读： 一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读” 不可重复读：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。 幻读： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读” 上述出现的问题都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证。 数据库的事务隔离越严格，并发副作用就越小，但付出的代价也就越大，因为事务隔离本质上就是使事务在一定程度上串行化，需要根据具体的业务需求来决定使用哪种隔离级别       脏读  不可重复读  幻读     read uncommitted  √  √  √    read committed     √  √    repeatable read        √    serializable            默认 repeatable read 可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况： mysql&gt; show status like 'innodb_row_lock%'; +-------------------------------+-------+ | Variable_name    | Value | +-------------------------------+-------+ | Innodb_row_lock_current_waits | 0  | | Innodb_row_lock_time  | 18702 | | Innodb_row_lock_time_avg | 18702 | | Innodb_row_lock_time_max | 18702 | | Innodb_row_lock_waits  | 1  | +-------------------------------+-------+ --如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高 InnoDB 的行锁 InnoDB 一共有两种行锁：  共享锁（简称 S 锁） 又称读锁。   排他锁（简称 X 锁） 又称写锁。 共享锁 / 读锁 / S锁 共享锁（简称 S 锁），又称读锁。 允许一个事务去读一行， mysql InnoDB引擎默认的修改数据语句：update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型， 注意： 有很多说法都说事务 T 给数据对象 A 上了 S 锁后，则事务 T 只能读 A 不能修改 A 。 经过测试，该说法是错误的。 共享锁： 只允许读，不允许写。 允许其他事务上共享锁，不允许上排他锁。 因为排他锁会覆盖共享锁。 ​ t t共享锁（s）：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 ​ t t排他锁（x）：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。 ​ t tmysql InnoDB引擎默认的修改数据语句：update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。所以加过排他锁的数据行在其他事务中是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。 InnoDB行锁实现方式 ​ t tInnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 1、在不通过索引条件查询的时候，innodb使用的是表锁而不是行锁 CREATE TABLE test (id INT, NAME VARCHAR(10)) ENGINE = INNODB; ALTER TABLE test ADD INDEX index_id (id); INSERT INTO test VALUES  t(1, '1'),  t(2, '2'),  t(3, '3'),  t(4, '4'),  t(4, '5'); 打开两个 MySQL 命令行，分别为 session 1 和 session 2    时刻  session1  说明  session2  说明     T1  set autocommit=0;  关闭自动提交  set autocommit=0;  关闭自动提交    T2  select * from tab_no_index where id = 1 for update;  成功          T3        select * from tab_no_index where id = 2 for update;  成功    T4  commit;  提交事务  commit;  提交事务    T5  select * from tab_no_index where name = ‘1’ for update;  成功          T6        select * from tab_no_index where name = ‘2’ for update;  阻塞，超时后失败    T7        select * from tab_no_index where id = 1 for update;  阻塞，超时后失败   id 是主键，默认会生成主键索引。 T2 时刻 session 1 加的是行锁，所以 T3 时刻 session 2 可以给其他行加行锁。 而 name 不是索引。 T5 时刻 session 1 加的是表锁，所以 T6 和 T7 时刻 session 2 无法再给该表加锁。 2、创建带索引的表进行条件查询，innodb使用的是行锁 create table tab_with_index(id int,name varchar(10)) engine=innodb; alter table `tab_with_index` add index id(`id`); insert into tab_with_index values(1,'1'),(2,'2'),(3,'3'),(4,'4');   session1  session2     set autocommit=0select * from tab_with_indexwhere id = 1;  set autocommit=0select * from tab_with_indexwhere id =2    select * from tab_with_index where id = 1 for update;          select * from tab_with_index where id = 2 for update;   3、由于mysql的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是依然无法访问到具体的数据 alter table tab_with_index drop index id; insert into tab_with_index values(1,'4');   session1  session2     set autocommit=0  set autocommit=0    select * from tab_with_index where id = 1 and name=’1’ for update          select * from tab_with_index where id = 1 and name=’4’ for update;虽然session2访问的是和session1不同的记录，但是因为使用了相同的索引，所以需要等待锁   总结 对于MyISAM的表锁，主要讨论了以下几点： （1）共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。 （2）在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。 （3）MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。 （4）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。 对于InnoDB表，本文主要讨论了以下几项内容： （1）InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。 （2）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。 在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：  尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会； 选择合理的事务大小，小事务发生锁冲突的几率也更小； 给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁； 不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会； 尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁； 对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/12/lock/",
      "keywords" : "MySQL, 锁"
    } ,
  
    {
      "title"    : "Java 多线程与高并发之—— volatile 关键字",
      "category" : "Java",
      "content": "Java 多线程与高并发之—— volatile 关键字 序言 在定义某个类的成员变量时，我们可以使用 volatile 关键字来修饰该变量。 这个关键字在平时用不到，只有在多线程时才会用到。 它的作用有两个： 保证线程可见性 禁止指令重排 保证线程可见性 现代计算机的内存模型 首先要了解的是现代计算机的内存模型 graph BT; A[主内存] --- B[缓存一致性协议] B --- C1[高速缓存] B --- C2[高速缓存] B --- C3[高速缓存] C1 --- D1[处理器] C2 --- D2[处理器] C3 --- D3[处理器] 在计算机的早期时代，因为 CPU 的运行速度和内存的读写速度相差无几。 所以当时是没有高速缓存的。 CPU 直接从内存读取数据，进行计算，返回结果给内存。 但随着技术的发展，CPU 的速度越来越快，但是内存读写速度的发展却陷入了瓶颈。 两者之间出现了几个数量级的差距。 于是不得不加入了读写速度能够与 CPU 匹配的高速缓存： 将运算需要使用到的数据复制到缓存中，让运算能快速进行。 当运算结束后再将数据从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 但此时又有了新的问题： 假如多个处理器从内存中取走了同一份数据，再经过各自的计算后，哪份数据才是真正需要写回内存的哪份？ 于是提出了缓存一致性协议，用于同步多个缓存之间的数据。 JMM 根据现代计算机的内存模型，Java 也提出了相似的内存模型（简称 JMM—— Java Memory Model）。 graph BT; A[主内存] --- B[Save 和 Load 操作] B --- C1[工作内存] B --- C2[工作内存] B --- C3[工作内存] C1 --- D1[Java 线程] C2 --- D2[Java 线程] C3 --- D3[Java 线程] Java 内存模型规定了以下几点： 所有的变量都存储在主内存中。 每条线程都有自己的工作内存，保存了主内存中的数据拷贝。 线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。 线程间传递变量值需要在主内存中完成。 线程可见性 当线程修改了其工作内存的数据后，需要使得其他线程能够看到该数据，这就是线程可见性。 在一般情况下，线程间是不可见的。 需要通过某些方法，强制触发该读写流程： 写：  改变工作内存中拷贝副本的值。  将改变后的副本同步回主内存。   读：  从主内存中拷贝最新的变量到副本中。  读取工作内存中副本的值。   请注意： volatile 不是实现线程可见性的唯一方法。 只要能够触发该流程，就能实现线程间可见。 案例 现有一个小程序 public class T01_VolatileTest {  boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别  void m() {  System.out.println(m start);  while(running) {  }  System.out.println(m end!);  } public static void main(String[] args) throws InterruptedException {  T01_VolatileTest t = new T01_VolatileTest();  new Thread(t::m, t1).start();  //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中  Thread.sleep(1000);  t.running = false;  } } 该程序很简单。 启动一个线程，当 running = false 时死循环，当 running = ture 时结束线程。 结果 m start 并且该程序不会结束，一直处于运行状态。 说明程序陷入了死循环。 这就是线程间不可见： 线程 t 一开始从主内存中复制的变量是 running = true。 主线程先等待 1s，确保线程 t 复制的是 running = true 。 然后将 running 改为 false。 但是线程 t 中的 running 并没有修改，所以线程 t 陷入了死循环。 解决办法 volatile 关键字 使用 volatile 关键字修饰共享变量 public class T01_VolatileTest {  volatile boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别  void m() {  System.out.println(m start);  while(running) {  }  System.out.println(m end!);  } public static void main(String[] args) throws InterruptedException {  T01_VolatileTest t = new T01_VolatileTest();  new Thread(t::m, t1).start();  //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中  Thread.sleep(1000);  t t//修改 running 的值，尝试让线程 t 停下来  t.running = false;  } } 结果 m start m end! synchronized 关键字 synchronized 关键字也是能够保证线程可见性的。 public class T01_VolatileTest {  boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别  void m() {  System.out.println(m start);  while(running){  t t tsynchronized(this){  t t t}  }  System.out.println(m end!);  } public static void main(String[] args) throws InterruptedException {  T01_VolatileTest t = new T01_VolatileTest();  new Thread(t::m, t1).start();  //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中  Thread.sleep(1000);  t t//修改 running 的值，尝试让线程 t 停下来  t.running = false;  } } 结果 m start m end! Thread.sleep() 如果调用了 Thread.sleep() 方法，那么 JVM 会利用线程睡眠的这段时间进行数据的同步。 public class T01_VolatileTest {  boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别  void m() {  System.out.println(m start);  while(running) {   try {    Thread.sleep(1);   } catch (InterruptedException e) {    e.printStackTrace();   }  }  System.out.println(m end!);  } public static void main(String[] args) throws InterruptedException {  T01_VolatileTest t = new T01_VolatileTest();  new Thread(t::m, t1).start();  //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中  Thread.sleep(1000);  t t//修改 running 的值，尝试让线程 t 停下来  t.running = false;  } } 结果 m start m end! System.out.println() 如果线程调用了 System.out.println() 方法，无论输出的是什么，JVM 都会进行数据同步。 public class T01_VolatileTest {  boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别  void m() {  System.out.println(m start);  while(running) {  t t tSystem.out.println(666);  }  System.out.println(m end!);  } public static void main(String[] args) throws InterruptedException {  T01_VolatileTest t = new T01_VolatileTest();  new Thread(t::m, t1).start();  //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中  Thread.sleep(1000);  t t//修改 running 的值，尝试让线程 t 停下来  t.running = false;  } } 结果 m start 666 ……（省略 10000 个 666） 666 m end! 总结 要实现线程间可见很简单，只要强制性地让 JVM 实现数据的同步就可以了。 方法有很多，笔者找到了这四种，但应该还有很多方法能触发线程间可见。 禁用指令重排 在单例模式中，双检锁（DCL—— Double Check Lock）式的单例模式必须使用 volatile 关键字。 双检锁式单例模式 public class Mgr06 {  t//使用volatile关键字，防止JVM内部语句重排后，没有初始化就返回INSTANCE  private static volatile Mgr06 INSTANCE; private Mgr06(){} public static Mgr06 getInstance() {  if(INSTANCE == null){   //双重检查   synchronized (Mgr06.class){    if(INSTANCE == null){    INSTANCE = new Mgr06();    }   }  }  return INSTANCE;  } } 指令重排： INSTANCE = new Mgr06(); 在 Java 中是一句话，但是翻译成汇编语言会变成三条语句： 申请内存 初始化成员变量 让 INSTANCE 指向这块内存 为了提高性能，系统会对指令进行重排序。 所以有时会把指令重排为以下顺序： 申请内存 让 INSTANCE 指向这块内存 初始化成员变量 即第二条指令和第三条指令互换。 然后考虑一个非常非常神奇的巧合： 线程 1 访问该单例，发现没有创建单例，于是在该线程中，执行创建单例的操作。 系统将 INSTANCE = new Mgr06(); 的指令重排了。 于是线程 1 先申请了内存，将 INSTANCE 指向了该内存。 在线程 1 初始化成员变量前，线程切换了，切换的线程 2 也要使用该单例模式。 线程 2 发现 INSTANCE 不是 null ，因为它已经指向了某块内存。 于是线程 2 开始直接使用 INSTANCE 。 但 INSTANCE 的成员变量没有初始化，此时它们都是默认值（例如 int 类型的变量默认值是 0 ）。  所以线程 2 使用 INSTANCE 执行了一系列奇奇怪怪的操作，程序出错。 这是一个极难复现的 BUG，要在百万级别的并发下才会偶尔出现。 volatile 与引用类型的二三事 笔者在写这篇博文的时候，看到了网上有很多人写了这样一句话： volatile 修饰引用类型时，只能保证引用类型本身是线程间可见的，但是其内部字段是线程间不可见。 换句话说，如果我有一个被 volatile 修饰的引用类型的变量（数组或对象）。 如果我把这个变量本身（即地址）改变了，这个改变是线程间可见的。 如果我把这个变量内部的值改变了（数组的内容，对象的成员变量），这个改变是线程间不可见的。 但是笔者仔细研究后发现，这句话并不对。 线程的工作内存到底存了什么东西 首先，提个问题：线程的工作内存中，到底存了什么？  假设一：存的是引用类型本身（即地址）。 但是如果存的是地址，说明我要访问该引用类型的内部字段都必须去主内存中找，为什么会出现内部字段线程间不可见呢？ 假设二：存的是引用类型的所有内容（包含内部字段）。 如果是这样的话，我现在有一个很大的对象（假设为 20 MB）。 有 1000 个线程在同时访问这个对象，那么每个线程都需要花 20MB 来存储这个对象。 总和就是 20GB ，这可能吗？ 无论哪种假设，都不合理。 最终笔者在《深入理解Java虚拟机（第二版）》中找到了答案： 线程的工作内存中拷贝了对象的引用，和对象中正在访问的字段，对象中其他没有访问到的字段不会拷贝。 既然是正在访问的字段，这也就说明当一段时间不访问该字段后，其拷贝会从线程的工作内存中删除。 这很好理解： 线程的数量太多了，而引用类型的变量又往往比较大。 如果不清空那些不常用的内部字段，会严重占用内存。 测试 1 ：数组 public class T02_VolatileReference1 {  boolean[] running = new boolean[]{true}; void m() {  System.out.println(m start);  while (running[0]) {  }  System.out.println(m end!);  } public static void main(String[] args) throws InterruptedException {  T02_VolatileReference1 t = new T02_VolatileReference1();  new Thread(t::m, t1).start();  Thread.sleep(1000);  t.running[0] = false;  } } 该程序很简单，running 是一个引用类型，是一个 boolean 型的数组。 running[0] 的初始值是 false，所以线程 t 在启动后会死循环。 隔 1000ms 后，在主线程中修改线程 t 的 running[0] 为 false。 查看线程 t 是否会结束死循环。 结果：死循环 m start 测试 2：对象 public class T03_VolatileReference2 {  Test test = new Test(); static class Test {  boolean running = true;  } void m(){  System.out.println(m start);  while(test.running){  }  System.out.println(m end);  } public static void main(String[] args) throws InterruptedException {  T03_VolatileReference2 t = new T03_VolatileReference2();  new Thread(t::m).start();  Thread.sleep(1000);  t.test.running=false;  } } 与测试 1 同理，只是将数组改为对象。 结果：死循环 m start 结论： 线程的工作内存会拷贝应用类型的正在访问的字段。 volatile 修饰的引用类型 volatile 的工作原理是什么？ 通俗来讲： volatile 变量在每次被线程访问时，都强迫从主内存中重读该变量的值。 而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。 这样任何时刻，不同的线程总能看到该变量的最新值。 线程写 volatile 变量的过程： 改变线程工作内存中 volatile 变量副本的值。 将改变后的副本从工作内存刷新到主内存。 线程读 volatile 变量过程： 从主内存读取 volatile 变量的最新值到线程工作内存中。 从工作内存读取 volatile 变量的副本。 那么 volatile 修饰的引用类型变量的内部字段的读写过程是什么样的呢？ volatile 修饰数组 public class T02_VolatileReference1 {  volatile boolean[] running = new boolean[]{true}; void m() {  System.out.println(m start);  while (running[0]) {  }  System.out.println(m end!);  } public static void main(String[] args) throws InterruptedException {  T02_VolatileReference1 t = new T02_VolatileReference1();  new Thread(t::m, t1).start();  Thread.sleep(1000);  t.running[0] = false;  } } 结果 m start m end! volatile 修饰对象 public class T02_VolatileReference2 {  volatile Test test = new Test(); void m() {  System.out.println(m start);  while (test.running) {  }  System.out.println(m end);  } public static void main(String[] args) throws InterruptedException {  T02_VolatileReference2 t = new T02_VolatileReference2();  new Thread(t::m).start();  Thread.sleep(1000);  t.test.running = false;  } } class Test {  boolean running = true; } 结果 m start m end! 这说明 volatile 修饰的引用类型其内部字段是线程间可见的！ 那么网上流传的 volatile 修饰的引用类型内部字段线程间不可见的说法是哪来的呢？ 请看以下代码： public class T03_VolatileReference1 {  volatile boolean[] running = new boolean[]{true}; void m() {  System.out.println(m start);  boolean[] running2 = running;  while (running2[0]) {  }  System.out.println(m end!);  } public static void main(String[] args) throws InterruptedException {  T03_VolatileReference1 t = new T03_VolatileReference1();  new Thread(t::m, t1).start();  Thread.sleep(1000);  t.running[0] = false;  } } 我们创建一个 running2 ，它与 running 是相同的，但是没有被 volatile 修饰。 结果：死循环 m start  结论： 结合以上 volatile 的工作原理和测试，我们可以得到以下结论： volatile 像一个标志，告诉我们的程序，看到这个标志，必须去主内存中读写。 所以当使用 volatile 修饰引用类型时，程序依然会去主内存中读写，所以内部字段是线程间可见的。 重点是在读的时候，也必须通过被 volatile 修饰的变量去读，而不能使用非 volatile 变量去读。 就像我们的测试： volatile boolean[] running = new boolean[]{true}; 被 volatile 修饰的是 running ，所以读写时都应该用 running。 boolean[] running2 = running; 而 running2 不是被 volatile 修饰的，尽管 running2 和 running 本身的值是一样的。 但是使用 running2 读写内部字段就是线程间不可见的。 通过基本类型验证该结论： public class T03_VolatileReference2 {  volatile boolean running = true; void m() {  System.out.println(m start);  boolean running2 = running;  while (running2) {  }  System.out.println(m end!);  } public static void main(String[] args) throws InterruptedException {  T03_VolatileReference2 t = new T03_VolatileReference2();  new Thread(t::m, t1).start();  Thread.sleep(1000);  t.running = false;  } } 结果：死循环 m start 完美验证该结论！ volatile 不能保证原子性 volatile 实现了线程可见性，使得多线程的数据能够同步，但是它并不能保证原子性。 什么是原子性？ 简单来说：保证指令序列是一体的，要么全部执行，要么全部不执行，不会发生执行到一半被打断的情况。 在 Java 中， synchronized 关键字不仅能保证线程间可见，还能保证原子性。 测试： public class T04_VolatileNotSync {  volatile int count = 0; void m() {  for (int i = 0; i &lt; 10000; i++) {  t t tcount++;  t t}  } public static void main(String[] args) throws InterruptedException {  T04_VolatileNotSync t = new T04_VolatileNotSync();  for (int i = 0; i &lt; 10; i++) {   new Thread(t::m).start();  }  //等待线程结束  Thread.sleep(3000);  System.out.println(t.count);  } } 该程序的目的是创建 10 个线程，每个线程在 count 上执行 10000 次 ++ 操作 预期输出是 count = 100000 在使用 volatile 的情况下，实际输出是多少？ 结果 26930 该结果不是个例，笔者测试过很多次，结果基本不会超过 30000 。 这是为什么？ 因为 volatile 关键字不能保证原子性。 假设某一时刻 count = 10 ，共有两个线程    时刻  Thread 1  Thread 2     T1  读取到 count = 10  等待 CPU    T2  让出 CPU  获得 CPU ，开始执行操作。读取到 count = 10    T3  等待CPU  将 count = 11 写回 内存    T4  获得 CPU ，继续执行操作。将 count = 11 写回内存  等待操作   可以看到，一共执行了两次自增操作，但写回内存的结果却只有一次。 在程序执行过程中发生的数据冲突不只这一种，但是导致的结果是一样的：数据不安全。 如果要保证数据安全，需要使用 synchronized 关键字。 public class T05_VolatileVsSync {  int count = 0; synchronized void m() {  t tfor (int i = 0; i &lt; 10000; i++){  t t tcount++;  t t}  } public static void main(String[] args) throws InterruptedException {  T05_VolatileVsSync t = new T05_VolatileVsSync();  for (int i = 0; i &lt; 10; i++) {   new Thread(t::m).start();  }  //等待线程结束  Thread.sleep(3000);  System.out.println(t.count);  } } 结果 100000 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/16/volatile/",
      "keywords" : "Java, volatile"
    } ,
  
    {
      "title"    : "Java 多线程与高并发之—— JUC",
      "category" : "Java",
      "content": "JUC 是 java.util.concurrent 的简称，是 JDK 1.5 诞生的一个工具包，专门用于处理线程。 ReentrantLock ReentrantLock 的字面意思是可重入锁，即某个线程获得锁后，再次获取该锁时不会陷入死锁状态。 ReentrantLock 可以视为 synchronized 的优化版。 ReentrantLock 的优点 首先要注意的是 ReentrantLock 上锁之后必须显式地调用 unlock() 方法释放锁，而 synchronized 不需要。 可设置为公平锁 synchronized 只能是非公平锁，而 ReentrantLock 默认情况下是非公平锁，但是可以设置为公平锁。 非公平锁  ReentrantLock lock = new ReentrantLock();  ReentrantLock lock = new ReentrantLock(false);   公平锁  ReentrantLock lock = new ReentrantLock(true);   加锁方法更多样，更灵活 ReentrantLock 共有三种方法加锁 lock() 普通加锁 tryLock() 非阻塞加锁 lockInterruptibly() 可响应外部中断的加锁 lock() 方法 普通上锁 public class ReentrantLockTest {  tLock lock = new ReentrantLock();  tpublic void lock01(){  t ttry {  t t tlock.lock(); //上锁  t t t...//业务逻辑  t t} catch (Exception e) {  t t te.printStackTrace();  t t} finally {  t t tlock.unlock();  t t}  t} } trylock() 方法 可使用 tryLock 方法尝试获得锁，无论是否成功获得锁，都能够继续往下执行，这使得程序更灵活多变。 tryLock 方法共有两种形参列表： tryLock() 尝试获得锁，直接返回结果。 tryLock( long timeout, TimeUnit unit) 尝试获得锁，可设置最长尝试时间。 public class ReentrantLockTest {  tLock lock = new ReentrantLock();  tpublic void method(){  t tboolean locked = false;  t ttry {  t t t//locked = lock.tryLock();  t t tlocked = lock.tryLock(5, TimeUnit.SECONDS);  t t tif (locked) {  t t t tSystem.out.println(获得锁成功);  t t t t...//成功代码  t t t} else {  t t t tSystem.out.println(获得锁失败);  t t t t...//失败代码  t t t}  t t} catch (InterruptedException e) {  t t te.printStackTrace();  t t} finally {  t t tif (locked) {  t t t tlock.unlock();  t t t}  t t}  t} } 尝试获得锁，最长尝试时间为 5s 。 其返回值是一个 boolean 值，根据该值决定接下来的执行逻辑。 可响应外部消息 synchronized 在执行的时候是无法响应外部消息，所以如果某个线程在获得锁后陷入了死循环，那么所有其他线程都会被阻塞。 public static void main(String[] args) throws InterruptedException {  tRunnable runnable = new Runnable() {  t t@Override  t tpublic void run() {  t t tsynchronized (this) {  t t t tSystem.out.println(Thread.currentThread().getName() + start);  t t t ttry {  t t t t tThread.sleep(Integer.MAX_VALUE);  t t t t} catch (InterruptedException e) {  t t t t te.printStackTrace();  t t t t}  t t t}  t t}  t};  tnew Thread(runnable, t1).start();  tnew Thread(runnable, t2).start(); } 结果 t1 start 因为 t1 拿到了锁以后进行了无限期的睡眠，所以 t2 永远拿不到锁。 并且没有办法打断 t1 线程的运行。 但是 ReentrantLock 可以解决这个问题。 使用 lockInterruptibly() 方法加锁，该方法会响应外部的 interrupt() 方法 public class ReentrantLockTest {  Lock lock = new ReentrantLock(); /** * 可响应外部中断上锁 lockInterruptibly() */  /** * 可响应外部中断上锁 lockInterruptibly() */  public void lock03() throws InterruptedException {  Runnable runnable = () -&gt; {   try {    lock.lockInterruptibly();    System.out.println(Thread.currentThread().getName() + start);    Thread.sleep(Integer.MAX_VALUE);    System.out.println(Thread.currentThread().getName() + end);   } catch (InterruptedException e) {    System.out.println(Thread.currentThread().getName() + interrupted!);   } finally {    lock.unlock();   }  };  Thread t1 = new Thread(runnable);  t1.start();  Thread t2 = new Thread(runnable);  t2.start();  Thread.sleep(5000);  t1.interrupt(); //打断线程 1 的等待  Thread.sleep(5000);  t2.interrupt(); //打断线程 2 的等待  }  tpublic static void main(String[] args) throws InterruptedException {  ReentrantLockTest reentrantLockTest = new ReentrantLockTest();  reentrantLockTest.lock03();  } } 结果 Thread-0 start Thread-0 interrupted! Thread-1 start Thread-1 interrupted! 该程序 t1 线程使用 lockInterruptibly() 方法上锁，然后陷入无限期的睡眠。 然后创建 t2 线程，因为 t1 线程不释放锁，所以 t2 线程无法运行。 在等待 5s 后，调用 t1.interrupt(); 打断 t1 线程： t1 线程会捕获到 InterruptedException 异常 t1 线程执行 catch 代码块，输出异常信息 t1 线程执行 finally 代码块，释放锁 于是 t2 线程拿到了锁，开始执行。 同样的，在 5s 后使用 t2.interrupt(); 打断 t2 线程的运行。 可关联多个条件 在 synchronized 中，可以使用 lock() 方法阻塞线程，并且使用 notify() 方法和 notifyAll() 方法线程。 notify() 方法只能随机唤醒一个阻塞线程 notifyAll() 方法会唤醒所有阻塞线程 这样的方式不够灵活，于是有了 Condition 变量。 使用 Condition condition = reentrantLock.newCondition() 创建对象 在线程中使用 condition.await() 方法阻塞线程 使用 condition.signal() 或 condition.signalAll() 方法唤醒线程 一个 ReentrantLock 对象可以创建多个 Condition 变量。 使用 Condition 唤醒的线程只会是使用该变量阻塞的线程。 这样就做到了在 ReentrantLock 对象创建了多个子队列，可以实现更灵活的功能。 注意： Condition 变量的操作必须搭配对应的 ReentrantLock 对象的 lock() 方法和 unlock() 方法使用。 例子： public class ReentrantLockTest {  Lock lock = new ReentrantLock(); /** * 实现 Condition 变量实现线程同步 */  public void condition() throws InterruptedException {  Condition condition1 = lock.newCondition();  Condition condition2 = lock.newCondition();  Runnable runnable1 = () -&gt; {   lock.lock();   try {    condition1.await();   } catch (InterruptedException e) {    e.printStackTrace();   } finally {    lock.unlock();   }   System.out.println(Thread.currentThread().getName());  };  Runnable runnable2 = () -&gt; {   lock.lock();   try {    condition2.await();   } catch (InterruptedException e) {    e.printStackTrace();   } finally {    lock.unlock();   }   System.out.println(Thread.currentThread().getName());  };  for (int i = 0; i &lt; 5; i++) {   new Thread(runnable1, t1- + i).start();   new Thread(runnable2, t2- + i).start();  }  Thread.sleep(1000);  lock.lock();  condition1.signalAll();  lock.unlock();  } public static void main(String[] args) throws InterruptedException {  ReentrantLockTest reentrantLockTest = new ReentrantLockTest();  reentrantLockTest.condition();  } } 结果 t1-0 t1-2 t1-4 t1-3 t1-1 t1 线程使用的是 condition1，t2 线程使用的是 condition2。 使用 condition1.notifyAll() 只唤醒了 t1 线程，并没有唤醒 t2 线程。 注意 synchronized 也是可重入锁。 ReentrantLock 和 synchronized 可重入的底层实现相同，都是通过一个计数器来实现。  一开始计数器 = 0  线程 A 加锁，记录线程 ID，计数器 ++  线程 A 退出后再次加锁，线程 ID 相同，计数器 ++  线程 B 加锁，计数器 != 0，线程 ID 不符合，加锁失败  线程 A 结束运行，连续释放两次锁，把计数器置为0  线程 B 加锁，计数器 = 0，成功   synchronized 会自动释放锁，但是 ReentrantLock 需要注意显式调用 unlock() 方法释放锁。 CountDownLatch 如果我们想要所有线程结束再继续执行主线程应该怎么做？ 一般地可以使用 join() public class T06_TestCountDownLatch {  private static int num = 10; private static void usingJoin() throws InterruptedException {  Thread[] threads = new Thread[num];  for(int i=0; i&lt;num; i++) {   threads[i] = new Thread(()-&gt;{    try {    Thread.sleep(1000);    } catch (InterruptedException e) {    e.printStackTrace();    }    System.out.println(Thread.currentThread().getName()+ end!);   },t+i);  }  for (Thread thread : threads) {   thread.start();  }  for (Thread thread : threads) {   thread.join();  }  System.out.println(all threads end);  } public static void main(String[] args) throws InterruptedException {  usingJoin();  } } 即在主线程遍历所有的线程并调用 join() 方法 结果 t7 end! t1 end! t6 end! t0 end! t9 end! t8 end! t2 end! t3 end! t5 end! t4 end! all threads end  但是在 JUC 中，有专门的类实现该功能：CountDownLatch 类 public class T06_TestCountDownLatch {  private static int num = 10; private static void usingCountDownLatch() throws InterruptedException {  CountDownLatch latch = new CountDownLatch(num);  for (int i = 0; i &lt; num; i++) {   new Thread(() -&gt; {    try {    Thread.sleep(1000);    } catch (InterruptedException e) {    e.printStackTrace();    } finally {    System.out.println(Thread.currentThread().getName() + end!);    latch.countDown();    }   }, t + i).start();  }  latch.await();  System.out.println(all threads end);  } public static void main(String[] args) throws InterruptedException {  usingCountDownLatch();  } } CountDownLatch 类似于一个倒数器，创建实例时指定初值。 在每个线程的结束部分（有异常时写在 finally 代码块中）调用 latch.countDown() 方法，计数 -1 。 在主线程中调用 latch.await() 方法，此时会阻塞，等待所有线程都调用了 latch.countDown() 方法，使得倒数器中的数为 0 。 简而言之，这就是一个倒数的过程。 每结束一个线程 -1 ，不停地倒数，直到为 0 ，继续执行。 结果 t1 end! t9 end! t8 end! t6 end! t4 end! t5 end! t0 end! t7 end! t2 end! t3 end! all threads end CyclicBarrier 先翻译一下类名：循环栅栏。 通过类名来感受这个类的作用： 现在有一个栅栏，把线程们的路拦住了。 线程到达栅栏后会被阻塞，无法继续前行。 当栅栏前等待的线程达到一定数量后，栅栏会打开，所有线程继续运行。 栅栏重新开闭，开启新一轮的循环。 从效果上来说， CountDownLatch 和 CyclicBarrier 都是用于线程同步的。 只不过一个是一次性的，一个是循环使用的。 案例： public class T07_TestCyclicBarrier {  public static void main(String[] args) {  CyclicBarrier barrier = new CyclicBarrier(20, () -&gt; {   System.out.println(已满 20，发车！);  });  for (int i = 0; i &lt; 100; i++) {   new Thread(() -&gt; {    try {    barrier.await();    } catch (InterruptedException e) {    e.printStackTrace();    } catch (BrokenBarrierException e) {    e.printStackTrace();    }   }).start();  }  } } Cyclic 有两个构造方法： CyclicBarrier(int parties) CyclicBarrier(int parties, Runnable barrierAction) 第一个参数是栅栏的大小——当等待线程的数量达到多少时开放栅栏。 第二个参数可选——栅栏开启时是否需要执行某些操作。 在本案例中，共有 100 个线程，栅栏大小为 20 ，开启栅栏时会打印一句话：“已满 20，发车！” 所以运行结果为： 已满 20，发车！ 已满 20，发车！ 已满 20，发车！ 已满 20，发车！ 已满 20，发车！ CyclicBarrier 用于同步多个线程的执行流程： 即某线程不能独自往前推进，它必须等待其他线程的运行结果。 使用方法： 在需要等待的地方调用 barrier.await(); Phaser CyclicBarrier 是循环栅栏，只有一道栅栏，通过栅栏的线程不会再被阻塞。 但如果需要使用多栅栏模式，线程们会先在第一道栅栏前集合，再在第二道栅栏前集合…… 从现实生活中考虑，集体活动是不是如此？ 现有一集体活动： graph LR; A[在某地点集合] --&gt; B[吃饭] B --&gt; C[大保健] C --&gt; D[喝酒] D --&gt; E[解散] 每个人都是一个线程，各自运行。 所有人必须一起行动。 不能发生其他人还在吃饭，有一个人已经所有事都做完回家的情况发生。 使用 Phaser 类实现该情景： public class T08_TestPhaser1 {  static Phaser phaser = new PartyPhaser();  static int num = 3; public static void main(String[] args) {  //注册数量  phaser.bulkRegister(num);  for (int i = 1; i &lt;= num; i++) {   new Thread(new Person(), p + i).start();  } } static class PartyPhaser extends Phaser {  /*  返回值 false 代表 phaser 未结束  返回值 true 代表 phaser 结束  */  @Override  protected boolean onAdvance(int phase, int registeredParties) {   switch (phase) {    case 0:    System.out.println(num + 人到齐，开饭！  );    return false;    case 1:    System.out.println(num + 人吃完，去做大保健！  );    return false;    case 2:    System.out.println(num + 人做完大保健，去喝酒！  );    return false;    case 3:    System.out.println(num + 人喝完酒，聚会结束！  );    return true;    default:    return true;   }  }  } static class Person implements Runnable {  public void arrive() {   System.out.println(Thread.currentThread().getName() + 到达现场！);   phaser.arriveAndAwaitAdvance();  }  public void eat() {   System.out.println(Thread.currentThread().getName() + 吃完了！);   phaser.arriveAndAwaitAdvance();  }  public void massage() {   System.out.println(Thread.currentThread().getName() + 做完大保健！);   phaser.arriveAndAwaitAdvance();  }  public void drink() {   System.out.println(Thread.currentThread().getName() + 喝完了！);   phaser.arriveAndAwaitAdvance();  }  @Override  public void run() {   arrive();   eat();   massage();   drink();  }  } } 关键： 继承 Phaser 类，重写 onAdvance() 方法，该方法代表当所有人都到达某一阶段时应该采取的行动。 注意：  在最后一个阶段前，返回值必须为 false ，代表流程还未结束。  如果某阶段的返回值为 true ，在该阶段后，所有线程将各自运行，不再同步。   每个线程完成阶段任务后，调用 phaser.arriveAndAwaitAdvance(); 方法。 表示该线程已经完成任务，并且在等待其他线程完成任务。 使用 phaser.bulkRegister(num); 设置注册数量，即栅栏大小。 结果： p1 到达现场！ p2 到达现场！ p3 到达现场！ 3 人到齐，开饭！ p1 吃完了！ p3 吃完了！ p2 吃完了！ 3 人吃完，去做大保健！ p2 做完大保健！ p3 做完大保健！ p1 做完大保健！ 3 人做完大保健，去喝酒！ p1 喝完了！ p3 喝完了！ p2 喝完了！ 3 人喝完酒，聚会结束！  一个小拓展： 在做大保健的时候，突然有人加入进来，并且在做完大保健后离开，如何实现？ 关键： phaser.register() 方法 注册数量 + 1 。 phaser.arriveAndAwaitAdvance() 方法 注册数量 - 1 。 为了使新加入的人直接开始做大保健，而跳过集合和吃饭环节。 加入了 stage 变量，代表已经进行到哪个阶段的活动。 代码 public class T09_TestPhaser2 {  static Phaser phaser = new PartyPhaser();  static int num = 3; public static void main(String[] args) {  phaser.bulkRegister(num);  for (int i = 1; i &lt;= num; i++) {   new Thread(new Person(), p + i).start();  } } static class PartyPhaser extends Phaser {  @Override  protected boolean onAdvance(int phase, int registeredParties) {   switch (phase) {    case 0:    System.out.println(num + 人到齐，开饭！  );    return false;    case 1:    System.out.println(num + 人吃完，去做大保健！);    num++;    System.out.println(p + num + 也要去做大保健！  );    return false;    case 2:    System.out.println(num + 人做完大保健，去喝酒！);    System.out.println(p + num + 不去喝酒！  );    num--;    return false;    case 3:    System.out.println(num + 人喝完酒，解散！  );    return true;    default:    return true;   }  }  } static class Person implements Runnable {  int stage = 0;  public Person() {  }  public Person(int stage) {   this.stage = stage;  }  public void arrive() {   System.out.println(Thread.currentThread().getName() + 到达现场！);   phaser.arriveAndAwaitAdvance();  }  public void eat() {   System.out.println(Thread.currentThread().getName() + 吃完了！);   phaser.arriveAndAwaitAdvance();  }  public void massage() {   System.out.println(Thread.currentThread().getName() + 做完大保健！);   if (phaser.getRegisteredParties() &lt; num) {    phaser.register();    new Thread(new Person(2), p + num).start();   }   phaser.arriveAndAwaitAdvance();  }  public void drink() {   if (Thread.currentThread().getName().equals(p + (num + 1))) {    phaser.arriveAndDeregister();   } else {    System.out.println(Thread.currentThread().getName() + 在喝酒！);    phaser.arriveAndAwaitAdvance();   }  }  @Override  public void run() {   switch (stage) {    case 0:    arrive();    case 1:    eat();    case 2:    massage();    case 3:    drink();   }  }  } } p1 到达现场！ p3 到达现场！ p2 到达现场！ 3 人到齐，开饭！ p3 吃完了！ p1 吃完了！ p2 吃完了！ 3 人吃完，去做大保健！ p4 也要去做大保健！ p2 做完大保健！ p1 做完大保健！ p3 做完大保健！ p4 做完大保健！ 4 人做完大保健，去喝酒！ p4 不去喝酒！ p2 在喝酒！ p1 在喝酒！ p3 在喝酒！ 3 人喝完酒，解散！ Semaphore Semaphore 类可用于控制最多有多少个线程可同时运行。 Semaphore 类可用于限流。 举个栗子： 某超市有 5 个收银台。 如果有 20 人等待结账，同一时刻只有 5 个人正在结账。 如果有 100 人等待结账，同一时刻也只有 5 个人正在结账。 如何使用？ 创建 Semaphore 对象，在创建时指定同时运行的线程的最大数量。 使用 acquire() 方法申请锁。 使用 release() 方法释放锁（请将该方法写入 finally 代码块，确保锁的释放）。 案例： public class T11_TestSemaphore {  public static void main(String[] args) {  //可控制同时最多有几个线程运行  Semaphore s = new Semaphore(1);  for (int i = 0; i &lt; 4; i++) {   new Thread(() -&gt; {    try {    s.acquire();    System.out.println(Thread.currentThread().getName() + running);    Thread.sleep(1);    } catch (InterruptedException e) {    e.printStackTrace();    } finally {    System.out.println(Thread.currentThread().getName() + end);    s.release();    }   }, T + i).start();  }  } } 该程序限制最大同时运行线程数为 1 。 结果： T0 running T0 end T2 running T2 end T1 running T1 end T3 running T3 end 在一个线程结束前，没有线程可以运行。 尝试修改最大同时运行线程数为 4 。 ……（其他代码不变） Semaphore s = new Semaphore(4); ……（其他代码不变） 结果 T0 running T3 running T2 running T1 running T3 end T1 end T0 end T2 end 可以看到，同一时刻有 4 个线程在运行。 Semaphore 共有两个构造方法： Semaphore(int permits) Creates a Semaphore with the given number of permits and nonfair fairness setting. Semaphore(int permits, boolean fair) Creates a Semaphore with the given number of permits and the given fairness setting. 即 Semaphore 默认是非公平的： 创建一个新线程后，它会试图直接去拿锁，拿不到后才会进入等待队列。 即会发生后面来的线程比前面来的线程先拿到锁的情况，即插队。 之前 Semaphore s = new Semaphore(1); 的例子的结果： T0 running T0 end T2 running T2 end T1 running T1 end T3 running T3 end T2 线程比 T1 线程先抢到了锁。 如果指定 Semaphore 为公平的： 无论现在锁是什么状态，我直接进入队列中进行排队等待。 即先进先出（FIFO）。 ……（其他代码不变） Semaphore s = new Semaphore(1, true); ……（其他代码不变） 结果 T0 running T0 end T1 running T1 end T2 running T2 end T3 running T3 end 满足线程创建的顺序。 Exchanger Exchanger 是一个用于交换线程信息的类。 如何使用？ 创建一个 Exchanger 对象。 调用 exchange(Object o) 方法交换数据。 案例 public class T12_TestExchanger { static Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); public static void main(String[] args) {  new Thread(new TestRunnable(a), A).start();  new Thread(new TestRunnable(b), B).start();  } static class TestRunnable implements Runnable {  String message = null;  public TestRunnable(String message) {   this.message = message;  }  @Override  public void run() {   try {    message = exchanger.exchange(message);   } catch (InterruptedException e) {    e.printStackTrace();   }   System.out.println(Thread.currentThread().getName() + + message);  }  } } 结果 A b B a 注意： 当某线程调用了 exchange(Object o) 方法后，在另一个线程也调用该方法交换数据前。 该线程会一直阻塞。 LockSupport LockSupport 类用于阻塞和唤醒线程。 public class T13_TestLockSupport {  public static void main(String[] args) throws InterruptedException {  Thread t = new Thread(()-&gt;{   for (int i = 0; i &lt; 5; i++) {    System.out.println(i);    if(i == 2) {    System.out.println(Thread.currentThread().getName()+ pause);    LockSupport.park();    }    try {    Thread.sleep(100);    } catch (InterruptedException e) {    e.printStackTrace();    }   }  });  t.start();  Thread.sleep(5000);  System.out.println(t.getName()+ continue);  LockSupport.unpark(t); } } 使用 park() 方法阻塞线程，使用 unpark(Thread t) 方法唤醒线程。 LockSupport 类和 Object 类的 wait() 方法和 notify() 方法的异同点： 共同点 LockSupport 中的 park 方法和 Object 中的 wait 方法都可以使线程进入 wait 或者 TIMED_wait 状态 LockSupport 中的 unpark 方法和 Object 中的 notify 可以使线程脱离 wait 、TIMED_ wait 状态 二者都可以通过调用线程的 interrupt 方法脱离等待状态 两者都是通过 JVM 层，也就是 native 代码实现的 不同点 Object 中的 wait 方法在调用时当前线程必须要对该 Object 进行加锁，否则会抛出 IllegalMonitorException 。 而 LockSupport 无需加锁，直接调用其静态方法 park() 就可以使当前线程进入阻塞状态。 Object 中 wait 和 notify 方法必须要按顺序调用，如果因为线程调度问题导致线程A先调用 notify 方法而线程B后调用 wait 方法，那么会使线程A永远处于 wait 状态。 对于 LockSupport 而言则没有这种限制，如果有线程A首先调用了 unpark() 方法并传入了线程B的引用，然后线程B再调用了 park() 方法，那么线程B是不会进入等待状态的。 调用 Object 的 wait 方法后，可以调用该线程的 interrupt 方法脱离等待状态并捕获 interruptedException 。 而 LockSupport 的并不能捕获 interruptedException。 其中第二点不同点比较重要。 即 Object 类的 wait 和 notify 必须注意调用顺序。 但是 LockSupport 类不需要。 如果先调用了 unpark() 方法，那么当程序执行到 park() 方法处时将不会被阻塞，继续往下执行。 测试 public class T13_TestLockSupport {  public static void main(String[] args) throws InterruptedException {  Thread t = new Thread(()-&gt;{   for (int i = 0; i &lt; 5; i++) {    System.out.println(i);    if(i == 2) {    System.out.println(Thread.currentThread().getName()+ pause);    LockSupport.park();    }    try {    Thread.sleep(1000);    } catch (InterruptedException e) {    e.printStackTrace();    }   }  });  t.start();  Thread.sleep(1000);  System.out.println(t.getName()+ continue);  LockSupport.unpark(t);  } } 修改了之前程序中两个线程的睡眠时间。 使 unpark() 方法比 park() 方法先被调用。 结果： 0 1 Thread-0 continue 2 Thread-0 pause 3 4 Thread-0 并没有被阻塞。 AQS AQS 等待队列 双向链表 装线程 head tail AQS 的效率为什么高？ 因为 AQS 用的是 CAS 比如说 插入尾结点时使用 CAS private Node addWaiter(Node mode) {  Node node = new Node(Thread.currentThread(), mode);  // Try the fast path of enq; backup to full enq on failure  Node pred = tail;  if (pred != null) {   node.prev = pred;   if (compareAndSetTail(pred, node)) {    pred.next = node;    return node;   }  }  enq(node);  return node;  } 获得锁 final boolean acquireQueued(final Node node, int arg) {  boolean failed = true;  try {   boolean interrupted = false;   for (;;) {    final Node p = node.predecessor();    if (p == head &amp;&amp; tryAcquire(arg)) {    setHead(node);    p.next = null; // help GC    failed = false;    return interrupted;    }    if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;    parkAndCheckInterrupt())    interrupted = true;   }  } finally {   if (failed)    cancelAcquire(node);  }  } VarHandle 如果使用的是 JDK 1.9 之后的版本，在阅读 AbstractQueuedSynchronizer 源码时会看到 VarHandle 类型的变量。 Object o = new Object(); o 是引用类型的变量，本身是一个地址，指向堆中的某块内存。 而 VarHandle 本身跟 o 没什么区别，它也是一个引用。 但是 VarHandle 的原理类似于反射： import java.lang.invoke.MethodHandles; import java.lang.invoke.VarHandle; public class VarHandleTest {  public static void main(String[] args) {  AClass aClass = new AClass();  VarHandle varHandle = null;  try {   varHandle = MethodHandles.lookup().findVarHandle(AClass.class,x,int.class);  } catch (NoSuchFieldException e) {   e.printStackTrace();  } catch (IllegalAccessException e) {   e.printStackTrace();  }  System.out.println((int)varHandle.get(aClass));  varHandle.set(aClass,9);  System.out.println((int)varHandle.get(aClass));  } } class AClass{  int x = 8; } 结果 8 9 那么为什么 AbstractQueuedSynchronizer 要使用 VarHandle 呢？ 因为 VarHandle 可以执行很多原子性的操作，这对多线程安全来说十分重要： // CAS varHandle.compareAndSet(aClass,9,10); // + 10 varHandle.getAndAdd(aClass,10); 还有一个细节： VarHandle 比反射快。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/17/locks/",
      "keywords" : "Java"
    } ,
  
    {
      "title"    : "Java Spring 01——初识 Spring",
      "category" : "Spring",
      "content": "Java Spring 01——初识 Spring 概念 框架 官方解释： 框架就是一些类和接口的集合，通过这些类和接口协调来完成一系列的程序实现。 JAVA 框架可以分为三层：表示层，业务层和物理层。 框架又叫做开发中的半成品，它不能提供整个WEB应用程序的所有东西，但是有了框架，我们就可以集中精力进行业务逻辑的开发而不用去关心它的技术实现以及一些辅助的业务逻辑。 大家熟知的 Structs 和 Spring 就是表示层和业务层框架的强力代表。 人话： 框架就是某些个人或者组织定义了一系列的类或者接口，提前定义好了一些实现。 用户可以在这些类和接口的基础之上，使用这些类来迅速的形成某个领域或者某个行业的解决方案，简化开发的过程，提高开发的效率。 就好比：现在很少有人自己去造房子，而是直接买房地产商的毛坯房，然后自己去选择喜欢的装修。 其实我们做的项目、系统都是类似的方式，如果所有的代码全部都需要自己实现，那么这个工程就太庞大了。 所以可以先创建出一些基础的模板框架，开发人员只需要按照自己的需求向架子中填充内容，完成自己独特需求即可，这就是框架存在的意义。 其实我们之前定义的简单的工具类这些东西也是类似的原理，只不过比较单一简单而已，因此，在现在的很多项目系统开发的过程中都是利用框架进行开发。 Spring 架构设计 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的Web框架(MVC)是关键。 分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。 此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 流动计算架构 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。 此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 Java主流框架演变之路  JSP+Servlet+JavaBean   MVC三层架构   使用EJB进行应用的开发，但是EJB是重量级框架（在使用的时候，过多的接口和依赖，侵入性强），在使用上比较麻烦   Struts1/Struts2+Hibernate+Spring   SpringMVC+Mybatis+Spring   SpringBoot开发，约定大于配置 Spring官网 官网地址：https://spring.io/projects/spring-framework#overview 压缩包下载地址：https://repo.spring.io/release/org/springframework/spring/ 源码地址：https://github.com/spring-projects/spring-framework  官方的介绍 Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment, with support for Groovy and Kotlin as alternative languages on the JVM, and with the flexibility to create many kinds of architectures depending on an application’s needs. As of Spring Framework 5.1, Spring requires JDK 8+ (Java SE 8+) and provides out-of-the-box support for JDK 11 LTS. Java SE 8 update 60 is suggested as the minimum patch release for Java 8, but it is generally recommended to use a recent patch release. Spring supports a wide range of application scenarios. In a large enterprise, applications often exist for a long time and have to run on a JDK and application server whose upgrade cycle is beyond developer control. Others may run as a single jar with the server embedded, possibly in a cloud environment. Yet others may be standalone applications (such as batch or integration workloads) that do not need a server. Spring is open source. It has a large and active community that provides continuous feedback based on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very long time. Spring 使创建 Java 企业应用程序变得更加容易。它提供了在企业环境中接受 Java 语言所需的一切，并支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并可根据应用程序的需要灵活地创建多种体系结构。 从 Spring Framework 5.0 开始，Spring 需要 JDK 8(Java SE 8+)，并且已经为 JDK 9 提供了现成的支持。 Spring支持各种应用场景， 在大型企业中, 应用程序通常需要运行很长时间，而且必须运行在 jdk 和应用服务器上，这种场景开发人员无法控制其升级周期。 其他可能作为一个单独的jar嵌入到服务器去运行，也有可能在云环境中。还有一些可能是不需要服务器的独立应用程序(如批处理或集成的工作任务)。 Spring 是开源的。它拥有一个庞大而且活跃的社区，提供不同范围的，真实用户的持续反馈。这也帮助Spring不断地改进,不断发展。 核心解释 spring是一个开源框架。 spring是为了简化企业开发而生的，使得开发变得更加优雅和简洁。 spring是一个 IOC 和 AOP 的容器框架。 IOC 控制反转 AOP 面向切面编程 容器 包含并管理应用对象的生命周期，就好比用桶装水一样，Spring 就是桶，而对象就是水。 使用spring的优点  Spring通过DI、AOP和消除样板式代码来简化企业级Java开发   Spring框架之外还存在一个构建在核心框架之上的庞大生态圈，它将Spring扩展到不同的领域，如Web服务、REST、移动开发以及NoSQL   低侵入式设计，代码的污染极低   独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺   Spring的IOC容器降低了业务对象替换的复杂性，提高了组件之间的解耦   Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的复用   Spring的ORM和DAO提供了与第三方持久层框架的的良好整合，并简化了底层的数据库访问   Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部 如何简化开发 基于POJO的轻量级和最小侵入性编程 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少样板式代码 spring的模块划分图 模块解释：  Test Spring的单元测试模块 Core Container 核心容器模块 AOP+Aspects 面向切面编程模块 Instrumentation 提供了class instrumentation支持和类加载器的实现来在特定的应用服务器上使用，几乎不用 Messaging 包括一系列的用来映射消息到方法的注解，几乎不用 Data Access/Integration 数据的获取/整合模块，包括了 JDBC , ORM , OXM ,J MS 和事务模块 Web 提供面向web整合特性 IOC（Inversion of Control）:控制反转 为什么要引入IOC 创建一个普通的java项目，完成下述功能 UserDao.java package com.mashibing.dao; public interface UserDao {  public void getUser(); } UserDaoImpl.java package com.mashibing.dao.impl; import com.mashibing.dao.UserDao; public class UserDaoImpl implements UserDao {  @Override  public void getUser() {  System.out.println(获取用户数据);  } } UserService.java package com.mashibing.service; public interface UserService {  public void getUser(); } UserServiceImpl.java package com.mashibing.service.impl; import com.mashibing.dao.UserDao; import com.mashibing.dao.impl.UserDaoImpl; import com.mashibing.dao.impl.UserDaoMysqlImpl; import com.mashibing.service.UserService; public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override  public void getUser() {  userDao.getUser();  } } SpringDemoTest.java package com.mashibing.test; import com.mashibing.service.UserService; import com.mashibing.service.impl.UserServiceImpl; public class SpringDemoTest {  public static void main(String[] args) {  UserService service = new UserServiceImpl();  service.getUser();  } } 在之前的代码编写过程中，我们都是这么完成我们的功能的，但是如果增加一个UserDao的实现类呢？ UserDaoMysqlImpl.java package com.mashibing.dao.impl; import com.mashibing.dao.UserDao; public class UserDaoMysqlImpl implements UserDao {  @Override  public void getUser() {  System.out.println(mysql);  } } 如果我们想要使用mysql的话，那么就必须要修改UserServiceImpl.java的代码： package com.mashibing.service.impl;import com.mashibing.dao.UserDao;import com.mashibing.dao.impl.UserDaoImpl;import com.mashibing.dao.impl.UserDaoMysqlImpl;import com.mashibing.service.UserService;public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); @Override public void getUser() {  userDao.getUser(); }} 但是如果我们再增加一个oracle的类呢？ UserDaoOracleImpl.java package com.mashibing.dao.impl;import com.mashibing.dao.UserDao;public class UserDaoOracleImpl implements UserDao { @Override public void getUser() {  System.out.println(oracle); }} 此时UserService还是要继续修改，很显然这样的方式已经不适用于我们的需求了，那么怎么解决呢，可以使用如下的方式 UserServiceImpl.java package com.mashibing.service.impl;import com.mashibing.dao.UserDao;import com.mashibing.dao.impl.UserDaoImpl;import com.mashibing.service.UserService;public class UserServiceImpl implements UserService { private UserDao userDao; public void setUserDao(UserDao userDao){  this.userDao = userDao; } @Override public void getUser() {  userDao.getUser(); }} 测试类SpringDemoTest.java package com.mashibing.test;import com.mashibing.dao.impl.UserDaoMysqlImpl;import com.mashibing.dao.impl.UserDaoOracleImpl;import com.mashibing.service.UserService;import com.mashibing.service.impl.UserServiceImpl;public class SpringDemoTest { public static void main(String[] args) {  UserServiceImpl userService = new UserServiceImpl();  userService.setUserDao(new UserDaoMysqlImpl());  userService.getUser();  userService.setUserDao(new UserDaoOracleImpl());  userService.getUser(); }} 其实从刚刚的代码中，大家应该能体会解耦的重要性了，下面我们就开始学习Spring的IOC。 IOC初始 想要搞明白IOC，那么需要搞清楚如下几个问题： 1、谁控制谁2、控制什么3、什么是反转4、哪些方面被反转 基本概念  tIoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern. tIOC与大家熟知的依赖注入同理，. 这是一个通过依赖注入对象的过程 也就是说，它们所使用的对象，是通过构造函数参数，工厂方法的参数或这是从工厂方法的构造函数或返回值的对象实例设置的属性，然后容器在创建bean时注入这些需要的依赖。 这个过程相对普通创建对象的过程是反向的（因此称之为IoC），bean本身通过直接构造类来控制依赖关系的实例化或位置，或提供诸如服务定位器模式之类的机制。 如果这个过程比较难理解的话，那么可以想象自己找女朋友和婚介公司找女朋友的过程。如果这个过程能够想明白的话，那么我们现在回答上面的问题： 分油分菜 容器——菜篮子 实现方式是DI 1、谁控制谁：在之前的编码过程中，都是需要什么对象自己去创建什么对象，有程序员自己来控制对象，而有了IOC容器之后，就会变成由IOC容器来控制对象，2、控制什么：在实现过程中所需要的对象及需要依赖的对象3、什么是反转：在没有IOC容器之前我们都是在对象中主动去创建依赖的对象，这是正转的，而有了IOC之后，依赖的对象直接由IOC容器创建后注入到对象中，由主动创建变成了被动接受，这是反转4、哪些方面被反转：依赖的对象 List IOC 不是 Spring提出的，之前就有，只不过Spring实现了IOC DI与IOC 很多人把IOC和DI说成一个东西，笼统来说的话是没有问题的，但是本质上还是有所区别的,希望大家能够严谨一点，IOC和DI是从不同的角度描述的同一件事，IOC是从容器的角度描述，而DI是从应用程序的角度来描述，也可以这样说，IOC是设计思想，而DI是具体的实现方式 4、总结 在此处总结中，希望大家能够能够明白两件事： 1、解耦 在面向对象设计的软件系统中，底层的实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。 需要注意的是，在这样的组合关系中，一旦某一个对象出现了问题，那么其他对象肯定回有所影响，这就是耦合性太高的缘故，但是对象的耦合关系是无法避免的，也是必要的。随着应用程序越来越庞大，对象的耦合关系可能越来越复杂，经常需要多重依赖关系，因此，无论是架构师还是程序员，在面临这样的场景的时候，都需要减少这些对象的耦合性。 耦合的关系不仅仅是对象与对象之间，也会出现在软件系统的各个模块之间，是我们需要重点解决的问题。而为了解决对象之间的耦合度过高的问题，我们就可以通过IOC来实现对象之间的解耦，spring框架就是IOC理论最最广泛的应用。 从上图中可以看到，当引入了第三方的容器之后，几个对象之间就没有了耦合关系，全部对象都交由容器来控制，这个容器就相当于粘合剂，将系统的对象粘合在一起发挥作用。 2、生态 任何一个语言或者任何一个框架想要立于不败之地，那么很重要的就是它的生态。 生态是一个笼统的概念，只要是与该语言相关的都可以计入生态中： 语言本身 集成开发环境（IDE） 扩展功能支持库 第三方功能模块、源码 帮助文档和知识库 技术交流社区 资源下载网站 教程和培训 …… Java 为什么火？ 因为它的生态虽然很杂很乱，但是很全。 一切新技术，都有会 Java 的从业人员通过 Java 实现，然后经过讨论、整理、归纳后封装成 Jar 包，同时市面上也会有大量的培训和教学资料教你如何使用。 所以 Java 在当今时代，在很多方面都比不过一些语言，但是由于它的生态，所以它始终占据市场最大的占用率。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/20/01-introduce/",
      "keywords" : "Java，Spring"
    } ,
  
    {
      "title"    : "Java Spring 02—— IOC 基本使用",
      "category" : "Spring",
      "content": "Java Spring 02—— IOC 基本使用 基本使用 1. 导包 手动请加载以下包（不推荐） commons-logging-1.2.jar spring-beans-5.2.3.RELEASE.jar spring-context-5.2.3.RELEASE.jar spring-core-5.2.3.RELEASE.jar spring-expression-5.2.3.RELEASE.jar 通过 Maven 自动导包（推荐） &lt;dependecies&gt;  t&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;  t&lt;dependency&gt;  t t&lt;groupId&gt;org.springframework&lt;/groupId&gt;  t t&lt;artifactId&gt;spring-context&lt;/artifactId&gt;  t t&lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  t&lt;/dependency&gt; &lt;/dependecies&gt; 2. 新建 Person 类 public class Person {  tprivate int id;  tprivate String name;  tprivate int age;  tprivate String gender;  tpublic Person(){  t}  tpublic int getId() {  t treturn id;  t}  tpublic void setId(int id) {  t tthis.id = id;  t}  tpublic String getName() {  t treturn name;  t}  tpublic void setName(String name) {  t tthis.name = name;  t}  tpublic int getAge() {  t treturn age;  t}  tpublic void setAge(int age) {  t tthis.age = age;  t}  tpublic String getGender() {  t treturn gender;  t}  tpublic void setGender(String gender) {  t tthis.gender = gender;  t}  t@Override  tpublic String toString() {  t treturn Person{ +  t t t id= + id +  t t t , name=' + name + '  '' +  t t t , age= + age +  t t t , gender=' + gender + '  '' +  t t t '}';  t} } 3. 新建 ioc.xml 文件 请将 ioc.xml 文件放在正确的路径中： 普通项目路径 src/ioc.xml IDEA Maven项目路径 src/main/resources/ioc.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation=http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&gt;  &lt;!--注册一个对象，spring会自动创建这个对象--&gt;  &lt;!--  一个bean标签就表示一个对象  id:这个对象的唯一标识  class:注册对象的完全限定名  --&gt;  &lt;bean id=person class=com.kky.bean.Person&gt;  &lt;!--使用property标签给对象的属性赋值  name:表示属性的名称  value：表示属性的值  --&gt;  &lt;property name=id value=1&gt;&lt;/property&gt;  &lt;property name=name value=zhangsan&gt;&lt;/property&gt;  &lt;property name=age value=18&gt;&lt;/property&gt;  &lt;property name=gender value=男&gt;&lt;/property&gt;  &lt;/bean&gt; &lt;/beans&gt; 测试 public class Test {  tpublic static void main(String[] args) {  t t//ApplicationContext:表示ioc容器  t t//ClassPathXmlApplicationContext:表示从当前classpath路径中获取xml文件的配置  t t//根据spring的配置文件来获取ioc容器对象  t tApplicationContext context = new ClassPathXmlApplicationContext(ioc.xml);  t tPerson person = context.getBean(person, Person.class);  t tSystem.out.println(person);  t} } 结果 Person{id=1, name='zhangsan', age=18, gender='男'} 可以看到，我们写入 ioc.xml 的对象成功被创建并读取。 一些细节 1 . ApplicationContext 就是 IOC 容器的接口，可以通过此对象获取容器中创建的对象 2 . Spring IOC 底层是通过 反射 创建对象的，所以请注意实现无参构造方法。 在 Java 中，如果类中没有构造方法，那么会自动为其设置一个无参构造方法。 此时使用 Spring IOC 不会报错。 但如果类中存在有参构造方法，但是没有无参构造方法时。 此时使用 Spring IOC 会报错。 3 . 对象的属性是由 setter/getter 方法决定的，而不是定义的成员属性 &lt;property name=id value=1&gt;&lt;/property&gt; 中 name=id 到底是哪个 id ？ 很多人会以为是这个 id private int id; 即成员变量 但其实是这个 id public int getId() {  treturn id; } public void setId(int id) {  tthis.id = id; } 即 IOC 会自动把 id 首字母大写变成 Id，然后去寻找对应的 set 和 get 方法 所以在使用 IOC 时要注意，要将类的 setter/getter 方法名与 ioc.xml 中的 name 名对应起来。 当然了，一般情况下，类的属性名和 setter/getter 方法名本身就是对应的。 获取对象的方式 一共有三种获取对象的方式： 通过 id ，需要转换数据类型 Person person = (Person)context.getBean(person)   通过类型  Person person = context.getBean(Person.class)  注意：当存在多个同类型的对象时无法使用该方法。 通过 id + 类型 Person person = context.getBean(person ,Person.class)   其他赋值方式 前文使用类的 setter 方法赋值，除此之外还有两种赋值方式 通过构造器给 bean 对象赋值 首先得定义构造器 public Person(int id, String name, Integer age, String gender) {  tthis.id = id;  tthis.name = name;  tthis.age = age;  tthis.gender = gender; } 然后在 ioc.xml 中使用该构造器 &lt;bean id=person2 class=com.mashibing.bean.Person&gt;  t&lt;constructor-arg name=id value=1&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg name=name value=lisi&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg name=age value=20&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg name=gender value=女&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 效果等同于 Person person2 = new Person(1, lisi, 20, 女); 提问：此时配置文件中的 name 是什么的 name ？ 回答： 依然不是类的成员变量的 name，而是构造方法中的形参列表中的 name 即 public Person(int id, String name, Integer age, String gender) 中的 id name age gender 在严格遵守形参列表的顺序的情况下，可以省略 name。 &lt;bean id=person3 class=com.mashibing.bean.Person&gt;  t&lt;constructor-arg value=1&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=lisi&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=20&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=女&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 效果等同于 Person person3 = new Person(1, lisi, 20, 女);  可以使用 index 指明该属性对应形参列表的哪个属性，下标从 0 开始。 &lt;bean id=person4 class=com.mashibing.bean.Person&gt;  t&lt;constructor-arg value=lisi index=1&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=1 index=0&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=女 index=3&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=20 index=2&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 效果等同于 Person person4 = new Person(1, lisi, 20, 女);  来看一个很深井冰的问题： 存在多个形参个数相同的构造器 通过构造器给 bean 对象赋值，省略 name 给 Person 类添加构造器 public Person(int id, String name, int age) {  tthis.id = id;  tthis.name = name;  tthis.age = age; } public Person(int id, String name, String gender) {  tthis.id = id;  tthis.name = name;  tthis.gender = gender; } 使用省略 name 的方式赋值 &lt;bean id=person4 class=com.kky.bean.Person&gt;  t&lt;constructor-arg value=4&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=wangwu&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=22&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 仔细观察，两个构造器的不同在于第三个形参，一个是 int age ，一个是 String gender 。 有趣的地方在于，我们赋值时所使用的 22 ，即能视为 age = 22 ，也能视为 gender = 22。 所以最后创建出来的对象是哪个呢？ 测试 Person person4 = context.getBean(person4, Person.class); System.out.println(person4); 结果 Person{id=4, name='wangwu', age=0, gender='22'} 下面的构造器被调用了。 难道跟顺序有关吗？ 试着把构造器换一下位置： public Person(int id, String name, String gender) {  tthis.id = id;  tthis.name = name;  tthis.gender = gender; } public Person(int id, String name, int age) {  tthis.id = id;  tthis.name = name;  tthis.age = age; } 测试 Person person4 = context.getBean(person4, Person.class); System.out.println(person4); 结果 Person{id=4, name='wangwu', age=22, gender='null'} 看来是哪个构造器在下面就调用哪个。 那此时我想强制调用上面的构造器怎么办？ 指定第三个参数的数据类型。 &lt;bean id=person4 class=com.kky.bean.Person&gt;  t&lt;constructor-arg value=4&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=wangwu&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=22 type=int&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 测试 Person person4 = context.getBean(person4, Person.class); System.out.println(person4); 结果 Person{id=22, name='4', age=0, gender='wangwu'} 为什么会出现这种结果，因为 public Person(int id, String name, int age) {  tthis.id = id;  tthis.name = name;  tthis.age = age; } 该方法中存在两个 int 类型的形参。 所以还应该指定下标位置 &lt;bean id=person4 class=com.kky.bean.Person&gt;  t&lt;constructor-arg value=4&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=wangwu&gt;&lt;/constructor-arg&gt;  t&lt;constructor-arg value=22 type=int index=2&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 测试 Person person4 = context.getBean(person4, Person.class); System.out.println(person4); 结果 Person{id=4, name='wangwu', age=22, gender='null'} 结果正确。 总结 通过构造器给 bean 对象赋值时，一共有以下属性： name 形参的名称，而非成员变量的名称 value 实参的值 type 参数的名称 index 对应的形参的下标，从 0 开始 通过命名空间赋值 通过 p 命名空间为bean赋值，简化配置文件中属性声明的写法  导入命名空间 &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:p=http://www.springframework.org/schema/p  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd&gt;   在配置中添加 bean  &lt;bean id=person6 class=com.mashibing.bean.Person p:id=3 p:name=wangwu p:age=22 p:gender=男&gt;&lt;/bean&gt;   复杂类型的赋值操作 在之前的测试代码中，我们都是给最基本的属性进行赋值操作。 在正常的企业级开发中还会遇到给各种复杂类型赋值，如集合、数组、其他对象等。 修改 Person 类 public class Person {  private int id;  private String name;  private int age;  private String gender;  private String[] hobbies;  private Address address;  private List&lt;Address&gt; lists;  private Set&lt;String&gt; sets;  private Map&lt;String, Object&gt; maps;  private Properties properties; 并新建 Address 类 public class Address {  private String province;  private String city;  private String town; 省略两个类的无参构造器，所有属性的 getter/setter 方法，toString() 方法。 给数组类型赋值 private String[] hobbies; 方式一 &lt;bean id=person6 class=com.kky.bean.Person&gt;  t...  t&lt;property name=hobbies value=book,girl,movie&gt;&lt;/property&gt;  t... &lt;/bean&gt; Spring 会自动把 “book,girl,movie” 转成数组 方式二 使用 array 标签 &lt;bean id=person6 class=com.kky.bean.Person&gt;  t...  t&lt;property name=hobbies&gt;  t t&lt;array&gt;  t t t&lt;value&gt;book&lt;/value&gt;  t t t&lt;value&gt;girl&lt;/value&gt;  t t t&lt;value&gt;movie&lt;/value&gt;  t t&lt;/array&gt;  t&lt;/property&gt;  t... &lt;/bean&gt; 给引用类型赋值 private Address address; 方式一：内部 bean &lt;bean id=person6 class=com.kky.bean.Person&gt;  t...  t&lt;property name=address&gt;  t t&lt;bean id=address class=com.kky.bean.Address&gt;  t t t&lt;property name=province value=江苏省&gt;&lt;/property&gt;  t t t&lt;property name=city value=南京市&gt;&lt;/property&gt;  t t t&lt;property name=town value=玄武区&gt;&lt;/property&gt;  t t&lt;/bean&gt;  t&lt;/property&gt;  t... &lt;/bean&gt; 该方式创建的对象无法从 IOC 容器中取出 Address address = context.getBean(address,Address.class); 执行该语句会报错。 方式二：引用外部 bean &lt;bean id=person6 class=com.kky.bean.Person&gt;  t...  t&lt;property name=address ref=address&gt;&lt;/property&gt;  t... &lt;/bean&gt; &lt;bean id=address class=com.mashibing.bean.Address&gt;  t&lt;property name=province value=河北省&gt;&lt;/property&gt;  t&lt;property name=city value=邯郸&gt;&lt;/property&gt;  t&lt;property name=town value=武安&gt;&lt;/property&gt; &lt;/bean&gt; 该方式创建的 Address 对象可从 IOC 容器中取出 给 List 赋值 private List&lt;Address&gt; lists; 同样地可以使用内部 bean 和外部 bean 的方式 &lt;bean id=person6 class=com.kky.bean.Person&gt;  t...  t&lt;property name=lists&gt;  t t&lt;list&gt;  t t t&lt;!--使用内部bean,无法从IOC容器中直接获取对象的值--&gt;  t t t&lt;bean id=address2 class=com.mashibing.bean.Address&gt;  t t t t&lt;property name=province value=北京&gt;&lt;/property&gt;  t t t&lt;/bean&gt;  t t t&lt;bean class=com.mashibing.bean.Address&gt;  t t t t&lt;property name=province value=上海&gt;&lt;/property&gt;  t t t&lt;/bean&gt;  t t t&lt;!--使用外部bean，可以随意从IOC容器获取对象的值--&gt;  t t t&lt;ref bean=address&gt;&lt;/ref&gt;  t t&lt;/list&gt;  t&lt;/property&gt;  t... &lt;/bean&gt; 给 Set 赋值 private Set&lt;String&gt; sets; &lt;bean id=person6 class=com.kky.bean.Person&gt;  t...  t&lt;property name=sets&gt;  t t&lt;set&gt;  t t t&lt;value&gt;zhangsan&lt;/value&gt;  t t t&lt;value&gt;lisi&lt;/value&gt;  t t t&lt;value&gt;wangwu&lt;/value&gt;  t t&lt;/set&gt;  t&lt;/property&gt;  t... &lt;/bean&gt; 给 Map 赋值 private Map&lt;String, Object&gt; maps; &lt;bean id=person6 class=com.kky.bean.Person&gt;  t...  t&lt;property name=maps&gt;  t t&lt;map&gt;  t t t&lt;entry key=a value=aaa&gt;&lt;/entry&gt;  t t t&lt;entry key=address value-ref=address&gt;&lt;/entry&gt;  t t t&lt;entry key=address2&gt;  t t t t&lt;bean class=com.mashibing.bean.Address&gt;  t t t t t&lt;property name=province value=广东省&gt;&lt;/property&gt;  t t t t&lt;/bean&gt;  t t t&lt;/entry&gt;  t t t&lt;entry&gt;  t t t t&lt;key&gt;  t t t t t&lt;value&gt;heihei&lt;/value&gt;  t t t t&lt;/key&gt;  t t t t&lt;value&gt;haha&lt;/value&gt;  t t t&lt;/entry&gt;  t t t&lt;entry key=list&gt;  t t t t&lt;list&gt;  t t t t t&lt;value&gt;11&lt;/value&gt;  t t t t t&lt;value&gt;22&lt;/value&gt;  t t t t&lt;/list&gt;  t t t&lt;/entry&gt;  t t&lt;/map&gt;  t&lt;/property&gt;  t... &lt;/bean&gt; 给 properties 赋值 private Properties properties; &lt;bean id=person6 class=com.kky.bean.Person&gt;  t...  t&lt;property name=properties&gt;  t t&lt;props&gt;  t t t&lt;prop key=111&gt;aaa&lt;/prop&gt;  t t t&lt;prop key=222&gt;bbb&lt;/prop&gt;  t t&lt;/props&gt;  t&lt;/property&gt;  t... &lt;/bean&gt; 自动装配 当一个对象中需要引用另外一个对象的时候。 除了通过 property 标签来进行手动配置的，还可以让 Spring 根据某种规则帮我们自动装配。 default/no：不自动装配 byName：按照名字进行装配，以属性名作为id去容器中查找组件，进行赋值，如果找不到则装配null byType：按照类型进行装配,以属性的类型作为查找依据去容器中找到这个组件，如果有多个类型相同的bean对象，那么会报异常，如果找不到则装配null constructor：按照构造器进行装配，先按照有参构造器参数的类型进行装配，没有就直接装配null；如果按照类型找到了多个，那么就使用参数名作为id继续匹配，找到就装配，找不到就装配null ioc.xml &lt;bean id=address class=com.mashibing.bean.Address&gt;  &lt;property name=province value=河北&gt;&lt;/property&gt;  &lt;property name=city value=邯郸&gt;&lt;/property&gt;  &lt;property name=town value=武安&gt;&lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=person1 class=com.mashibing.bean.Person autowire=byName&gt;&lt;/bean&gt;  &lt;bean id=person2 class=com.mashibing.bean.Person autowire=byType&gt;&lt;/bean&gt;  &lt;bean id=person3 class=com.mashibing.bean.Person autowire=constructor&gt;&lt;/bean&gt; &lt;/beans&gt; bean 之间的继承关系 bean 之间是可以继承的 &lt;bean id=parent class=com.mashibing.bean.Person abstract=false&gt;  t&lt;property name=id value=1&gt;&lt;/property&gt;  t&lt;property name=name value=zhangsan&gt;&lt;/property&gt;  t&lt;property name=age value=20&gt;&lt;/property&gt;  t&lt;property name=gender value=男&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--可以通过 parent 属性来获取父 bean 中的某些属性值--&gt; &lt;bean id=son class=com.mashibing.bean.Person parent=parent&gt;  t&lt;property name=name value=haha&gt;&lt;/property&gt; &lt;/bean&gt; 测试 Person son = context.getBean(son, Person.class); System.out.println(son); 结果 Person{id=1, name='haha', age=20, gender='男', address=null,...} 即自己定义的属性是覆盖父 bean 的属性的。 在 bean 中添加 abstract=true ，则该 bean 是抽象的，不会实例化。 如果想实现类似于 Java 中的抽象类，不需要将当前 bean 实例化的话，可以使用 abstract 属性。 &lt;bean id=parent class=com.mashibing.bean.Person abstract=false&gt;  t&lt;property name=id value=1&gt;&lt;/property&gt;  t&lt;property name=name value=zhangsan&gt;&lt;/property&gt;  t&lt;property name=age value=20&gt;&lt;/property&gt;  t&lt;property name=gender value=男&gt;&lt;/property&gt; &lt;/bean&gt; 该 bean 不会实例化 bean 之间的依赖关系 在配置文件中先定义的 bean 对象先被创建。 &lt;bean id=address class=com.mashibing.bean.Address&gt;&lt;/bean&gt; &lt;bean id=person class=com.mashibing.bean.Person&gt;&lt;/bean&gt; address 先创建，person 后创建。 使用 depend-on 标签改变创建顺序 &lt;bean id=address class=com.mashibing.bean.Address depends-on=person&gt;&lt;/bean&gt; &lt;bean id=person class=com.mashibing.bean.Person&gt;&lt;/bean&gt; 此时 person 先创建，address 后创建。 不需要关心 Spring IOC 的创建对象的顺序问题。 现在 Person 类中包含 Address 对象。 public class Person{  t...  tprivate Address address;  t... } 我们平时是这么做的。 Address address = new Address(...); Person person = new Person(... ,address ,...); 即先创建子对象。 但是在 Spring IOC 中无需关心这个问题，Spring IOC 先创建的对象中即使有空对象，后续也会进行正确的设置。 bean 的作用域 bean 有两种作用域：singleton 和 prototype 默认情况下是 singleton 单例模式 ApplicationContext context = new ClassPathXmlApplicationContext(ioc.xml); Person person = context.getBean(person, Person.class); Person person1 = context.getBean(person, Person.class); System.out.println(person == person1); 结果 true 也就是说，person 和 person1 是同一个对象，修改 person 中的属性值，person1 也会被修改。 prototype 原型模式 ，可以简单地理解成 “多例模式”。 即该模式每次创建的都是一个新对象。 如果要使用 prototype 请修改 scope 属性 &lt;bean id=person class=com.kky.bean.Person scope=prototype&gt;  t&lt;property name=id value=1&gt;&lt;/property&gt;  t&lt;property name=name value=zhangsan&gt;&lt;/property&gt;  t&lt;property name=age value=18&gt;&lt;/property&gt;  t&lt;property name=gender value=男&gt;&lt;/property&gt; &lt;/bean&gt; 此时从容器中取出的是不同的对象 测试 ApplicationContext context = new ClassPathXmlApplicationContext(ioc.xml); Person person = context.getBean(person, Person.class); Person person1 = context.getBean(person, Person.class); System.out.println(person == person1); 结果 false    容器的模式  对象何时创建     单例模式  容器创建完成时自动创建    原型模式  从容器中取出对象时才创建   在 Spring 4.x 的版本中还包含另外两种作用域： request 每次发送请求都会有一个新的对象 session 每一次会话都会有一个新的对象 使用率极低，于是在 Spring 5.x 版本的时候被淘汰了 利用工厂模式创建 bean 对象 自定义工厂 在之前的案例中，所有 bean 对象的创建都是通过反射得到对应的 bean 实例。 但其实 Spring 还支持另一种创建 bean 实例的方式——工厂模式。 在利用工厂模式创建 bean 实例的时候有两种方式 静态工厂 不需要创建工厂对象，直接通过 对象=工厂类.静态工厂方法名() 调用。 实例工厂 需要创建工厂对象。  工厂类 工厂对象 = new 工厂类(); 对象 = 工厂对象.get对象名();   静态工厂 新建静态工厂类 PersonStaticFactory public class PersonStaticFactory {  public static Person getPerson(String name){  Person person = new Person();  person.setId(1);  person.setName(name);  return person;  } } 写入配置文件： class 指定静态工厂类 factory-method 指定哪个方法是工厂方法 &lt;bean id=person5 class=com.mashibing.factory.PersonStaticFactory factory-method=getPerson&gt;  &lt;!--constructor-arg：可以为方法指定参数--&gt;  &lt;constructor-arg value=lisi&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 实例工厂 新建实例工厂类 PersonInstanceFactory public class PersonInstanceFactory {  public Person getPerson(String name){  Person person = new Person();  person.setId(1);  person.setName(name);  return person;  } } 写入配置文件： 创建实例工厂类对象  &lt;!--创建实例工厂类--&gt; &lt;bean id=personInstanceFactory class=com.mashibing.factory.PersonInstanceFactory&gt;&lt;/bean&gt;   调用对象  factory-bean 指定使用哪个工厂实例  factory-method 指定使用哪个工厂实例的方法  &lt;bean id=person6 class=com.mashibing.bean.Person factory-bean=personInstanceFactory factory-method=getPerson&gt; &lt;constructor-arg value=wangwu&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;   继承 FactoryBean 接口 FactoryBean 是 Spring 规定的一个接口。 实现该接口后 Spring 会自动调用以创建实例。 但是在 IOC 容器启动的时候不会创建实例，只有在使用的时候才会创建对象。 该接口必须实现的两个方法： getObject() 工厂方法，返回需要创建的对象 getObjectType() 返回对象类型 以及一个可选方法 isSingleton Spring 通过调用该方法得知该对象是单例模式还是原型模式。 该方法在接口有默认实现： default boolean isSingleton() {  treturn true; } 可以看到，默认是单例模式。 当我们需要使用原型模式时，重写该方法使返回值为 false 。 Spring 会自动调用这三个方法，我们只需要关心实现即可。 案例 public class MyFactoryBean implements FactoryBean&lt;Person&gt; {  @Override  public Person getObject() throws Exception {  Person person = new Person();  person.setName(maliu);  return person;  } @Override  public Class&lt;?&gt; getObjectType() {  return Person.class;  } @Override  public boolean isSingleton() {  return false;  } } 写入配置文件 &lt;bean id=myfactorybean class=com.mashibing.factory.MyFactoryBean&gt;&lt;/bean&gt; 添加 bean 对象的初始化和销毁方法 我们可以根据需要为 bean 对象添加初始化方法和销毁方法。 初始化方法 创建对象后调用。 销毁方法 销毁对象前调用。 在 Person 类中添加 init() 方法和 destory() 方法 public class Person{  ...  public void init(){  System.out.println(对象被初始化);  }  public void destory(){  System.out.println(对象被销毁);  }  ... 写入配置文件 &lt;bean id=address class=com.mashibing.bean.Address init-method=init destroy-method=destory&gt;&lt;/bean&gt;  当容器 scope = singleton 时。 容器创建后会自动创建对象，容器销毁时会自动销毁对象。 如何销毁容器？ ApplicationContext 类没有 close() 方法。 但它的子类 ClassPathXmlApplicationContext 实现了 close() 方法。 只需要做强制类型转换即可。 ApplicationContext context = new ClassPathXmlApplicationContext(ioc.xml); //applicationContext没有close方法，需要使用具体的子类 ((ClassPathXmlApplicationContext)context).close();  当容器 scope = prototype 时。 从容器获取对象时才创建对象，并且销毁容器时不会销毁对象。 也就是说，原型模式时的 destory() 方法不会被自动调用的。 配置 bean 对象初始化方法的前后处理方法 Spring中包含一个 BeanPostProcessor 的接口，可以在 bean 的初始化方法的前后调用该方法。 如果配置了初始化方法的前置和后置处理器，无论是否包含初始化方法，都会进行调用。  实现 BeanPostProcessor 接口 重写两个方法  postProcessBeforeInitialization() bean 对象初始化前调用  postProcessAfterInitialization() bean 对象初始化后调用   案例 public class MyBeanPostProcessor implements BeanPostProcessor {  t//初始化前调用  @Override  public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {  System.out.println(初始化前);  return bean;  }  t//初始化后调用  @Override  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {  System.out.println(初始化后);  return bean;  } } 写入配置文件 &lt;bean id=myBeanPostProcessor class=com.kky.bean.MyBeanPostProcessor&gt;&lt;/bean&gt; 因为 bean 对象默认使用单例模式，会自动创建对象。 所以不需要编写测试代码，直接运行程序即可。 注意： BeanPostProcessor 是服务于所有 bean 的。 也就是说，每一个 bean 初始化时都会调用 BeanPstProcessor 的方法 。 Spring创建第三方 bean 对象 在 Spring 中，很多对象都是单实例的，在日常的开发中，我们经常需要使用某些外部的单实例对象，例如数据库连接池。 下面我们来讲解下如何在 Spring 中创建第三方 bean 实例。 案例：创建 Druid 数据库连接池对象。 通过 Maven 导入相关 jar 包 &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt;  t&lt;groupId&gt;com.alibaba&lt;/groupId&gt;  t&lt;artifactId&gt;druid&lt;/artifactId&gt;  t&lt;version&gt;1.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt;  t&lt;groupId&gt;mysql&lt;/groupId&gt;  t&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  t&lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; 编写配置文件。 填写数据库的用户名、密码、地址、驱动 &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd&gt; &lt;bean id=dataSource class=com.alibaba.druid.pool.DruidDataSource&gt;  &lt;property name=username value=root&gt;&lt;/property&gt;  &lt;property name=password value=123456&gt;&lt;/property&gt;  &lt;property name=url value=jdbc:mysql://localhost:3306/demo&gt;&lt;/property&gt;  &lt;property name=driverClassName value=com.mysql.jdbc.Driver&gt;&lt;/property&gt;  &lt;/bean&gt; &lt;/beans&gt; 使用 ApplicationContext context = new ClassPathXmlApplicationContext(ioc.xml); DruidDataSource dataSource = context.getBean(dataSource, DruidDataSource.class); Spring 引用外部配置文件 在项目开发中，有些数据定义在配置文件中比较好，比如用户名、密码…… 那么如何使用 Spring 引用外部配置文件呢？ 案例：创建数据库连接池对象 在 resource 中添加 dbconfig.properties jdbc.username=root jdbc.password=123456 jdbc.url=jdbc:mysql://localhost:3306/test jdbc.driverClassName=com.mysql.jdbc.Driver 使用方法： 导入 context 命名空间 &lt;beans ...  xmlns:context=http://www.springframework.org/schema/context  xsi:schemaLocation=  ...  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  ...&gt; &lt;/beans&gt;   引入配置文件 xml &lt;context:property-placeholder location=classpath:dbconfig.properties/&gt;  使用 ${} 来读取配置文件中的数据 &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd&gt;  t&lt;!--加载外部配置文件  t t在加载外部依赖文件的时候需要context命名空间  t--&gt;  &lt;context:property-placeholder location=classpath:dbconfig.properties/&gt;  &lt;bean id=dataSource class=com.alibaba.druid.pool.DruidDataSource&gt;  &lt;property name=username value=${jdbc.username}&gt;&lt;/property&gt;  &lt;property name=password value=${jdbc.password}&gt;&lt;/property&gt;  &lt;property name=url value=${jdbc.url}&gt;&lt;/property&gt;  &lt;property name=driverClassName value=${jdbc.driverClassName}&gt;&lt;/property&gt;  &lt;/bean&gt; &lt;/beans&gt; 注意 有时通过 Spring 读取配置文件中的参数时会得到预期之外的效果。 这是因为 Spring 默认会将本机中的环境配置文件导入。 而当多个配置文件的参数名重名时，会发生读取错误。 特别是以下情形： dbconfig.properties username=root 此时使用 ${username} 读取不到 root ，而会读取到本机当前的账户名： 即柯凯元 所以使用 Spring 读取配置文件时，最好给参数名加上前缀，例如：jdbc.username SpEL SpEL—— Spring Expression Language。 Spring 的表达式语言，支持运行时查询操作对象。 使用 #{...} 作为语法规则，所有的大括号中的字符都认为是 SpEL。 &lt;bean id=person4 class=com.mashibing.bean.Person&gt;  t&lt;!--支持任何运算符--&gt;  t&lt;property name=age value=#{12*2}&gt;&lt;/property&gt;  t&lt;!--可以引用其他bean的某个属性值--&gt;  t&lt;property name=name value=#{address.province}&gt;&lt;/property&gt;  t&lt;!--引用其他bean--&gt;  t&lt;property name=address value=#{address}&gt;&lt;/property&gt;  t&lt;!--调用静态方法--&gt;  t&lt;property name=hobbies value=#{T(java.util.UUID).randomUUID().toString().substring(0,4)}&gt;&lt;/property&gt;  t&lt;!--调用非静态方法--&gt;  t&lt;property name=gender value=#{address.getCity()}&gt;&lt;/property&gt; &lt;/bean&gt; 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/21/02-ioc/",
      "keywords" : "Java，Spring"
    } ,
  
    {
      "title"    : "Java Spring 03——注解",
      "category" : "Spring",
      "content": "Java Spring 03——注解 序言 除了使用 xml 文件注册 bean 对象，还可以通过使用注解注册 bean 对象。 两种方式的应用场景都很多，在企业中，往往是将两种方式混合使用的。 使用注解将 bean 对象添加到 IOC 容器中 添加注解 给类添加注解，Spring 会自动把该类添加在 Spring IOC 容器中。    注解  含义  使用场景     @Controller  控制器  推荐给 controller 层添加此注解    @Service  业务逻辑  推荐给业务逻辑层添加此注解    @Repository  仓库管理  推荐给数据访问层添加此注解    @Component  普通组件  给不属于以上基层的组件添加此注解   实际上，Spring 并不会区分这四种注解，它只是单纯地将 bean 对象注册到 IOC 容器中。 我们甚至可以只使用一种注解来注册所有的 bean 对象。 但是为了提高代码的可阅读性，我们根据功能人为地把 bean 对象分成四种类型。 其他注解 注意：当使用注解注册组件和使用配置文件注册组件是一样的，但是要注意：  t1、组件的id默认就是组件的类名首字符小写，如果非要改名字的话，直接在注解中添加即可  t2、组件默认情况下都是单例的,如果需要配置多例模式的话，可以在注解下添加@Scope注解 添加自动扫描组件 在给类添加注解后，我们还需要让 Spring 扫描这些被注解的类并添加到 IOC 容器中。 1 . 导入 context 命名空间。 在 &lt;beans&gt;&lt;/beans&gt; 标签中添加 xmlns:context=http://www.springframework.org/schema/context 并在 &lt;beans&gt;&lt;/beans&gt; 标签的 xsi:schemaLocation 中添加 http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd  2 . 使用 context:component-scan 标签指定要扫描的包。 案例： 以下代码正确地导入了 context 命名空间， 并将扫描 com.kky 包下的所有的类，把被注解的类加载到 IOC 容器中。 applicationContext.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd&gt; &lt;context:component-scan base-package=com.kky&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 排除不需要添加的对象 ... &lt;context:component-scan base-package=com.kky&gt;&lt;/context:component-scan&gt; ... 以上方式会扫描 com.kky 包中的所有类，但如果此时我们需要排除某些对象应该怎么办？ 使用 context 标签自带的过滤器 exclude-filter ... &lt;context:component-scan base-package=com.kky&gt;  t&lt;context:exclude-filter type= expression=/&gt; &lt;/context:component-scan&gt; ... type 表示过滤规则，expression 为表达式 assignable 排除某个具体的类，注意使用完全限定名（包括包名），只能排除单个类。 ... &lt;context:component-scan base-package=com.kky&gt;  t&lt;context:exclude-filter type=assignable expression=com.kky.bean.Student&gt;&lt;/context:exclude-filter&gt; &lt;/context:component-scan&gt; ... 包 com.kky.bean 下的 Student 类将不会被添加到 IOC 容器中。 annotation 排除注解，表达式必须是完全限定名。 前文提到过，有四种将对象注册到 IOC 容器的注解： @Controller @Service @Repository @Component Spring 在扫描这些注解时一视同仁，全部都会加载到 IOC 容器中。 但是此时我们可以搞区别对待，排除某个注解，使它们无法被加载。 ... &lt;context:component-scan base-package=com.kky&gt;  t&lt;context:exclude-filter type=annotation expression=org.springframework.stereotype.Controller&gt;&lt;/context:exclude-filter&gt;  t&lt;context:exclude-filter type=annotation expression=org.springframework.stereotype.Service&gt;&lt;/context:exclude-filter&gt;  t&lt;context:exclude-filter type=annotation expression=org.springframework.stereotype.Repository&gt;&lt;/context:exclude-filter&gt;  t&lt;context:exclude-filter type=annotation expression=org.springframework.stereotype.Component&gt;&lt;/context:exclude-filter&gt; &lt;/context:component-scan&gt; ... 以上将四种注解都排除了。 实际中根据需要，排除对应的注解。 regex 使用正则表达式，一般不用。 正则表达式是个非常复杂的东西，本文中不予讲述。 aspectj 使用切面的方式，一般不用。 custom 使用自定义的方式，可以自定义筛选规则，一般不用。 指定需要添加的对象 一般情况下，我们导入某个包中的所有对象，根据需要排除某些对象。 在 Spring 的语法中，提供了添加额外对象的功能，只不过这种方式很少使用。 ... &lt;context:component-scan base-package=com.kky&gt;  t&lt;context:include-filter type= expression=/&gt; &lt;/context:component-scan&gt; ... 把标签从 exclude-filter 改为 include-filter，type 依然是 assignable annotation regex aspectj custom 五种。 使用方法 新建 PersonController 类并添加 @Controller 注解 package com.kky.controller; import org.springframework.stereotype.Controller; @Controller public class PersonController { } 添加自动扫描组件 applicationContext.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd&gt; &lt;context:component-scan base-package=com.kky&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 测试 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); PersonController personController = context.getBean(personController, PersonController.class); System.out.println(personController); 结果 自动注入 @Autowired 修饰成员变量 用 @Autowired 修饰成员变量的效果是什么？ @Service public class PersonService { public void save() {  System.out.println(personservice);  } } @Controller public class PersonController { private PersonService personService; public void save() {  personService.save();  } } 可以看到，PersonController 类中的某个成员是另一个类 PersonService 的对象。 并且会在 save() 方法调用该对象。 测试 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); PersonController personController = context.getBean(personController, PersonController.class); personController.save(); 结果：空指针 java.lang.NullPointerException ... 这个异常很好理解，因为 personController 中的 personService 并没有初始化。 而通过自动注入，我们可以将成员变量成功赋值为某个 bean 对象。 根据类型自动注入 而如果我们使用了自动注入，即 @Autowired @Controller public class PersonController {  t@Autowired  private PersonService personService; public void save() {  personService.save();  } } 测试 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); PersonController personController = context.getBean(personController, PersonController.class); personController.save(); 结果 personservice 使用了 @Autowired 注解的对象，Spring 会进行自动装配——将该对象装配为 IOC 容器中的 bean 对象。 所以我们要装配的对象，必须通过某种方式加载到 IOC 容器中。 假如我们把 PersonService 类的 @Service 注解去掉。 public class PersonService { public void save() {  System.out.println(personservice);  } } 再次测试结果会报错。 @Autowired 的规则是什么？ 根据类型进行装配。 @Controller public class PersonController {  t@Autowired  private PersonService personService; } 即 Spring 会去寻找 PersonService 类的对象并装配。 规则（以下的寻找是在 IOC 容器中寻找，所以请将对应的类加载到 IOC 容器中）： 如果只存在一个对应类型的 bean 对象，直接进行赋值。 如果找不到对应类型，抛出异常。 当存在多个对应类型的 bean 对象 （现有 A 类和 B 类，A 类是 B 类的父类，两者都加载到了 IOC 容器中，此时 @Autowired 修饰的是 A 类，则会同时寻找到两个 bean 对象） 会根据变量名继续匹配（即 personService）bean 对象的 id。  匹配成功，进行装配。  匹配失败，抛出异常。   根据 id 自动注入 Spring 提供了根据 id 自动注入对应 bean 对象的方式，实际中较少使用。 即 @Qualifier() 注解 @Controller public class PersonController { @Autowired  @Qualifier(personService)  private PersonService personService; public void save() {  personService.save();  } } 这样 Spring 会直接去寻找 id 为 personService 的 bean 对象。 找到，成功装配。 找不到，抛出异常。 修饰方法 用 @Autowired 修饰成员变量时将其自动赋值为 IOC 容器中的某个 bean 对象。 而使用 @Autowired 修饰的方法会怎么样呢？ 会在对象创建时自动调用该方法。 案例： 给 PersonController 类添加新的方法 test() @Controller public class PersonController {  t... @Autowired  public void test() {  System.out.println(test);  } } 测试 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); PersonController personController = context.getBean(personController, PersonController.class); 可以看到，只是创建了 PersonController 类对象，并没有调用任何方法。 结果 test 可以看到，test() 方法被自动调用了。 被 @Autowired 修饰的方法，其形参会被自动注入 新建 PersonDao 类 @Repository public class PersonDao { public void save(){  System.out.println(persondao);  } } 修改 PersonController 类 @Controller public class PersonController {  t... @Autowired  public void test(PersonDao personDao) {  System.out.println(test);  t tpersonDao.save();  } } 我们在形参中添加了 PersonDao 对象并调用其 save() 方法。 测试 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); PersonController personController = context.getBean(personController, PersonController.class); 结果 test persondao 可以看到，并没有创建 PersonDao 对象，但是却成功调用了。 这说明 Spring 为形参执行了自动注入。 此时的形参是根据类型进行自动装配的，原理跟前文中一样。 同样可以根据 id 进行自动装配。 @Controller public class PersonController {  t... @Autowired  public void test(@Qualifier(personDao) PersonDao personDao123) {  System.out.println(test);  t tpersonDao.save();  } } jdk 中的自动装配 @Resource @Autowired 是 Spring 提供的自动装配的注解。 JDK 中也有实现装配的注解，那就是 @Resource。 在上文提到的案例中，把 @Autowired 替换成 @Resource 效果是一样的。 只不过使用 @Resource 需要导入一个包：javax.annotation.Resource 。 JDK1.8 自带这个包的，但是在某个版本之后被删除了（不确定是哪个版本，笔者使用的 JDK 12 是没有这个包的）。 此时需要外部导入这个包，其 Maven 依赖为： &lt;!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api --&gt; &lt;dependency&gt;  t&lt;groupId&gt;javax.annotation&lt;/groupId&gt;  t&lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;  t&lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; @Autowired 和 @Resource 的异同： @Autowired 是 Spring 中提供的注解。 @Resource 是 JDK 中定义的注解，依靠的是 Java 的标准。 @Autowired 默认按照类型进行装配，要求被依赖的对象必须存在。 @Resource 默认按照变量名进行装配，可以使用 @Qualifier() 指定名称。 @Autowired 只适合 Spring 框架，因为装配的是 IOC 容器中的 bean 对象。 @Resource 是基于 Java 实现的，适用于多种框架，扩展性更好。 泛型依赖注入 如何在依赖注入中实现泛型？ 如今的项目开发，一般把项目分为 Model, View, Controller，其中 Model 层分为 entity 层 定义与数据库对应的实体类。 dao 层 调用 entity 层，实现增删改查 service 层 编程的重点，业务逻辑主要集中在这层。 在经过一系列逻辑处理后，调用 dao 层读写数据库。 所以一般来说，数据库每多一张表，就会多出三个类。 例如：现数据库有一张表 student。 entity 层 public class Student { } dao 层 @Repository public class StudentDao extends BaseDao&lt;Student&gt; {  public void save() {  System.out.println(保存学生);  } } service 层 @Service public class StudentService{  @Autowired  StudentDao studentDao; public void save(){  studentDao.save();  } } 调用 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); StudentService studentService = context.getBean(studentService, StudentService.class); studentService.save(); 结果 保存学生 如果现在数据库多了一张表 teacher，那么要编写与之对应的 entity、dao、service 然后又多了一张表…… …… 所以能不能通过泛型，简化代码？ entity 层 public class Student { } public class Teacher { }  dao 层 定义一个 BaseDao 接口，并实现泛型 @Repository public abstract class BaseDao&lt;T&gt; {  public abstract void save(); } 实现接口 @Repository public class StudentDao extends BaseDao&lt;Student&gt; {  public void save() {  System.out.println(保存学生);  } } @Repository public class TeacherDao extends BaseDao&lt;Teacher&gt;{  public void save() {  System.out.println(保存老师);  } }  serivce 层 在 dao 层实现泛型后，service 层可以减少代码量 public class BaseService&lt;T&gt; { @Autowired  private BaseDao&lt;T&gt; baseDao; public void save() {  baseDao.save();  } } @Service public class StudentService extends BaseService&lt;Student&gt;{ } @Service public class TeacherService extends BaseService&lt;Teacher&gt; { } 可以看到 StudentService 和 TeacherService 都是空方法。 因为到时候将通过泛型直接调用 BaseService 的方法。 调用 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); StudentService studentService = context.getBean(studentService, StudentService.class); studentService.save(); TeacherService teacherService = context.getBean(teacherService, TeacherService.class); teacherService.save(); 结果 保存学生 保存老师  可以看到，在实现了泛型后，简化了 service 层的代码。 注意： 没有把握的情况下不要使用泛型编程，直接老实地实现每一张数据表的每一层。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/29/03-annotation/",
      "keywords" : "Java, Spring"
    } ,
  
    {
      "title"    : "Java Spring 04—— AOP 的详细讲解",
      "category" : "Spring",
      "content": "Java Spring 04—— AOP 的详细讲解 序言 要理解 Spring AOP，必须先理解 动态代理。 为什么要引入 AOP？ 先通过以下代码的优化升级来感受动态代理和 AOP 的提出目的。 现在实现一个计算器类，能够实现两个数字的加、减、乘、除。 public class MyCalculator {  public Integer add(Integer i, Integer j) {  return i + j;  } public Integer sub(Integer i, Integer j) {  return i - j;  } public Integer mul(Integer i, Integer j) {  return i * j;  } public Integer div(Integer i, Integer j) {  return i / j;  } } 测试 MyCalculator myCalculator = new MyCalculator(); System.out.println(myCalculator.add(6, 6)); System.out.println(myCalculator.sub(6, 6)); System.out.println(myCalculator.mul(6, 6)); System.out.println(myCalculator.div(6, 6)); 结果 12 0 36 1  输出过于简单，增加一些信息 public class MyCalculator implements Calculator { public Integer add(Integer i, Integer j) {  System.out.println(add 方法开始执行，参数为： + i + , + j);  Integer result = i + j;  System.out.println(add 方法完成，结果为： + result +   );  return result;  } public Integer sub(Integer i, Integer j) {  System.out.println(sub 方法开始执行，参数为： + i + , + j);  Integer result = i - j;  System.out.println(sub 方法完成，结果为： + result +   );  return result;  } public Integer mul(Integer i, Integer j) {  System.out.println(mul 方法开始执行，参数为： + i + , + j);  Integer result = i * j;  System.out.println(mul 方法完成，结果为： + result +   );  return result;  } public Integer div(Integer i, Integer j) {  System.out.println(div 方法开始执行，参数为： + i + , + j);  Integer result = i / j;  System.out.println(div 方法完成，结果为： + result +   );  return result;  } } 测试 MyCalculator myCalculator = new MyCalculator(); myCalculator.add(6, 6); myCalculator.sub(6, 6); myCalculator.mul(6, 6); myCalculator.div(6, 6); 结果 add 方法开始执行，参数为：6,6 add 方法完成，结果为：12 sub 方法开始执行，参数为：6,6 add 方法完成，结果为：0 mult 方法开始执行，参数为：6,6 add 方法完成，结果为：36 div 方法开始执行，参数为：6,6 add 方法完成，结果为：1 四个方法中有大量的重复代码，尝试提取出来，写一个工具类 public class LogUtil01 { public static void start(Method method, Object... objects) {  System.out.println(method.getName() + 方法开始执行，参数是： + Arrays.asList(objects));  } public static void stop(Method method, Object... objects) {  System.out.println(method.getName() + 方法执行结束，结果是： + Arrays.asList(objects) +   );  } public static void logException(Method method, Exception e) {  System.out.print(method.getName() + 方法出现异常：);  e.printStackTrace(System.out);  } public static void end(Method method) {  System.out.println(method.getName() + 方法结束);  } } 修改 MyCalculator 类 public class MyCalculator implements Calculator { public Integer add(Integer i, Integer j) throws NoSuchMethodException {  Method add = MyCalculator.class.getMethod(add, Integer.class, Integer.class);  LogUtil01.start(add, i, j);  Integer result = i + j;  LogUtil01.stop(add, result);  return result;  } public Integer sub(Integer i, Integer j) throws NoSuchMethodException {  Method sub = MyCalculator.class.getMethod(sub, Integer.class, Integer.class);  LogUtil01.start(sub, i, j);  Integer result = i - j;  LogUtil01.stop(sub, result);  return result;  } public Integer mul(Integer i, Integer j) throws NoSuchMethodException {  Method mul = MyCalculator.class.getMethod(mul, Integer.class, Integer.class);  LogUtil01.start(mul, i, j);  Integer result = i * j;  LogUtil01.stop(mul, result);  return result;  } public Integer div(Integer i, Integer j) throws NoSuchMethodException {  Method div = MyCalculator.class.getMethod(div, Integer.class, Integer.class);  LogUtil01.start(div, i, j);  Integer result = i / j;  LogUtil01.stop(div, result);  return result;  } } 测试 MyCalculator myCalculator = new MyCalculator(); myCalculator.add(6, 6); myCalculator.sub(6, 6); myCalculator.mul(6, 6); myCalculator.div(6, 6); 结果 add 方法开始执行，参数是：[6, 6] add 方法执行结束，结果是：[12] sub 方法开始执行，参数是：[6, 6] sub 方法执行结束，结果是：[0] mul 方法开始执行，参数是：[6, 6] mul 方法执行结束，结果是：[36] div 方法开始执行，参数是：[6, 6] div 方法执行结束，结果是：[1] 如果是面向对象编程的话，这样的代码已经很棒了。 但仔细阅读代码，有没有一种切入的感觉？ —— LogUtil01 类的方法像切片一样，切入到了 MyCalculator 类的方法中。 那我能不能把 LogUtil01 类的方法动态性地切入到任何一个类的任何一个方法中？ 何为动态性？ 上文就是静态的，MyCalculator 类调用 LogUtil 类是写入程序中的，是一开始就定好的，执行多少遍，结果都一样。 而如果是动态的，那么程序将在执行过程中，将 LogUtil 类的方法切入到某个类的方法中（程序运行前并未写入该类中）。 这就是 动态代理。 不理解动态代理的同学请戳上方链接，下文直接贴代码。 将 MyCalculator 类还原为最简单的版本 public class MyCalculator {  public Integer add(Integer i, Integer j) {  return i + j;  } public Integer sub(Integer i, Integer j) {  return i - j;  } public Integer mul(Integer i, Integer j) {  return i * j;  } public Integer div(Integer i, Integer j) {  return i / j;  } } Cglib 的动态代理 Cglib 是一个额外的 Jar 包，通过该 Jar 包实现动态代理比较简单，不需要实现接口。 其 Maven 依赖为 &lt;dependency&gt;  t&lt;groupId&gt;cglib&lt;/groupId&gt;  t&lt;artifactId&gt;cglib&lt;/artifactId&gt;  t&lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; public class CglibProxy { public static Object getProxy(Class clz) {  Enhancer enhancer = new Enhancer();  enhancer.setSuperclass(clz);  enhancer.setCallback(new MethodInterceptor() {   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws IOException {    Object result = null;    try {    LogUtil01.start(method, objects);    result = methodProxy.invokeSuper(o,objects);    LogUtil01.stop(method, result);    } catch (Exception e) {    LogUtil01.logException(method, e);    } catch (Throwable throwable) {    throwable.printStackTrace();    } finally {    LogUtil01.end(method);    }    return result1;   }  });  Object proxy = enhancer.create();  return proxy;  } } 测试 MyCalculator proxy = (MyCalculator) CglibProxy.getProxy(MyCalculator.class); proxy.add(6, 6); proxy.sub(6, 6); proxy.mul(6, 6); proxy.div(6, 0); 结果 add 方法开始执行，参数是：[6, 6] add 方法执行结束，结果是：[12] add 方法结束 sub 方法开始执行，参数是：[6, 6] sub 方法执行结束，结果是：[0] sub 方法结束 mul 方法开始执行，参数是：[6, 6] mul 方法执行结束，结果是：[36] mul 方法结束 div 方法开始执行，参数是：[6, 0] div 方法出现异常：java.lang.ArithmeticException: / by zero  t...(此处省略一万行异常信息) div 方法结束 LogUtil 类添加了异常处理，然后调用时进行了 6/0 的操作，成功地处理了除 0 异常。 JDK 自带的动态代理 JDK 本身就能够实现动态代理，只不过需要实现接口。 定义接口 public interface Calculator { public Integer add(Integer i, Integer j) throws NoSuchMethodException; public Integer sub(Integer i, Integer j) throws NoSuchMethodException; public Integer mul(Integer i, Integer j) throws NoSuchMethodException; public Integer div(Integer i, Integer j) throws NoSuchMethodException; } 将 MyCalculator 类实现该接口 public class MyCalculator implements Calculator {  t... } 实现动态代理 public class DynamicProxy { public static Object getProxy(final Object object) {  ClassLoader loader = object.getClass().getClassLoader();  Class&lt;?&gt;[] interfaces = object.getClass().getInterfaces();  InvocationHandler h = new InvocationHandler() {   public Object invoke(Object proxy, Method method, Object[] args) throws IOException {    Object result = null;    try {    LogUtil01.start(method, args);    result = method.invoke(object, args);    LogUtil01.stop(method, result);    } catch (Exception e) {    LogUtil01.logException(method, e);    } finally {    LogUtil01.end(method);    }    return result;   }  };  Object proxy = Proxy.newProxyInstance(loader, interfaces, h);  return proxy;  } } 测试 add 方法开始执行，参数是：[6, 6] add 方法执行结束，结果是：[12] add 方法结束 sub 方法开始执行，参数是：[6, 6] sub 方法执行结束，结果是：[0] sub 方法结束 mul 方法开始执行，参数是：[6, 6] mul 方法执行结束，结果是：[36] mul 方法结束 div 方法开始执行，参数是：[6, 0] div 方法出现异常：java.lang.reflect.InvocationTargetException  t...(此处省略一万行异常信息) div 方法结束 性能差异 使用 Cglib 和 JDK 实现的动态代理有性能上的差异吗？ 在以前，是有差异的，低版本的 JDK 的动态代理性能比不过同期的 Cglib 的动态代理。 但是 Cglib 已经很久没更新了（笔者在 2021.08.02 找到的 Cglib 是 2019.08 的 3.3.0 版）。 而 JDK 一直在更新，也有优化动态代理。 所以高版本的 JDK 的动态代理的性能是不弱于 Cglib 的。 什么是 AOP？ 经过前面的几个案例，我们已经理解了动态代理的作用和好处。 但是以上的方式依然不够好： 需要手写动态代理的源码，比较麻烦。 实现了动态代理后，被代理类的所有方法都会被代理，无法只代理类中的一部分方法。 AOP Aspect Oriented Programming 面向切面编程 OOP Object Oriented Programming 面向对象编程 AOP 是基于 OOP 提出的一种新的编程思想。 现在把执行某个类的某个方法看作一段轨道。 一个程序，会有多个类，每个类又会有多个方法，总共就有许多轨道。 通过 AOP ，我们可以把这些方法的执行过程切开，然后在切开的位置装入额外的功能代码。 这就是面向切面编程——将某段代码动态切入到指定方法的指定位置中去。 上文的动态代理就属于 AOP 的范畴。 把方法的执行过程切分： 在方法开始运行前，切入了 LogUtil01.start() 方法 在方法捕获异常时，切入了 LogUtil01.logException() 方法 在方法得到计算结果后，切入了 LogUtil01.stop() 方法 在方法结束后，切入了 LogUtil01.end() 方法 AOP的核心概念及术语  切面（Aspect）: 指关注点模块化，这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中，切面可以使用通用类基于模式的方式（schema-based approach）或者在普通类中以@Aspect注解（@AspectJ 注解方式）来实现。 连接点（Join point）: 在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中，一个连接点总是代表一个方法的执行。 通知（Advice）: 在切面的某个特定的连接点上执行的动作。通知有多种类型，包括“around”, “before” and “after”等等。通知的类型将在后面的章节进行讨论。 许多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。 切点（Pointcut）: 匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如，当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP的核心：Spring默认使用AspectJ切点语义。 引入（Introduction）: 声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被通知的对象上。例如，可以使用引入来使bean实现 IsModified接口， 以便简化缓存机制（在AspectJ社区，引入也被称为内部类型声明（inter））。 目标对象（Target object）: 被一个或者多个切面所通知的对象。也被称作被通知（advised）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个被代理（proxied）的对象。 AOP代理（AOP proxy）:AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。 织入（Weaving）: 把切面连接到其它的应用程序类型或者对象上，并创建一个被被通知的对象的过程。这个过程可以在编译时（例如使用AspectJ编译器）、类加载时或运行时中完成。 Spring和其他纯Java AOP框架一样，是在运行时完成织入的。 AOP的通知类型  前置通知（Before advice）: 在连接点之前运行但无法阻止执行流程进入连接点的通知（除非它引发异常）。 后置返回通知（After returning advice）:在连接点正常完成后执行的通知（例如，当方法没有抛出任何异常并正常返回时）。 后置异常通知（After throwing advice）: 在方法抛出异常退出时执行的通知。 后置通知（总会执行）（After (finally) advice）: 当连接点退出的时候执行的通知（无论是正常返回还是异常退出）。 环绕通知（Around Advice）:环绕连接点的通知，例如方法调用。这是最强大的一种通知类型，。环绕通知可以在方法调用前后完成自定义的行为。它可以选择是否继续执行连接点或直接返回自定义的返回值又或抛出异常将执行结束。 AOP的应用场景  日志管理 权限认证 安全检查 事务控制 Spring AOP 的简单使用 导入 Jar 包 通过 Maven 添加以下依赖 &lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt; &lt;dependency&gt;  t&lt;groupId&gt;cglib&lt;/groupId&gt;  t&lt;artifactId&gt;cglib&lt;/artifactId&gt;  t&lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt;  t&lt;groupId&gt;org.aspectj&lt;/groupId&gt;  t&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  t&lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/aopalliance/aopalliance --&gt; &lt;dependency&gt;  t&lt;groupId&gt;aopalliance&lt;/groupId&gt;  t&lt;artifactId&gt;aopalliance&lt;/artifactId&gt;  t&lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt; &lt;dependency&gt;  t&lt;groupId&gt;org.springframework&lt;/groupId&gt;  t&lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;  t&lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 编写切面类 LogUtil02 @Aspect @Component public class LogUtil02 { @Before(execution( public Integer com.kky.service.MyCalculator.add( Integer, Integer)))  public static void start() {  System.out.println( 方法开始执行，参数是：);  } @AfterReturning(execution( public Integer com.kky.service.MyCalculator.add( Integer, Integer)))  public static void stop() {  System.out.println( 方法执行完成，结果是：);  } @AfterThrowing(execution( public Integer com.kky.service.MyCalculator.add( Integer, Integer)))  public static void logException() {  System.out.println( 方法出现异常：);  } @After(execution( public Integer com.kky.service.MyCalculator.add( Integer, Integer)))  public static void end() {  System.out.println( 方法结束。  );  } } 简单解析该代码： @Component 将该类注册到 IOC 容器中 @Aspect 指明该类为切面类 通知类型。 表明切入到方法中的哪个位置。 @Before 前置通知 在目标方法之前运行 @After 后置通知 在目标方法之后运行 @AfterReturning 返回通知 在目标方法正常返回之后 @AfterThrowing 异常通知 在目标方法抛出异常后开始运行 @Around 环绕通知 环绕 切入点表达式 execution(访问修饰符 返回值类型 方法全称) 表明切入到什么方法中。 像execution( public Integer com.kky.service.MyCalculator.add( Integer, Integer)) 表示切入 com.kky.service.MyCalculator 类的 public Integer add(Integer i, Integer j) 方法中。 编写配置 请先将前文中的 LogUtil 类添加 @Component 注解 MyCalculator 类添加 @Service 注解 以将它们加载到 IOC 容器中。 然后修改 application.xml 文件 &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xmlns:aop=http://www.springframework.org/schema/aop  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  http://www.springframework.org/schema/aop  http://www.springframework.org/schema/aop/spring-aop.xsd &gt;  &lt;!--开启自动扫描--&gt;  &lt;context:component-scan base-package=com.kky&gt;&lt;/context:component-scan&gt;  &lt;!--开启 aop 的注解功能--&gt;  &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;/beans&gt; 测试 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); Calculator bean = context.getBean(Calculator.class); bean.add(6, 6); 结果 方法开始执行，参数是： 方法执行完成，结果是： 方法结束。 动态代理的类型 前文介绍了两种动态代理： 使用 JDK 实现 使用 Cglib 实现 两者最大的区别在于是否需要接口。 而 Spring AOP 底层原理也是这两种动态代理。 那么到底使用哪种呢？ Spring AOP 会自动选择： 有接口，使用 JDK 实现 无接口，使用 Cglib 实现 看上去很方便对吧，无论有没有接口，我们使用 Spring AOP 的方法都是一样的，不需要关心细节。 唯一有一点要注意： 当使用接口时，从 IOC 容器中取对象时必须使用接口类型！ @Service public class MyCalculator implements Calculator {  t... } 可以看到，此时的 MyCalculator 类继承于 Calculator 接口，Spring AOP 会自动使用 JDK 来实现动态代理。 此时调用动态代理必须使用如下方式： ... Calculator bean = context.getBean(Calculator.class); ... 使用的是 Calculator.class 如果是这样 ... MyCalculator bean = context.getBean(MyCalculator.class); ... 则会报错 org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.kky.service.MyCalculator' available ... 找不到该类，说明 IOC 容器注册该 bean 对象时使用的是接口的类型。 详解 Spring AOP 上文只是简单地介绍了 Spring AOP 如何使用。 这里对其做出详解。 切入点表达式 execution(public Integer com.kky.service.MyCalculator.add(Integer,Integer)) 这是最精准的匹配方式，规定了修饰符、返回值、完全限定名、方法名、形参。 这种匹配方式至多匹配到一个方法，是最准确的。 但是在实际中，我们并不需要这么准确，因为一对一意味着代码量的增加。 我们更希望实现一对多，所以有了通配符。 通配符有两种： * 和 .. 通配符 * 号 匹配一个或者多个字符 execution( public Integer com.kky.service.MyCalculator.a*( Integer, Integer))  可匹配所有以 a 开头的方法，包括 ab, ac, abc, add… execution( public Integer com.kky.service.MyCalculator.*( Integer, Integer))  匹配所有方法。 对于类名和包名同样有效。 匹配任意类型的参数 execution( public Integer com.kky.service.MyCalculator.add( Integer, *))  第二个参数的类型将不做限制 匹配路径 当使用 * 匹配路径时，根据使用方法不同，其效果也不同  匹配多层路径    只有 *   execution( public Integer *( Integer, Integer))     将匹配所有类的所有方法。    * + 方法名   execution( public Integer *.add( Integer, Integer))     匹配所有类的 add 方法      匹配单层路径 除了以上两种使用方法，* 只能匹配单层路径，例如   execution( public Integer *.MyCalculator.add( Integer, *))   只能匹配最外层路径下的 MyCalculator 类，而 com.kky.service.MyCalculator 类是匹配不到的。   匹配返回值 execution( public * com.kky.service.MyCalculator.add( Integer, Integer))  可匹配所有的返回值 * 不能用于匹配修饰符。 如果有需要，请直接省略修饰符。 execution( Integer com.kky.service.MyCalculator.add( Integer, Integer))  此时将匹配所有的修饰符 .. （两个点） 可匹配参数，其数量和类型不限。 execution( public Integer com.kky.service.MyCalculator.add(..))  此时参数列表没有限制 匹配多层路径 execution( public Integer com..MyCalculator.add( Integer, Integer))  此时可以匹配到 com.kky.service.MyCalculator 总结 通配符的功能很强大，请根据需要，合理地制定匹配规则。 当需要为所有类的所有方法增加动态代理时，可以使用以下最偷懒的方式： execution( * *(..)) 逻辑运算 &amp;&amp; || ! 表达式除了使用通配符扩大匹配范围，更可以使用逻辑运算。 其运算和 Java 中的逻辑运算一样。  &amp;&amp; 同时满足两个表达式  execution( public Integer com.kky.service.MyCalculator.a*( Integer, Integer)) &amp;&amp; execution( public Integer com.kky.service.MyCalculator.*d( Integer, Integer))  匹配名称以 a 开头，以 d 结尾的方法 || 满足一个表达式即可 ! 除了这个表达式外的地方都可以切入 抽取表达式 可以看到，表达式是有重复性的，往往一个切面类中所有通知的表达式都是同一个。 此时可以对表达式进行抽取，简化代码。  声明一个空方法并添加 @PointCut 注解 用该方法替换通知中的表达式 ```java @Aspect @Component public class LogUtil02 { @PointCut(execution( public Integer com.kky.service.MyCalculator.add( Integer, Integer)))  public void myPointCut(){} @Before(myPointCut())  public static void start() {  System.out.println( 方法开始执行，参数是：);  } @AfterReturning(myPointCut())  public static void stop() {  System.out.println( 方法执行完成，结果是：);  } @AfterThrowing(myPointCut())  public static void logException() {  System.out.println( 方法出现异常：);  } @After(myPointCut())  public static void end() {  System.out.println( 方法结束。  );  } } 通知的执行顺序sdfasdfqwer 2、通知方法的执行顺序 在之前的代码中大家一直对通知的执行顺序有疑问，其实执行的结果并没有错，大家需要注意： 1、正常执行：@Before---&gt;@After---&gt;@AfterReturning 2、异常执行：@Before---&gt;@After---&gt;@AfterThrowing 如何定义通知方法的参数 通知方法在定义时对于访问修饰符、返回值都没有明确要求。 无论是 public 还是 private ，通知方法都能够被调用。 无论写不写返回值都不影响返回值的功能，一般不写。 但是通知方法对于参数的要求特别严格，需要严格地遵照规范。 JoinPoint JoinPoint 可直接写入通知方法的参数列表，其包含了有关于被切入的方法的相关信息。 常用于获取方法名称和参数。 @Component @Aspect public class LogUtil { @PointCut(execution( public Integer com.kky.service.MyCalculator.add( Integer, Integer)))  public void myPointCut(){} @Before(myPointCut())  public static void start(JoinPoint joinPoint){  String name = joinPoint.getSignature().getName();  Object[] args = joinPoint.getArgs();  System.out.println(name+ 方法开始执行，参数是：+ Arrays.asList(args));  } @AfterReturning(myPointCut())  public static void stop(JoinPoint joinPoint) {  System.out.println(joinPoint.getSignature().getName() +   方法执行完成，结果是：);  } @AfterThrowing(myPointCut())  public static void logException(JoinPoint joinPoint) {  System.out.println(joinPoint.getSignature().getName() + 方法出现异常：);  } @After(myPointCut())  public static void end(JoinPoint joinPoint) {  System.out.println(joinPoint.getSignature().getName() + 方法结束。);  } } 测试 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); Calculator bean = context.getBean(Calculator.class); bean.add(6, 6); 结果 add 方法开始执行，参数是：[6, 6] add 方法结束。 add 方法执行完成，结果是： 成功获取到了方法名和参数，但是没有返回值。 配置注解的参数 五种注解可以配置的参数如下    @Before()  @AfterReturning  @AfterThrowing  @After  @Round     value  value  value  value  value    argName  argName  argName  argName  argName       pointcut  pointcut             returning  throwing         value value 就是切入点表达式。 当注解中只有切入点表达式时 value 可以省略。 当注解中有其他参数时需要显式地写出 value 以区分。 @Component @Aspect public class LogUtil { @PointCut(execution( public Integer com.kky.service.MyCalculator.add( Integer, Integer)))  public void myPointCut(){} @Before(value = myPointCut())  public static void start(JoinPoint joinPoint){  t tString name = joinPoint.getSignature().getName();  Object[] args = joinPoint.getArgs();  System.out.println(name+ 方法开始执行，参数是：+ Arrays.asList(args));  } ... } argName argName 用于配置被切入方法的参数。 @Component @Aspect public class LogUtil { @PointCut(execution( public Integer com.kky.service.MyCalculator.add( Integer, Integer)))  public void myPointCut(){} @Before(value = myPointCut() &amp;&amp; args(i,j), argNames = i,j)  public static void start(Integer i, Integer j) {  System.out.println( 方法开始执行，参数是： + i + , + j);  } ... }  首先要在 value 里配置 args(i,j)  强制限定匹配的方法只有两个参数。 因为 Spring 需要通过限制方法参数来确定匹配的方法是哪一个。  给参数起别名，为了之后的调用。   在注解中添加 argNames 参数。 在通知方法中写入参数。 注意： 这三个地方必须一致！ 测试： ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); Calculator bean = context.getBean(Calculator.class); bean.add(6, 6); 结果 方法开始执行，参数是：6,6 ... pointcut pointcut 的功能和 value 的功能是一样的，都用于配置切入点表达式，一般不用。 returning 用于获取方法的返回值 在 @AfterReturning 注解中添加 returning 参数，并写入方法形参。 @Aspect @Component public class LogUtil02 { ...  t  @AfterReturning(value = execution( public Integer com.kky.service.MyCalculator.*(Integer,Integer)), returning = result)  public static void stop(JoinPoint joinPoint, Object result) {  System.out.println(joinPoint.getSignature().getName() + 方法执行完成，结果是： + result);  } ... } 重新测试结果 ... add 方法执行完成，结果是：12 throwing 获取异常信息 在 @AfterThrowing 注解中添加 throwing 参数，并写入方法形参。 @Aspect @Component public class LogUtil02 { ...  t@AfterThrowing(value = execution( public Integer com.kky.service.MyCalculator.*(Integer,Integer)), throwing = e)  tpublic static void logException(JoinPoint joinPoint, Exception e) {  t tSystem.out.println(joinPoint.getSignature().getName() + 方法出现异常： + e);  t} ... } 测试除 0 异常 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); Calculator bean = context.getBean(Calculator.class); bean.div(6, 0); 结果 ... div 方法出现异常：java.lang.ArithmeticException: / by zero java.lang.ArithmeticException: / by zero ...(此处省略异常详情) 6、环绕通知的使用 LogUtil.java package com.mashibing.util; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.springframework.stereotype.Component; import java.util.Arrays; @Component @Aspect public class LogUtil {  @Pointcut(execution( public int com.kky.services.MyCalculator.*(int,int)))  public void myPoint(){}  /** * 环绕通知是spring中功能最强大的通知 * @param proceedingJoinPoint * @return */  @Around(myPoint())  public Object myAround(ProceedingJoinPoint proceedingJoinPoint){  Object[] args = proceedingJoinPoint.getArgs();  String name = proceedingJoinPoint.getSignature().getName();  Object proceed = null;  try {   System.out.println(环绕前置通知:+name+方法开始，参数是+Arrays.asList(args));   //利用反射调用目标方法，就是method.invoke()   proceed = proceedingJoinPoint.proceed(args);   System.out.println(环绕返回通知:+name+方法返回，返回值是+proceed);  } catch (Throwable e) {   System.out.println(环绕异常通知+name+方法出现异常，异常信息是：+e);  }finally {   System.out.println(环绕后置通知+name+方法结束);  }  return proceed;  } } 总结：环绕通知的执行顺序是优于普通通知的，具体的执行顺序如下： 环绕前置–&gt;普通前置–&gt;目标方法执行–&gt;环绕正常结束/出现异常–&gt;环绕后置–&gt;普通后置–&gt;普通返回或者异常。 但是需要注意的是，如果出现了异常，那么环绕通知会处理或者捕获异常，普通异常通知是接收不到的，因此最好的方式是在环绕异常通知中向外抛出异常。 多切面类的运行顺序 如果要执行多个切面类，顺序是怎样的？ 默认情况下，根据类名的字典序 升序执行。 假如现有切面类 AAspect 和 BAspect 此时先执行 AAspect ，再执行 BAspect 具体的执行流程是这样的 graph TD; A1[AAspect @Before] --&gt; B1(BAspect @Before) B1 --&gt; Z((核心逻辑)) Z --&gt; B2(BAspect @AfterReturning&lt;br&gt;或 BAspect @AfterThrowing) B2 --&gt; B3(BAspect @After) B3 --&gt; A2[AAspect @AfterReturning&lt;br&gt;或 AAspect @AfterThrowing] A2 --&gt; A3[AAspect @After] 根据名称进行排序肯定不是我们想要的方式，所以可以使用 @Order 注解改变顺序。 先执行数值小的切面类。 @Aspect @Component @Order(200) public class AAspect{  t... } @Aspect @Component @Order(100) public class BAspect{  t... } 此时就是先执行 BAspect，再执行 AAspect 如果需要添加环绕通知呢，具体的执行顺序又会是什么顺序呢？ 因为环绕通知在进行添加的时候，是在切面层引入的，所以在哪个切面添加环绕通知，那么就会在哪个切面执行。 3、基于配置的AOP配置 之前我们讲解了基于注解的AOP配置方式，下面我们开始讲一下基于xml的配置方式，虽然在现在的企业级开发中使用注解的方式比较多，但是你不能不会，因此需要简单的进行配置，注解配置快速简单，配置的方式共呢个完善。 1、将所有的注解都进行删除 2、添加配置文件 aop.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xmlns:aop=http://www.springframework.org/schema/aop  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  http://www.springframework.org/schema/aop  https://www.springframework.org/schema/aop/spring-aop.xsd &gt; &lt;context:component-scan base-package=com.mashibing&gt;&lt;/context:component-scan&gt;  &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;bean id=logUtil class=com.mashibing.util.LogUtil2&gt;&lt;/bean&gt;  &lt;bean id=securityAspect class=com.mashibing.util.SecurityAspect&gt;&lt;/bean&gt;  &lt;bean id=myCalculator class=com.kky.services.MyCalculator&gt;&lt;/bean&gt;  &lt;aop:config&gt;  &lt;aop:pointcut id=globalPoint expression=execution(public int com.kky.services.MyCalculator.*(int,int))/&gt;  &lt;aop:aspect ref=logUtil&gt;   &lt;aop:pointcut id=mypoint expression=execution(public int com.kky.services.MyCalculator.*(int,int))/&gt;   &lt;aop:before method=start pointcut-ref=mypoint&gt;&lt;/aop:before&gt;   &lt;aop:after method=end pointcut-ref=mypoint&gt;&lt;/aop:after&gt;   &lt;aop:after-returning method=stop pointcut-ref=mypoint returning=result&gt;&lt;/aop:after-returning&gt;   &lt;aop:after-throwing method=logException pointcut-ref=mypoint throwing=exception&gt;&lt;/aop:after-throwing&gt;   &lt;aop:around method=myAround pointcut-ref=mypoint&gt;&lt;/aop:around&gt;  &lt;/aop:aspect&gt;  &lt;aop:aspect ref=securityAspect&gt;   &lt;aop:before method=start pointcut-ref=globalPoint&gt;&lt;/aop:before&gt;   &lt;aop:after method=end pointcut-ref=globalPoint&gt;&lt;/aop:after&gt;   &lt;aop:after-returning method=stop pointcut-ref=globalPoint returning=result&gt;&lt;/aop:after-returning&gt;   &lt;aop:after-throwing method=logException pointcut-ref=globalPoint throwing=exception&gt;&lt;/aop:after-throwing&gt;   &lt;aop:around method=myAround pointcut-ref=mypoint&gt;&lt;/aop:around&gt;  &lt;/aop:aspect&gt;  &lt;/aop:config&gt; &lt;/beans&gt; Spring AOP 一共有五种通知，可以分为两类： 普通通知  前置通知  后置返回通知  后置异常通知  后置通知   环绕通知 在这里先讲解普通通知，再讲解环绕通知。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/07/31/04-aop/",
      "keywords" : "Java, Spring"
    } ,
  
    {
      "title"    : "Java Spring 05—— AOP 的高级应用",
      "category" : "Spring",
      "content": "Java Spring 05—— AOP 的高级应用 Spring JdbcTemplate 在 Spring 中为了更加方便的操作 JDBC，在 JDBC 的基础之上定义了一个抽象层。 此设计的目的是为不同类型的 JDBC 操作提供模板方法，每个模板方法都能控制整个过程，并允许覆盖过程中的特定任务。 通过这种方式，可以尽可能保留灵活性，将数据库存取的工作量讲到最低。 环境配置 添加 pom 依赖 pom.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;project xmlns=http://maven.apache.org/POM/4.0.0  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt;  &lt;artifactId&gt;spring_demo&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt;  &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-context&lt;/artifactId&gt;   &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;  &lt;dependency&gt;   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;   &lt;artifactId&gt;druid&lt;/artifactId&gt;   &lt;version&gt;1.1.21&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;  &lt;dependency&gt;   &lt;groupId&gt;mysql&lt;/groupId&gt;   &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;   &lt;version&gt;5.1.47&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;  &lt;dependency&gt;   &lt;groupId&gt;cglib&lt;/groupId&gt;   &lt;artifactId&gt;cglib&lt;/artifactId&gt;   &lt;version&gt;3.3.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;   &lt;version&gt;1.9.5&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/aopalliance/aopalliance --&gt;  &lt;dependency&gt;   &lt;groupId&gt;aopalliance&lt;/groupId&gt;   &lt;artifactId&gt;aopalliance&lt;/artifactId&gt;   &lt;version&gt;1.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;   &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;/dependencies&gt; &lt;/project&gt;  编写数据库连接的配置文件 dbconfig.properties jdbc.username=root123 password=123456 url=jdbc:mysql://localhost:3306/demo driverClassName=com.mysql.jdbc.Driver  通过 xml 文件导入 dataSource 对象 applicationContext.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xmlns:aop=http://www.springframework.org/schema/aop  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  http://www.springframework.org/schema/aop  https://www.springframework.org/schema/aop/spring-aop.xsd &gt;  &lt;context:property-placeholder location=classpath:dbconfig.properties&gt;&lt;/context:property-placeholder&gt;  &lt;bean id=dataSource class=com.alibaba.druid.pool.DruidDataSource&gt;  &lt;property name=username value=${jdbc.username}&gt;&lt;/property&gt;  &lt;property name=password value=${jdbc.password}&gt;&lt;/property&gt;  &lt;property name=url value=${jdbc.url}&gt;&lt;/property&gt;  &lt;property name=driverClassName value=${jdbc.driverClassName}&gt;&lt;/property&gt;  &lt;/bean&gt; &lt;/beans&gt;  测试 ApplicationContext context = new ClassPathXmlApplicationContext(jdbcTemplate.xml); DruidDataSource dataSource = context.getBean(dataSource, DruidDataSource.class); System.out.println(dataSource.getConnection()); } 结果 com.mysql.jdbc.JDBC4Connection@611889f4 成功地使用 druid 与 mysql 建立了连接。 添加 JdbcTemplate 对象 添加 pom 依赖 pom.xml &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt; &lt;dependency&gt;  t&lt;groupId&gt;org.springframework&lt;/groupId&gt;  t&lt;artifactId&gt;spring-orm&lt;/artifactId&gt;  t&lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt;  在 xml 文件中添加 JdbcTemplate 对象 applicationContext.xml ... &lt;context:property-placeholder location=classpath:dbconfig.properties&gt;&lt;/context:property-placeholder&gt; &lt;bean id=dataSource class=com.alibaba.druid.pool.DruidDataSource&gt;  t&lt;property name=username value=${jdbc.username}&gt;&lt;/property&gt;  t&lt;property name=password value=${jdbc.password}&gt;&lt;/property&gt;  t&lt;property name=url value=${jdbc.url}&gt;&lt;/property&gt;  t&lt;property name=driverClassName value=${jdbc.driverClassName}&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=jdbcTemplate class=org.springframework.jdbc.core.JdbcTemplate&gt;  t&lt;constructor-arg name=dataSource ref=dataSource&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; ... 在创建 JdbcTemplate 对象必须传入一个 dataSource 对象。 测试 ApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); JdbcTemplate jdbcTemplate = context.getBean(jdbcTemplate, JdbcTemplate.class); System.out.println(jdbcTemplate); 结果 org.springframework.jdbc.core.JdbcTemplate@37858383 成功创建了 JdbcTemplate 对象 使用 JdbcTemplate 对象读写数据 使用 JdbcTemplate 对象读写数据非常地方便。 我们只需要定义 sql 语句即可，其他细节 Spring 会帮我们自动完成。 插入单条数据 ApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); JdbcTemplate jdbcTemplate = context.getBean(jdbcTemplate, JdbcTemplate.class); String sql = insert into emp(empno,ename) values(?,?); int result = jdbcTemplate.update(sql, 1111, zhangsan); System.out.println(result); 是不是很方便，只需要写 sql 语句，然后直接调用 JdbcTemplate 的方法执行 sql 语句即可。 插入批量数据 ApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); JdbcTemplate jdbcTemplate = context.getBean(jdbcTemplate, JdbcTemplate.class); String sql = insert into emp(empno,ename) values(?,?); List&lt;Object[]&gt; list = new ArrayList&lt;Object[]&gt;(); list.add(new Object[]{1,zhangsan1}); list.add(new Object[]{2,zhangsan2}); list.add(new Object[]{3,zhangsan3}); int[] result = jdbcTemplate.batchUpdate(sql, list); for (int i : result) {  tSystem.out.println(i); } 查询单个对象 ApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); JdbcTemplate jdbcTemplate = context.getBean(jdbcTemplate, JdbcTemplate.class); String sql = select * from emp where empno = ?; Emp emp = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class), 7369); System.out.println(emp); 注：Emp 是与数据表 emp 对应的实体类。 查询多个对象 ApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); JdbcTemplate jdbcTemplate = context.getBean(jdbcTemplate, JdbcTemplate.class); String sql = select * from emp where sal &gt; ?; List&lt;Emp&gt; query = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Emp.class), 1500); for (Emp emp : query) {  tSystem.out.println(emp); } 执行组合函数 ApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); JdbcTemplate jdbcTemplate = context.getBean(jdbcTemplate, JdbcTemplate.class); String sql = select max(sal) from emp; Double aDouble = jdbcTemplate.queryForObject(sql, Double.class); System.out.println(aDouble); 8、使用具备具名函数的JdbcTemplate jdbcTemplate.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xmlns:aop=http://www.springframework.org/schema/aop  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  http://www.springframework.org/schema/aop  https://www.springframework.org/schema/aop/spring-aop.xsd &gt;  &lt;context:property-placeholder location=classpath:dbconfig.properties&gt;&lt;/context:property-placeholder&gt;  &lt;bean id=dataSource class=com.alibaba.druid.pool.DruidDataSource&gt;  &lt;property name=username value=${jdbc.username}&gt;&lt;/property&gt;  &lt;property name=password value=${jdbc.password}&gt;&lt;/property&gt;  &lt;property name=url value=${jdbc.url}&gt;&lt;/property&gt;  &lt;property name=driverClassName value=${jdbc.driverClassName}&gt;&lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=jdbcTemplate class=org.springframework.jdbc.core.JdbcTemplate&gt;  &lt;constructor-arg name=dataSource ref=dataSource&gt;&lt;/constructor-arg&gt;  &lt;/bean&gt;  &lt;bean id=namedParameterJdbcTemplate class=org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&gt;  &lt;constructor-arg name=dataSource ref=dataSource&gt;&lt;/constructor-arg&gt;  &lt;/bean&gt; &lt;/beans&gt; MyTest.java ApplicationContext context = new ClassPathXmlApplicationContext(applicationContext.xml); JdbcTemplate jdbcTemplate = context.getBean(jdbcTemplate, JdbcTemplate.class); import java.sql.SQLException; import java.util.HashMap; import java.util.List; import java.util.Map; public class MyTest {  public static void main(String[] args) throws SQLException {  ApplicationContext context = new ClassPathXmlApplicationContext(jdbcTemplate.xml);  NamedParameterJdbcTemplate jdbcTemplate = context.getBean(namedParameterJdbcTemplate, NamedParameterJdbcTemplate.class);  String sql = insert into emp(empno,ename) values(:empno,:ename);  Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();  map.put(empno,2222);  map.put(ename,sili);  int update = jdbcTemplate.update(sql, map);  System.out.println(update);  } } 9、整合EmpDao jdbcTemplate.xml &lt;context:component-scan base-package=com.mashibing&gt;&lt;/context:component-scan&gt; EmpDao.java package com.mashibing.dao; import com.mashibing.bean.Emp; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; public class EmpDao { @Autowired  private JdbcTemplate jdbcTemplate; public void save(Emp emp){  String sql = insert into emp(empno,ename) values(?,?);  int update = jdbcTemplate.update(sql, emp.getEmpno(), emp.getEname());  System.out.println(update);  } } MyTest.java import com.mashibing.bean.Emp; import com.mashibing.dao.EmpDao; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate; import java.sql.SQLException; import java.util.HashMap; import java.util.Map; public class MyTest {  public static void main(String[] args) throws SQLException {  ApplicationContext context = new ClassPathXmlApplicationContext(jdbcTemplate.xml);  EmpDao empDao = context.getBean(empDao, EmpDao.class);  empDao.save(new Emp(3333,wangwu));  } } 声明式事务 现有某 service 类 ，调用某 dao ，执行了一系列 SQL 操作，此时如何为其添加事务支持？ @Service public class AService { @Autowired  ADao aDao; public void aMethod(...){  t taDao.select(...);  t taDao.update(...);  t taDao.insert(...);  t taDao.delete(...);  t t...  } } 总结：在事务控制方面，主要有两个分类： 编程式事务：在代码中直接加入处理事务的逻辑，可能需要在代码中显式调用beginTransaction()、commit()、rollback()等事务管理相关的方法 声明式事务：在方法的外部添加注解或者直接在配置文件中定义，将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。spring的AOP恰好可以完成此功能：事务管理代码的固定模式作为一种横切关注点，通过AOP方法模块化，进而实现声明式事务。 2、声明式事务的简单配置 Spring从不同的事务管理API中抽象出了一整套事务管理机制，让事务管理代码从特定的事务技术中独立出来。开发人员通过配置的方式进行事务管理，而不必了解其底层是如何实现的。 Spring的核心事务管理抽象是PlatformTransactionManager。它为事务管理封装了一组独立于技术的方法。无论使用Spring的哪种事务管理策略(编程式或声明式)，事务管理器都是必须的。 事务管理器可以以普通的bean的形式声明在Spring IOC容器中。下图是spring提供的事务管理器 1、在配置文件中添加事务管理器 jdbcTemplate.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xmlns:aop=http://www.springframework.org/schema/aop  xmlns:tx=http://www.springframework.org/schema/tx  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  http://www.springframework.org/schema/aop  https://www.springframework.org/schema/aop/spring-aop.xsd  http://www.springframework.org/schema/tx  https://www.springframework.org/schema/tx/spring-tx.xsd &gt;  &lt;context:component-scan base-package=com.mashibing&gt;&lt;/context:component-scan&gt;  &lt;context:property-placeholder location=classpath:dbconfig.properties&gt;&lt;/context:property-placeholder&gt;  &lt;bean id=dataSource class=com.alibaba.druid.pool.DruidDataSource&gt;  &lt;property name=username value=${jdbc.username}&gt;&lt;/property&gt;  &lt;property name=password value=${jdbc.password}&gt;&lt;/property&gt;  &lt;property name=url value=${jdbc.url}&gt;&lt;/property&gt;  &lt;property name=driverClassName value=${jdbc.driverClassName}&gt;&lt;/property&gt;  &lt;/bean&gt;  &lt;bean id=jdbcTemplate class=org.springframework.jdbc.core.JdbcTemplate&gt;  &lt;constructor-arg name=dataSource ref=dataSource&gt;&lt;/constructor-arg&gt;  &lt;/bean&gt;  &lt;!--事务控制--&gt;  &lt;!--配置事务管理器的bean--&gt;  &lt;bean id=transactionManager class=org.springframework.jdbc.datasource.DataSourceTransactionManager&gt;  &lt;property name=dataSource ref=dataSource&gt;&lt;/property&gt;  &lt;/bean&gt;  &lt;!--开启基于注解的事务控制模式，依赖tx名称空间--&gt;  &lt;tx:annotation-driven transaction-manager=transactionManager&gt;&lt;/tx:annotation-driven&gt; &lt;/beans&gt; 添加注解 @Service public class AService { @Autowired  ADao aDao; @Transactional  public void aMethod(...){  t taDao.select(...);  t taDao.update(...);  t taDao.insert(...);  t taDao.delete(...);  t t...  } } 配置事务属性 事务详解 传播特性 当某个事务调用了另一个事务，此时它们之间的关系是怎样的？ 传播特性就是用于处理这个的。    传播属性  描述     REQUIRED  如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行    REQUIRES_NEW       SUPPORTS       NOT_SUPPORTED       MANDATORY       NEVER       NESTED      @Service public class AService { @Autowired  ADao aDao;  t@Transactional(propagation = Propagation.XXX, rollbackFor = {Exception.class})  public void methodA() throws Exception {  t taDao.update();  t taDao.update();  }  t  t@Transactional(propagation = Propagation.XXX, rollbackFor = {Exception.class})  public void methodB() throws Exception{  t taDao.update();  t taDao.update();  } } @Service public class MulService { @Autowired  private AService aService; @Transactional  public void mul() throws Exception {  aService.methodA();  aService.methodB();  }  t } 有异常都回滚 REQUIRES_NEW 详解 REQUIRED, REQUIRES_NEW, NESTED 这三个传播特性的描述很类似，它们具体有什么不同呢？ 情况一 @Service public class AService { @Autowired  ADao aDao;  t@Transactional(propagation = Propagation.REQUIRES_NEW, rollbackFor = {Exception.class})  public void methodA() {  t taDao.update();  t taDao.update();  throw new Exception();  }  t  t@Transactional  public void methodB() {  t taDao.update();  t taDao.update();  } } @Service public class MulService { @Autowired  private AService aService; @Transactional  public void mul() {  t ttry{  t t taService.methodA();  t t}catch (Exception e){   e.printStackTrace();  t t}  aService.methodB();  }  t } methodA() 抛出的异常被捕获了，methodB() 会回滚吗？ 会！ 如果 methodA() 的传播级别为 REQUIRES_NEW 和 NESTED，methodB() 不会回滚！ 隔离级别 可设置事务的 隔离级别 使用所连接数据库默认的隔离级别 @Transactional(isolation = Isolation.DEFAULT) 读未提交 @Transactional(isolation = Isolation.READ_UNCOMMITTED) 读已提交 @Transactional(isolation = Isolation.READ_COMMITTED) 可重复读 @Transactional(isolation = Isolation.REPEATABLE_READ) 序列化 @Transactional(isolation = Isolation.SERIALIZABLE) 设置超时 可通过设置 timeout 属性来设置超时，单位为秒。 当事务执行时间超时后，将自动终止该事务并回滚。 @Transactional(timeout = 3) 如果该事务执行时间超过 3s，自动失败并回滚。 只读事务 可通过设置 readonly 属性来设置是否是只读事务，默认否。  执行一条查询语句 不需要开启事务，数据库默认支持 SQL 执行期间的读一致性。 执行多条查询语句 此时必须开启事务，保证整体的读一致性。 当事务内只有读操作时，可设置该事务为只读事务。 此时数据库将阻止其他事务修改数据。 并且因为是只读事务，不存在数据修改，数据库会提供一些优化手段来加快读取速度。 @Transactional(readOnly = true) 异常处理 当事务执行过程中发生异常时，默认情况下 RunTimeExpcetion 及其子类会自动回滚 其他异常不会自动回滚 除此之外，我们可以手动配置处理异常时的回滚问题  声明哪些异常不需要回滚  noRollbackFor 填写 class 对象，使用 {}   @Transactional(noRollbackFor = {FileNotFoundException.class})     noRollbackForClassName 填写完整类名，使用 “”   @Transactional(noRollbackForClassName = java.io.FileNotFoundException)     声明哪些异常需要回滚  rollbackFor 填写 class 对象，使用 {}   @Transactional(rollbackFor = {FileNotFoundException.class})     rollbackForClassName 填写完整类名，使用 “”   @Transactional(rollbackForClassName = java.io.FileNotFoundException)     9、事务的传播特性 事务的传播特性指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行？ spring的事务传播行为一共有7种： 10、测试事务的传播特性 BookDao.java package com.mashibing.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repositorypublic class BookDao { @Autowired JdbcTemplate jdbcTemplate; /**  * 减去某个用户的余额  * @param userName  * @param price  */ public void updateBalance(String userName,int price){  String sql = update account set balance=balance-? where username=?;  jdbcTemplate.update(sql,price,userName); } /**  * 按照图书的id来获取图书的价格  * @param id  * @return  */ public int getPrice(int id){  String sql = select price from book where id=?;  return jdbcTemplate.queryForObject(sql,Integer.class,id); } /**  * 减库存，减去某本书的库存  * @param id  */ public void updateStock(int id){  String sql = update book_stock set stock=stock-1 where id=?;  jdbcTemplate.update(sql,id); } /**  * 修改图书价格  * @param id  * @param price  */ public void updatePrice(int id,int price){  String sql = update book set price=? where id =?;  jdbcTemplate.update(sql,price,id); }} BookService.java package com.mashibing.service;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Service;  import org.springframework.transaction.annotation.Isolation;  import org.springframework.transaction.annotation.Propagation;  import org.springframework.transaction.annotation.Transactional;  import java.io.File;  import java.io.FileInputStream;  import java.io.FileNotFoundException;@Servicepublic class BookService { @Autowired BookDao bookDao; /**  * 结账：传入哪个用户买了哪本书  * @param username  * @param id  */ @Transactional(propagation = Propagation.REQUIRED) public void checkout(String username,int id) {  bookDao.updateStock(id);  int price = bookDao.getPrice(id);  bookDao.updateBalance(username,price); } @Transactional(propagation = Propagation.REQUIRED) public void updatePrice(int id,int price){  bookDao.updatePrice(id,price);  int i = 1/0; }} MulService.java package com.mashibing.service;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class MulService { @Autowired private BookService bookService; @Transactional public void mulTx(){  bookService.checkout(zhangsan,1);  bookService.updatePrice(1,1000); }} MyTest.java import com.mashibing.service.MulService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest { public static void main(String[] args) {  ApplicationContext context = new ClassPathXmlApplicationContext(jdbcTemplate.xml);  MulService mulService = context.getBean(mulService, MulService.class);  mulService.mulTx(); }} 通过上图的结果发现，如果设置的传播特性是Required，那么所有的事务都会统一成一个事务，一旦发生错误，所有的数据都要进行回滚。 BookService.java package com.mashibing.service;  import com.mashibing.dao.BookDao;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Service;  import org.springframework.transaction.annotation.Isolation;  import org.springframework.transaction.annotation.Propagation;  import org.springframework.transaction.annotation.Transactional;  import java.io.File;  import java.io.FileInputStream;  import java.io.FileNotFoundException;@Servicepublic class BookService { @Autowired BookDao bookDao; /**  * 结账：传入哪个用户买了哪本书  * @param username  * @param id  */ @Transactional(propagation = Propagation.REQUIRES_NEW) public void checkout(String username,int id) {  bookDao.updateStock(id);  int price = bookDao.getPrice(id);  bookDao.updateBalance(username,price); } @Transactional(propagation = Propagation.REQUIRED) public void updatePrice(int id,int price){  bookDao.updatePrice(id,price);  int i = 1/0; }} 通过修改checkout方法的传播特性为Required_new,发现价格进行了回滚，而其他的数据没有进行回滚。 BookService.java package com.mashibing.service;  import com.mashibing.dao.BookDao;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Service;  import org.springframework.transaction.annotation.Isolation;  import org.springframework.transaction.annotation.Propagation;  import org.springframework.transaction.annotation.Transactional;  import java.io.File;  import java.io.FileInputStream;  import java.io.FileNotFoundException;@Servicepublic class BookService { @Autowired BookDao bookDao; /**  * 结账：传入哪个用户买了哪本书  * @param username  * @param id  */ @Transactional(propagation = Propagation.REQUIRED) public void checkout(String username,int id) {  bookDao.updateStock(id);  int price = bookDao.getPrice(id);  bookDao.updateBalance(username,price); } @Transactional(propagation = Propagation.REQUIRED) public void updatePrice(int id,int price){  bookDao.updatePrice(id,price); }} MulService.java package com.mashibing.service;import com.mashibing.bean.Book;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class MulService { @Autowired private BookService bookService; @Transactional public void mulTx(){  bookService.checkout(zhangsan,1);  bookService.updatePrice(1,1000);  int i = 1/0; }} 将bookservice方法的传播行为为Required，并且将报错设置在MulService中，发现会都进行回滚。 BookService.java package com.mashibing.service;  import com.mashibing.dao.BookDao;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Service;  import org.springframework.transaction.annotation.Isolation;  import org.springframework.transaction.annotation.Propagation;  import org.springframework.transaction.annotation.Transactional;  import java.io.File;  import java.io.FileInputStream;  import java.io.FileNotFoundException;@Servicepublic class BookService { @Autowired BookDao bookDao; /**  * 结账：传入哪个用户买了哪本书  * @param username  * @param id  */ @Transactional(propagation = Propagation.REQUIRES_NEW) public void checkout(String username,int id) {  bookDao.updateStock(id);  int price = bookDao.getPrice(id);  bookDao.updateBalance(username,price); } @Transactional(propagation = Propagation.REQUIRES_NEW) public void updatePrice(int id,int price){  bookDao.updatePrice(id,price); }} MulService.java package com.mashibing.service;import com.mashibing.bean.Book;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class MulService { @Autowired private BookService bookService; @Transactional public void mulTx(){  bookService.checkout(zhangsan,1);  bookService.updatePrice(1,1000);  int i = 1/0; }} 将bookservice方法的传播行为为Requires_new，并且将报错设置在MulService中，发现都不会进行回滚。 BookService.java package com.mashibing.service;  import com.mashibing.dao.BookDao;  import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.stereotype.Service;  import org.springframework.transaction.annotation.Isolation;  import org.springframework.transaction.annotation.Propagation;  import org.springframework.transaction.annotation.Transactional;  import java.io.File;  import java.io.FileInputStream;  import java.io.FileNotFoundException;@Servicepublic class BookService { @Autowired BookDao bookDao; /**  * 结账：传入哪个用户买了哪本书  * @param username  * @param id  */ @Transactional(propagation = Propagation.REQUIRES_NEW) public void checkout(String username,int id) {  bookDao.updateStock(id);  int price = bookDao.getPrice(id);  bookDao.updateBalance(username,price); } @Transactional(propagation = Propagation.REQUIRES_NEW) public void updatePrice(int id,int price){  bookDao.updatePrice(id,price); } @Transactional public void mulTx(){  checkout(zhangsan,1);  updatePrice(1,1000);  int i = 1/0; }} 如果在bookservice执行的话，会发现刚刚的效果就没有了，原因是外层调用的时候使用的AOP，但是本类方法自己的调用就是最最普通的调用，就是同一个事务。 总结： 1、事务传播级别是REQUIRED，当checkout()被调用时（假定被另一类中commit()调用），如果checkout()中的代码抛出异常，即便被捕获，commit()中的其他代码都会roll back2、是REQUIRES_NEW，如果checkout()中的代码抛出异常，并且被捕获，commit()中的其他代码不会roll back；如果commit()中的其他代码抛出异常，而且没有捕获，不会导致checkout()回滚3、是NESTED，如果checkout()中的代码抛出异常，并且被捕获，commit()中的其他代码不会roll back；如果commit()中的其他代码抛出异常，而且没有捕获，会导致checkout()回滚 PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 内部 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行.  另一方面, PROPAGATION_NESTED 开始一个 嵌套的 事务, 它是已经存在事务的一个真正的子事务. 嵌套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交.  由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back. 3、基于xml的事务配置 jdbcTemplate.xml &lt;?xml version=1.0 encoding=UTF-8?&gt;&lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xmlns:aop=http://www.springframework.org/schema/aop  xmlns:tx=http://www.springframework.org/schema/tx  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd  http://www.springframework.org/schema/aop  https://www.springframework.org/schema/aop/spring-aop.xsd  http://www.springframework.org/schema/tx  https://www.springframework.org/schema/tx/spring-tx.xsd&gt; &lt;context:component-scan base-package=com.mashibing&gt;&lt;/context:component-scan&gt; &lt;context:property-placeholder location=classpath:dbconfig.properties&gt;&lt;/context:property-placeholder&gt; &lt;bean id=dataSource class=com.alibaba.druid.pool.DruidDataSource&gt;  &lt;property name=username value=${jdbc.username}&gt;&lt;/property&gt;  &lt;property name=password value=${jdbc.password}&gt;&lt;/property&gt;  &lt;property name=url value=${jdbc.url}&gt;&lt;/property&gt;  &lt;property name=driverClassName value=${jdbc.driverClassName}&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=jdbcTemplate class=org.springframework.jdbc.core.JdbcTemplate&gt;  &lt;constructor-arg name=dataSource ref=dataSource&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=namedParameterJdbcTemplate class=org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&gt;  &lt;constructor-arg name=dataSource ref=dataSource&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--事务控制--&gt; &lt;!--配置事务管理器的bean--&gt; &lt;bean id=transactionManager class=org.springframework.jdbc.datasource.DataSourceTransactionManager&gt;  &lt;property name=dataSource ref=dataSource&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 基于xml配置的事务：依赖tx名称空间和aop名称空间  1、spring中提供事务管理器（切面），配置这个事务管理器  2、配置出事务方法  3、告诉spring哪些方法是事务方法（事务切面按照我们的切入点表达式去切入事务方法） --&gt; &lt;bean id=bookService class=com.mashibing.service.BookService&gt;&lt;/bean&gt; &lt;aop:config&gt;  &lt;aop:pointcut id=txPoint expression=execution(* com.mashibing.service.*.*(..))/&gt;  &lt;!--事务建议：advice-ref:指向事务管理器的配置--&gt;  &lt;aop:advisor advice-ref=myAdvice pointcut-ref=txPoint&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; &lt;tx:advice id=myAdvice transaction-manager=transactionManager&gt;  &lt;!--事务属性--&gt;  &lt;tx:attributes&gt;  &lt;!--指明哪些方法是事务方法--&gt;  &lt;tx:method name=*/&gt;  &lt;tx:method name=checkout propagation=REQUIRED/&gt;  &lt;tx:method name=get* read-only=true&gt;&lt;/tx:method&gt;  &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;/beans&gt; 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/08/02/05-transaction/",
      "keywords" : "Java, Spring"
    } ,
  
    {
      "title"    : "Java Spring MVC 01——简单介绍及使用方法（一）",
      "category" : "SpringMVC",
      "content": "Java Spring MVC 01——简单介绍及使用方法（一） 什么是 MVC？ MVC 是一种软件设计规范，是当今通用的一种设计思想。 MVC 将项目分为三个层次： Model（模型） 读写数据库并对数据进行一系列处理，一般分为三层：  entity 实体层 与数据库对应的类  dao 层 进行增删改查  service 层 Model 层的编程重点，在使用 dao 层读写数据库的基础上，添加一系列逻辑处理。   View（视图） 负责展示模型数据，即用户所看到的用户界面。 Controller（控制器） Model 和 View 之间的中间人。  接受用户请求，并传入 Model 层处理。  接受 Model 层处理好的模型数据，并传回 View 层展示。   MVC 主要作用是降低了视图与业务逻辑间的双向耦合。 如果没有 Controller，View 和 Model 之间会相互调用，程序会显得十分臃肿，并且不利于维护和拓展。 MVC 不是一种设计模式，而是一种架构模式，不同的 MVC 存在差异。 最典型的 MVC 就是 JSP + servlet + javabean 的模式 Spring MVC 的介绍  以下内容引用自 官网 Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning. The formal name, “Spring Web MVC,” comes from the name of its source module (spring-webmvc), but it is more commonly known as “Spring MVC”. Spring Web MVC 是构建在 Servlet API 上的原始 Web 框架，从一开始就包含在 Spring Framework 中。 正式名称 “Spring Web MVC” 来自其源模块(spring-webmvc)的名称，但它通常被称为 “Spring MVC”。 简而言之，SpringMVC 是 Spring 框架的一部分，是基于 Java 实现的一个轻量级 web 框架。 SpringMVC 框架的核心关键是 DispatcherServlet。 Spring MVC 的优点  清晰的角色划分 控制器(controller)、验证器(validator)、命令对象(command obect)、表单对象(form object)、模型对象(model object)、Servlet分发器(DispatcherServlet)、处理器映射(handler mapping)、试图解析器(view resoler)等等。 每一个角色都可以由一个专门的对象来实现。   强大而直接的配置方式 将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用。 例如，在web控制器中对业务对象和验证器validator的引用。   可适配、非侵入 可以根据不同的应用场景，选择何事的控制器子类(simple型、command型、from型、wizard型、multi-action型或者自定义)，而不是一个单一控制器(比如Action/ActionForm)继承。   可重用的业务代码 可以使用现有的业务对象作为命令或表单对象，而不需要去扩展某个特定框架的基类。   可定制的绑定(binding)和验证(validation 比如将类型不匹配作为应用级的验证错误，这可以保证错误的值。再比如本地化的日期和数字绑定等等。在其他某些框架中，你只能使用字符串表单对象，需要手动解析它并转换到业务对象。   可定制的handler mapping和view resolution Spring提供从最简单的URL映射，到复杂的、专用的定制策略。与某些web MVC框架强制开发人员使用单一特定技术相比，Spring显得更加灵活。   灵活的model转换 在Springweb框架中，使用基于Map的键/值对来达到轻易的与各种视图技术集成。   可定制的本地化和主题(theme)解析 支持在JSP中可选择地使用Spring标签库、支持JSTL、支持Velocity(不需要额外的中间层)等等。   简单而强大的JSP标签库(Spring Tag Library) 支持包括诸如数据绑定和主题(theme)之类的许多功能。他提供在标记方面的最大灵活性。   JSP表单标签库 在Spring2.0中引入的表单标签库，使用在JSP编写表单更加容易。   Spring Bean的生命周期 可以被限制在当前的HTTp Request或者HTTp Session。准确的说，这并非Spring MVC框架本身特性，而应归属于Spring MVC使用的WebApplicationContext容器。 Spring MVC 的实现原理 SpringMVC 的 MVC 模式： SpringMVC的具体执行流程： 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。  DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。 返回处理器执行链，根据url查找控制器，并且将解析后的信息传递给DispatcherServlet HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。 执行handler找到具体的处理器 Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。 HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。 DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet。 DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图，进行试图渲染 将响应数据返回给客户端 Spring MVC 的简单实现 基于 XML 的实现 先看以下项目结构（开发环境为 IDEA） 其中标红的地方为我们需要配置的，一共五处。 1. 添加 pom 依赖 &lt;dependencies&gt;  t&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;  t&lt;dependency&gt;  t t&lt;groupId&gt;org.springframework&lt;/groupId&gt;  t t&lt;artifactId&gt;spring-context&lt;/artifactId&gt;  t t&lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  t&lt;/dependency&gt;  t&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;  t&lt;dependency&gt;  t t&lt;groupId&gt;org.springframework&lt;/groupId&gt;  t t&lt;artifactId&gt;spring-web&lt;/artifactId&gt;  t t&lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  t&lt;/dependency&gt;  t&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;  t&lt;dependency&gt;  t t&lt;groupId&gt;org.springframework&lt;/groupId&gt;  t t&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  t t&lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  t&lt;/dependency&gt; &lt;/dependencies&gt; 初次之外，还需要导入 tomcat 的两个 jar 包 .  apache-tomcat-9.0.50  lib 下的 jsp-api.jar servlet-api.jar 也可以通过 Maven 依赖导入这两个包 &lt;dependency&gt;  t&lt;groupId&gt;javax.servlet&lt;/groupId&gt;  t&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;  t&lt;version&gt;2.5&lt;/version&gt;  t&lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt;  t&lt;groupId&gt;javax.servlet&lt;/groupId&gt;  t&lt;artifactId&gt;jsp-api&lt;/artifactId&gt;  t&lt;version&gt;2.0&lt;/version&gt;  t&lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 使用 Maven 导入时要注意是否与本地所使用的 tomcat 兼容。 2. 编写 web.xml 文件 &lt;!--配置前端控制器--&gt; &lt;servlet&gt;  t&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;  t&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  t&lt;!-- 设置初始化参数，指定默认的 springmvc 的配置文件 --&gt;  t&lt;init-param&gt;  t t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  t t&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;  t&lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 添加前端控制器对应的 mapping 映射 --&gt; &lt;servlet-mapping&gt;  t&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;  t&lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 这里一共有三个操作： 创建一个 org.springframework.web.servlet.DispatcherServlet 的对象 springmvc，即前端控制器。 当用户发送请求时，会先送到这里。 设置 springmvc 通过读取 springmvc.xml 进行初始化。 设置 springmvc 将接收哪些 url。 此处设置为 / ，即接收所有的 url。 3. 编写 spring.xml 文件 &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd&gt; &lt;!--将逻辑视图转换成真实资源--&gt;  &lt;bean class=org.springframework.web.servlet.view.InternalResourceViewResolver&gt;  &lt;property name=prefix value=/WEB-INF/page/&gt;&lt;/property&gt;  &lt;property name=suffix value=.jsp&gt;&lt;/property&gt;  &lt;/bean&gt;  t  &lt;!--设置某一具体请求的处理类--&gt;  &lt;bean id=/hello class=com.kky.controller.HelloController&gt;&lt;/bean&gt;  t &lt;/beans&gt; 第一个 bean 对象通过设置前缀和后缀用于将逻辑视图转换成真实的资源。 prefix 是前缀，suffix 是后缀。 假如此时的逻辑视图是 hello 加上前缀 /WEB-INF/page/hello 加上后缀 /WEB-INF/page/hello.jsp 这样就找到了真实存在的资源了 第二个 bean 对象用于配置处理具体请求的对象。 即当请求为 localhost:8080/hello 时， 该请求将交予 com.kky.controller.HelloController 处理。 4. 编写 HelloController 类 import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.Controller; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {  //创建对象  ModelAndView modelAndView = new ModelAndView();  //添加视图名称，要跳转的页面的名称  modelAndView.setViewName(hello);  //向前端页面添加的属性值  modelAndView.addObject(hello, hello,springmvc);  //返回对象  return modelAndView;  } } 继承于 org.springframework.web.servlet.mvc.Controller 接口。 请注意，不是 org.springframework.stereotype.Controller。 可以看到，此时跳转的页面名称只是 hello，这只是逻辑视图。 它会根据第 3 步编写的 springmvc.xml 文件转成真实资源 /WEB-INF/page/hello.jsp 5. 编写 hello.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 欢迎 ${hello} &lt;/body&gt; &lt;/html&gt; 6. 配置 tomcat，发送请求  当使用 Idea 开发项目时，有时会遇到以下错误 仔细看，异常信息是 java.lang.ClassNotFoundException: org.springframework.web.servlet.DispatcherServlet 说明 Spring MVC 相关的 jar 包并没有导入到程序中。 打开 Project Structure，在 WEB-INF 目录下新建一个 lib 包 右键 lib 包，点击 Add Copy of ，点击 Library Files 将 Spring MVC 相关的 jar 包导进去 重新运行即可解决该错误 基于注解实现 基于 xml 实现比较麻烦，更多的时候使用注解实现 以下内容部分与 基于 XML 的实现 相同，不做解释。 1. 添加pom依赖 与 基于 XML 的实现 相同 &lt;dependencies&gt;  t&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;  t&lt;dependency&gt;  t t&lt;groupId&gt;org.springframework&lt;/groupId&gt;  t t&lt;artifactId&gt;spring-context&lt;/artifactId&gt;  t t&lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  t&lt;/dependency&gt;  t&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;  t&lt;dependency&gt;  t t&lt;groupId&gt;org.springframework&lt;/groupId&gt;  t t&lt;artifactId&gt;spring-web&lt;/artifactId&gt;  t t&lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  t&lt;/dependency&gt;  t&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;  t&lt;dependency&gt;  t t&lt;groupId&gt;org.springframework&lt;/groupId&gt;  t t&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  t t&lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  t&lt;/dependency&gt; &lt;/dependencies&gt; 2. 编写 web.xml 文件 与 基于 XML 的实现 相同 &lt;!--配置前端控制器--&gt; &lt;servlet&gt;  t&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;  t&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  t&lt;!-- 设置初始化参数，指定默认的 springmvc 的配置文件 --&gt;  t&lt;init-param&gt;  t t&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  t t&lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;  t&lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- 添加前端控制器对应的 mapping 映射 --&gt; &lt;servlet-mapping&gt;  t&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;  t&lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3. 编写 springmvc.xml 文件 注意导入 context 命名空间 &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xmlns:mvc=http://www.springframework.org/schema/mvc  xsi:schemaLocation=http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd  http://www.springframework.org/schema/context  https://www.springframework.org/schema/context/spring-context.xsd&gt; &lt;!--开启自动扫描功能--&gt;  &lt;context:component-scan base-package=com.kky&gt;&lt;/context:component-scan&gt;  t  &lt;!--将逻辑视图转换成真实资源--&gt;  &lt;bean class=org.springframework.web.servlet.view.InternalResourceViewResolver&gt;  &lt;property name=prefix value=/WEB-INF/page/&gt;&lt;/property&gt;  &lt;property name=suffix value=.jsp&gt;&lt;/property&gt;  &lt;/bean&gt; &lt;/beans&gt; 4. 编写 HelloController @Controller @RequestMapping(hello) public class HelloController {  //处理哪个请求  @RequestMapping(value = /hello)  public String hello(Map&lt;String, String&gt; map) {  //传回 jsp 的信息  map.put(hello, hello,Springmvc);  //传回哪个 jsp  return hello;  } }  使用 @RequestMapping 配置处理的请求。 使用 map 配置传回 jsp 的信息。 return 表示要返回的 jsp 。 5. 编写 hello.jsp 与 基于 XML 的实现 相同 注意 @Controller @RequestMapping(hello) public class HelloController {  //处理哪个请求  @RequestMapping(value = /hello)  public String hello(Map&lt;String, String&gt; map) {  //传回 jsp 的信息  map.put(hello, hello,springmvc);  //传回哪个 jsp  return hello;  } } 此时匹配的请求是 localhost:8080/hello/hello。 因为类和方法都有 @RequestMapping 注解 而如果把类的 @RequestMapping 注解去掉 @Controller public class HelloController {  //处理哪个请求  @RequestMapping(value = /hello)  public String hello(Map&lt;String, String&gt; map) {  //传回 jsp 的信息  map.put(hello, hello,springmvc);  //传回哪个 jsp  return hello;  } } 此时匹配的请求是 localhost:8080/hello。 在学习时，为了简化操作，可以不给类加 @RequestMapping 注解。 但是在企业开发中，是要加的。 因为整个项目中是不允许出现一个请求匹配多个 Controller 的情况的。 所以为了保证你负责的模块和别人负责的模块不会出现冲突，给类加 @RequestMapping 注解是很有必要的。 6. 配置 tomcat，发送请求 总结 Spring MVC 的运行流程 通过上述的代码，我们能够总结出具体的运行流程： 客户端发送请求 http://localhost:8080/xxx 由 tomcat 接受到对应的请求 SpringMVC 的前端控制器 DispatcherServlet 接收到所有的请求 根据请求地址寻找对应的 @RequestMapping 注解，进而找到处理该请求的类和方法。 前端控制器找到目标处理类和方法之后，执行目标方法。 方法执行完成之后会有一个返回值，Spring MVC 会将这个返回值用视图解析器进行解析拼接成完整的页面地址。 DispatcherServlet 拿到页面地址之后，转发到具体的页面 Spring MVC 的配置文件 web.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;web-app xmlns=http://xmlns.jcp.org/xml/ns/javaee  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation=http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd  version=4.0&gt;  &lt;!--配置DispatcherServlet--&gt;  &lt;servlet&gt;  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  &lt;!--  t t关联springmvc的配置文件  t t此配置文件的属性可以不添加，但是需要在WEB-INF的目录下创建 前端控制器名称-servlet.xml文件  t t--&gt;  &lt;init-param&gt;   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;   &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;  &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt; &lt;/web-app&gt; DispatcherServlet 的 url-pattern 在前文配置 DispatcherServlet 时，需要配置一个 &lt;url-pattern&gt; 的属性，一般而言有两种方式。 &lt;url-pattern&gt;/&lt;/url-pattern&gt; 匹配所有请求。 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 匹配所有请求，但是会拦截 jsp 页面（无法跳转到 jsp 页面）。 如何访问 html 页面 此时如果创建一个 html 页面，是无法访问的。 如 http://localhost:8080/heihei.html 这样的访问会出错。 原因是因为每个项目的 web.xml 文件都是继承于 tomcat 的 web.xml 文件的。 tomcat 的 web.xml 文件有一个 DefaultServlet 的处理类用来处理静态资源。 但是我们在编写自己的 DispatcherServlet 的时候使用了 / 的方式，此方式覆盖了父 web.xml 对于静态资源的处理。 所以此时所有的静态资源的访问也需要由 DispatcherServlet 来进行处理，但是我们并没有设置对应的 Controller，所以报 404。 而 jsp 能够处理是因为父 web.xml 文件中包含了一个 JSPServlet 的处理类，会由 tomcat 进行处理，而不是我们定义的 DispatcherServlet。 如果想要访问 html 页面，在 web.xml 中添加 &lt;servlet&gt;  t&lt;servlet-name&gt;default&lt;/servlet-name&gt;  t&lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt;  t&lt;servlet-name&gt;default&lt;/servlet-name&gt;  t&lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 详解基于注解实现 Spring MVC @RequestMapping @RequestMapping用来匹配客户端发送的请求，可以在方法上使用，也可以在类上使用。 方法：表示用来匹配要处理的请求 类上：表示为当前类的所有方法的请求地址添加一个前置路径，访问的时候必须要添加此路径 package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(/mashibing)public class HelloController{ /* * @RequestMapping就是用来标识此方法用来处理什么请求，其中的/可以取消 * 取消后默认也是从当前项目的根目录开始查找，一般在编写的时候看个人习惯 * 同时，@RequestMapping也可以用来加在类上， * */ @RequestMapping(/hello) public String hello(Model model){  model.addAttribute(msg,hello,SpringMVC);  return hello; }} 注意：在整个项目的不同方法上不能包含相同的@RequestMapping值 除此以外，@RequestMapping注解还可以添加很多额外的属性值，用来精确匹配请求 @RequestMapping 的属性值 @RequestMapping 还可以添加很多额外的属性值，用来精准匹配请求 value 要匹配的请求 @RequestMapping(value = /hello) method 限定请求方式 @RequestMapping(value = /hello, method = RequestMethod.GET) @RequestMapping(value = /hello, method = RequestMethod.POST) params 限定参数 @RequestMapping(value = /hello, params = {username}) 此时访问的 url 中必须有 username 参数 http://localhost:8080/hello/hello?username=zhangsan @RequestMapping(value = /hello, params = {!username}) 此时访问的 url 中不能有 username 参数 @RequestMapping(value = /hello, params = {username=zhangsan,age}) 此时访问的 url 中参数 username 必须是 zhangsan，参数 age 随意。 username 和 age 顺序无所谓。 headers 限制请求头 这是使用 Google Chrome 浏览器访问时的请求头 可以看到，信息非常多。 其中的 Upgrade-Insecure-Requests=1 所以当我们把请求头限制为 @RequestMapping(value = /hello, headers = {Upgrade-Insecure-Requests=2}) 时，将无法通过 Google Chrome 访问该网页。 当然，这个属性一般不用。 谁会嫌弃访问量多呢？ produces 和 headers 同理，也是限制请求头。 但是只限制 Context-Type 属性。 consumer 限制响应头中的 Context-Type 属性。 模糊匹配 通配符： ? 替代任意一个字符 * 替代多个字符 ** 替代多层路径 @RequestMapping(value = /**/h*llo?) 当匹配到多个请求时，优先精准匹配，其次是模糊匹配。 @PathVariable 之前我们在请求路径中是如何定义参数的？ http://localhost:8080/hello?username=zhangsan 通过这种方式我们可以获取到 username=zhangsan 但我们能否读取到 http://localhost:8080/hello/zhangsan 中的 zhangsan？ 即将路径读取为参数。 可以使用 @PathVariable 注解。 此注解就是提供了对占位符 URL 的支持，就是将 URL 中占位符参数绑定到控制器处理方法的参数中。 @Controller public class PathVariableController { @RequestMapping(/hello/{username})  public String testPathVariable(@PathVariable(username) String username, Map&lt;String, String&gt; map) {  map.put(hello, username);  return hello;  } } 把要读取的路径用 {参数名} 括起来做标识，再用 @PathVariable(参数名) 传入方法参数列表。 当路径中的参数和方法参数同名时，可以省略 @PathVariable 括号中的内容。 例如：此时路径和方法参数名都是 username。 @Controller public class PathVariableController { @RequestMapping(/hello/{username})  public String testPathVariable(@PathVariable String username, Map&lt;String, String&gt; map) {  map.put(hello, username);  return hello;  } } 但是建议还是采取 @PathVariable(username) 的方式。 多个参数的设置 @Controller public class PathVariableController { @RequestMapping(/hello/{id}/{username})  public String testPathVariable(@PathVariable(id) Integer id,      @PathVariable(username) String username,      Map&lt;String, String&gt; map) {  map.put(hello, id + 号 + username);  return hello;  } }  REST REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。 在三种主流的Web服务实现方案中，因为REST模式的Web服务与复杂的SOAP和XML-RPC对比来讲明显的更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务进行图书查找；雅虎提供的Web服务也是REST风格的。 REST,翻译过来叫做表现层状态转化，是目前最流行的一个互联网软件架构，它架构清晰，符合标准，易于理解，扩展方便。 表现层（Representation）：把资源具体呈现出来的形式，因此叫做表现层。 资源（Resource）：网络上的一个具体信息，文本，图片，音频，视频都可以称之为资源，如果想要访问到互联网上的某一个资源，那么就必须要使用一个URL来唯一性的获取改资源，也可以这么说，URL是每一个资源的唯一标识符。 状态转化（State Transfer）：当客户端发出一个请求的时候，就代表客户端跟服务端的一次交互过程，HTTP是一种无状态协议，即所有的状态都保存在服务器端，因此，客户端如果想要操作服务器，必须通过某些手段，让服务器的状态发生转化，而这种转化是建立在表现层的，这就是名字的由来（非人话） 以上是官方说明，下面通过一些简单描述和案例介绍 REST 首先考虑，我们如何通过 web 实现增删改查？ 如果按照原来的架构，应该这样的： @Controller @RequestMapping(user) public class UserController {  @Autowired  UserService userService; @RequestMapping(/insert)  public void insert() {  userService.insert(new User());  } @RequestMapping(/delete)  public void delete(Integer id) {  userService.delete(id);  } @RequestMapping(/update)  public void update(Integer id) {  userService.update(id);  } @RequestMapping(/select)  public void select(Integer id) {  userService.select(id);  } } 无需关心 User 和 UserDao 的实现，那无关紧要。 如果我们是这样的设计，我们应该这样访问 http://localhost:8080/user/insert http://localhost:8080/user/delete?id=1 http://localhost:8080/user/update?id=1 http://localhost:8080/user/select?id=1 看上去有些麻烦。 于是有人提出了 REST： 在 HTTP 协议中，有不同的请求方法，为什么不能将发送请求方法和增删改查联系到一起呢？ 一共有 8 种请求方法： GET HEAD POST PUT DELETE CONNECT OPTIONS TRACE 现在让我们不要考虑这些请求方法的原意是什么，直接进行如下定义：    请求类型  执行操作     POST  insert    DELETE  delete    PUT  update    GET  select   通过这样的定义，请求的 url 将变得高度统一： 无参  http://localhost:8080/user   有参  http://localhost:8080/user/1   设计很美，如何实现呢？ 添加 Filter 我们无法直接发送 DELETE 和 PUT 请求，必须借助于 Spring MVC 的 Filter 实现 修改 web.xml ... &lt;!--此过滤器完成请求方式的转换，将 post 请求转换为 put 或 delete--&gt; &lt;filter&gt;  t&lt;filter-name&gt;hidden&lt;/filter-name&gt;  t&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt;  t&lt;filter-name&gt;hidden&lt;/filter-name&gt;  t&lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 修改 Controller 在方法中限定 method 属性，并使用 @PathVariable() 读取路径中的参数 @Controller @RequestMapping(user) public class UserController {  @Autowired  UserService userService; @RequestMapping(method = RequestMethod.POST)  public void insert() {  userService.insert(new User());  } @RequestMapping(value = /{id}, method = RequestMethod.DELETE)  public void delete(@PathVariable(id) Integer id) {  userService.delete(id);  } @RequestMapping(value = /{id}, method = RequestMethod.PUT)  public void update(@PathVariable(id) Integer id) {  userService.update(id);  } @RequestMapping(value = /{id}, method = RequestMethod.GET)  public void select(@PathVariable(id) Integer id) {  userService.select(id);  } } 创建 jsp 页面 直接修改 index.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%  pageContext.setAttribute(baseUrl, request.getContextPath()); %&gt; &lt;form action=${baseUrl}/user method=post&gt;  &lt;input type=submit value=post&gt; &lt;/form&gt; &lt;form action=${baseUrl}/user/1 method=post&gt;  &lt;input type=hidden name=_method value=delete&gt;  &lt;input type=submit value=delete&gt; &lt;/form&gt; &lt;form action=${baseUrl}/user/1 method=post&gt;  &lt;input type=hidden name=_method value=put&gt;  &lt;input type=submit value=put&gt; &lt;/form&gt; &lt;form action=${baseUrl}/user/1 method=get&gt;  &lt;input type=submit value=get&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; post 和 get 请求可以直接发送。 delete 和 put 请求必须借助于 Spring MVC 实现，格式十分严格。 type = hidden name = _method method = delete 或 method = put 点击按钮提交对应表单即可实现增删改查 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/08/05/01-introduce/",
      "keywords" : "Spring MVC, Java"
    } ,
  
    {
      "title"    : "Java Spring MVC 02——使用方法（二）",
      "category" : "SpringMVC",
      "content": "Java Spring MVC 02——使用方法（二） SpringMVC 对请求的处理 参数处理 在 servlet 中，我们通过 request.getParameter() 获取请求中的参数。 但是在 Spring MVC 中并没有 request 参数，此时如何处理？ 获取参数 @RequestParam 当请求中的参数和方法形参同名时，可以直接获取参数。 @Controller public class RequestController {  @RequestMapping(/request)  public void request(String name){  System.out.println(name);  } } 请求 http://localhost:8080/request?name=zhangsan 此时请求和方法中的参数名都是 username，可以直接获取。 但如果不同名，例如此时请求是这样的 http://localhost:8080/request?username=zhangsan 那么方法将获取不到 username=zhangsan。 此时需要使用 @RequestParam 注解来获取参数 @RequestMapping(/request) public void request(@RequestParam( username) String name){  System.out.println(name); } 请求 http://localhost:8080/request?username=zhangsan 结果 zhangsan 请注意将 @RequestParam 与 @PathVariable 分开。 @RequestParam 读取 ? 后的参数 @PathVariable 读取路径作为参数 @RequestParam 的属性 value 表示要获取的参数值 @RequestMapping(/request) public void request(@RequestParam( value = username) String name){  System.out.println(name); } required 表示该参数是否是必须的，默认是。 当方法这样时 @RequestMapping(/request) public void request(@RequestParam( value = username) String name){  tSystem.out.println(name); } 默认 required = true ，即请求必须带有 username 如果请求是这样的 http://localhost:8080/request 报错 400 所以如果 request = false，将允许请求中不携带该参数 @RequestParam(value = username, required = true) defaultValue 设置参数的默认值 @RequestParam(value = username, defaultValue = lisi) 如果请求中没有 username ，则默认其 username = lisi 所以，当有 defaultValue 时，required = true 自动失效。 因为请求中一定会有 username。 获取请求头 @RequestHeader 获取整个请求头 @Controller public class RequestController {  t...  t  @RequestMapping(/requestHeader)  public void requestHeader(@RequestHeader HttpHeaders headers) {  System.out.println(headers);  } } 获取一部分请求头 @Controller public class RequestController { ...  t  @RequestMapping(/requestHeader)  public void requestHeader(@RequestHeader(Accept) String accept) {  System.out.println(accept);  } } @RequestHeader 同样拥有以下属性值，其效果等同于 @RequestParam 中的属性值 value required defaultValue 获取 Cookie @CookieValue Cookie 是 Request Header 的一部分 读取一部分 Cookie @Controller public class RequestController {  t...  t  @RequestMapping(/cookie)  public void cookie(@CookieValue(JSESSIONID) String id){  System.out.println(id);  } } 读取全部 Cookie，通过 @RequestHeader 读取 @RequestHeader(Cookie) String cookie @CookieValue 同样拥有以下属性值，其效果等同于 @RequestParam 中的属性值 value required defaultValue Spring MVC 传输对象 使用 Spring MVC 传输对象非常方便。 User 类 public class User {  private Integer id;  private String name;  private Integer age;  private Date date;  private Address address; //省略无参构造器，setter/getter 方法，toString 方法 } Address 类 package com.mashibing.bean; public class Address {  private String province;  private String city;  private String town; //省略无参构造器，setter/getter 方法，toString 方法 } user.jsp 把该 jsp 直接放置于 web 目录以直接访问 &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp,request.getContextPath()); %&gt; &lt;body&gt; &lt;form action=${ctp}/testUser method=post&gt;  编号：&lt;input type=text name=id&gt;&lt;br&gt;  姓名：&lt;input type=text name=name&gt;&lt;br&gt;  年龄：&lt;input type=text name=age&gt;&lt;br&gt;  性别：&lt;input type=text name=gender&gt;&lt;br&gt;  省份：&lt;input type=text name=address.province&gt;&lt;br&gt;  城市：&lt;input type=text name=address.city&gt;&lt;br&gt;  区域：&lt;input type=text name=address.town&gt;&lt;br&gt;  &lt;input type=submit value=提交&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; UserController2 @Controller public class UserController2 { @RequestMapping(/testUser)  public void testUser(User user){  System.out.println(user);  } } 测试 结果 User{id=1, name='kky', age=24, gender='鐢�', address=Address{province='浜戝崡', city='澶х悊', town='涓嬪叧'}} 有乱码问题，下文解决。 Spring MVC 会帮我们自动封装对象，十分方便。 与 Spring 同理，在表单中的 编号：&lt;input type=text name=id&gt; 中的 id 匹配的是 User 类中的 getId()方法和 setId() 方法，并不是 private Integer id; 中的 id。 解决乱码问题 前后端交互时经常会出现乱码问题，如何解决？ GET 请求 对于 GET 请求，直接在 .  apache-tomcat-9.0.50  conf  server.xml 中添加 URIEncoding=UTF-8 &lt;Connector port=8080 protocol=HTTP/1.1  t t connectionTimeout=20000  t t redirectPort=8443  t t URIEncoding=UTF-8/&gt; POST 请求 对于 POST 请求，需要添加过滤器 自定义编码过滤器 MyFilter.java public class MyFilter implements Filter {  @Override  public void init(FilterConfig filterConfig) throws ServletException {  System.out.println(init);  } @Override  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {  System.out.println(this.getClass().getName() + ------start);  servletRequest.setCharacterEncoding(UTF-8);  servletResponse.setCharacterEncoding(UTF-8);  filterChain.doFilter(servletRequest, servletResponse);  System.out.println(this.getClass().getName() + ------stop);  } @Override  public void destroy() {  System.out.println(destroy);  } } 在 web.xml 中添加过滤器 &lt;!--自定义编码过滤器--&gt; &lt;filter&gt;  t&lt;filter-name&gt;myFilter&lt;/filter-name&gt;  t&lt;filter-class&gt;com.kky.MyFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt;  t&lt;filter-name&gt;myFilter&lt;/filter-name&gt;  t&lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Spring MVC 的编码过滤器 直接在 web.xml 中配置 Spring MVC 自带的编码过滤器即可 &lt;!--Spring MVC 的编码过滤器--&gt; &lt;filter&gt;  t&lt;filter-name&gt;encoding&lt;/filter-name&gt;  t&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;  t&lt;init-param&gt;  t t&lt;param-name&gt;encoding&lt;/param-name&gt;  t t&lt;param-value&gt;UTF-8&lt;/param-value&gt;  t&lt;/init-param&gt;  t&lt;init-param&gt;  t t&lt;param-name&gt;forceEncoding&lt;/param-name&gt;  t t&lt;param-value&gt;true&lt;/param-value&gt;  t&lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt;  t&lt;filter-name&gt;encoding&lt;/filter-name&gt;  t&lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 注意 如果项目中配置了多个过滤器，那么字符编码过滤器必须在最前面（谁在前面先执行谁），否则失效。 Spring MVC对原生 API 的支持 在 Spring MVC 中是可以使用原生 servlet 对象的，只需要在参数中给出好了。 例如，这是从 菜鸟教程 中找的 servlet 教程 // 导入必需的 java 库 import java.io.*; import javax.servlet.*; import javax.servlet.http.*; // 扩展 HttpServlet 类 public class HelloWorld extends HttpServlet {  private String message; public void init() throws ServletException {  // 执行必需的初始化  message = Hello World; } public void doGet(HttpServletRequest request,    HttpServletResponse response)   throws ServletException, IOException {  // 设置响应内容类型  response.setContentType(text/html);  // 实际的逻辑是在这里  PrintWriter out = response.getWriter();  out.println(&lt;h1&gt; + message + &lt;/h1&gt;); } public void destroy() {  // 什么也不做 } } 可以看到，其中有两个重要的参数： HttpServletRequest request 封装请求 HttpServletResponse response 封装回应 根据 request 中的内容，在 response 中填写要返回的内容，这就是 servlet 。 那么在 Spring MVC 中，同样支持 HttpServletRequest request 和 HttpServletResponse response。 直接写入方法参数列表即可。 import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; @Controller public class UserController2 { @RequestMapping(api)  public String servletAPI(HttpServletRequest request, HttpServletResponse response, HttpSession session){  request.setAttribute(request,request);  session.setAttribute(session,session);  return success;  } } 然后前端页面直接读取这些信息 &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; request:${requestScope.get(request)} session:${sessionScope.get(session)} &lt;/body&gt; &lt;/html&gt; 那么，Spring MVC 到底支持哪些原生的 servlet 对象呢？ HttpServletRequest HttpServletResponse HttpSession Locale 设置区域信息，国际化操作使用 InputStream OutputStream Reader Writer 传输数据到页面 使用 Map, Model, ModelMap return 要返回的页面 @Controller @SessionAttributes(types = String.class) public class OutputController { @RequestMapping(/output)  public String output(Map&lt;String,String&gt; map){  map.put(msg,hello,output);  return success;  } @RequestMapping(/output2)  public String output2(Model model){  model.addAttribute(msg,hello,output2);  return success;  } @RequestMapping(/output3)  public String output3(ModelMap modelMap){  modelMap.addAttribute(msg,hello,output3);  return success;  } } 前端如何调用？ ${msg} 这三者的效果是一模一样的，而且作用域都是 request 。 因为这三者继承于同一个类： org.springframework.validation.support.BindingAwareModelMap  并且其数据都是放在 ModelAndView 中的。 使用 ModelAndView setViewName(要返回的页面名称) @Controller public class OutputController { @RequestMapping(mv)  public ModelAndView mv(){  ModelAndView mv = new ModelAndView();  mv.setViewName(output);  mv.addObject(msg,hello.modelAndView);  return mv;  } } 使用 ModelAndView 时，返回的数据同样是放在 request 作用域中。 使用 session 当使用 Map, Model, ModelMap, ModelAndView 传输数据时，数据都是放入 request 作用域的。 如果此时添加 @SessionAttribute ，那么会将数据在 session 中也保存一份。 此注解有两个参数 value 表示要添加哪些数据到 session 中 type 设置添加哪一类的数据 一般情况下不使用，因为会将很多数据都设置到 session 中，导致 session 异常。 @Controller @SessionAttributes(value = msg) public class OutputController { @RequestMapping(output1)  public String output1(Model model){  model.addAttribute(msg,hello,Springmvc);  System.out.println(model.getClass());  return sucess;  } } 使用 @ModelAttribute 来获取请求中的数据 @ModelAttribute 注解用于将方法的参数或者方法的返回值绑定到指定的模型属性上，并返回给 web 视图。 介绍一下业务场景。 在某网站，用户可以查看自己的个人信息，此时我们会从数据库中读取该用户的数据并显示到网页上。 用户可以修改部分信息，但不能修改所有信息，例如其 id 就不能修改。 这些不允许修改的属性不应该被提交，因为没有意义，只是在浪费资源。 但是如果不提交，form 表单提交数据后，后端接收到的实体类会出现 null。 如何解决？ 此时就有了这样的设计： 执行查询操作时，把从数据库获取的对象保存下来。 用户提交表单时，根据其内容修改之前保存的对象。 把这个对象再存回数据库。 对比之前的设计： 执行查询操作时，创建一个新对象，保存数据。 把这个对象传到前端。 用户提交表单时，再创建一个新对象，保存数据。 把这个对象存回数据库。 原来需要创建两个对象，现在只需要创建一个对象。 实体类 User public class User {  private Integer id;  private String name;  private String password;  private Integer age; //省略构造方法，所有属性的 getter/setter 方法和 toString 方法 } UserController @Controller @SessionAttributes(user) public class UserController { @RequestMapping(/update)  public String update(@ModelAttribute(user) User user) {  System.out.println(user);  return success;  } @ModelAttribute  public void testModelAttribute(Model model) {  User user = new User();  user.setId(1);  user.setName(李四);  user.setAge(11);  user.setPassword(1234);  model.addAttribute(user, user);  }  t  t@RequestMapping(/user)  public String testUser(Model model) {  testModelAttribute(model);  return update;  }  t } update.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp, request.getContextPath()); %&gt; &lt;body&gt; &lt;form action=${ctp}/update&gt;  id:&lt;input type=text value=${sessionScope.user.id} readonly=true&gt;&lt;br&gt;  name:&lt;input type=text value=${requestScope.user.name} name=name&gt;&lt;br&gt;  &lt;input type=submit value=更新&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 测试 点击更新，结果 User{id=1, name='zhangsan', password='1234', age=11} 可以看到，前端页面并没有 password 和 age 属性。 如果不使用 @ModelAttribute，那么后端收到的将是 User{id=1, name='zhangsan', password=null, age=null} 因为前端提交表单时，将重新新建一个对象，所以没有提交的属性值就是 null。 而如果使用了 @ModelAttribute ，整个流程使用的是一个对象。 该对象传输到前端，进行数据改写。 再将该对象传输到后端进行数据处理。 注意： 使用 @ModelAttribute 时，对象存在在 session 中。 使用时可以省略 @SessionAttribute 和方法参数中的 @ModelAttribute，但是不推荐。 请尽量将使用该对象的地方同名，否则 Spring MVC 将自动把类名首字母小写进行匹配，匹配不到时会报错。 @ModelAttribute 除了将对象添加到 Model 之外，还可以直接返回。 注意：ModelAttribute除了可以使用设置值到model中之外，还可以利用返回值。 ... @ModelAttribute(user)  public User testModelAttribute() {  System.out.println(testModelAttribute---------------+);  User user = new User();  user.setId(1);  user.setName(zhangsan);  user.setAge(11);  user.setPassword(1234);  return user;  } ... 转发和重定向 使用 forward 实现页面转发 在 Spring MVC 中，我们可以使用视图处理器将逻辑视图转换成实际视图。 springmvc.xml &lt;bean class=org.springframework.web.servlet.view.InternalResourceViewResolver&gt;  t&lt;property name=suffix value=.jsp&gt;&lt;/property&gt;  t&lt;property name=prefix value=/WEB-INF/page/&gt;&lt;/property&gt; &lt;/bean&gt; @Controller public class ForWardController { @RequestMapping(/success)  public String forward(){  System.out.println(forward);  return success;  } } 此时当接收到 /success 请求时，将跳转到 /WEB-INF/page/success.jsp。 而如果使用 forward ，则不会触发视图处理器，直接跳转到我们指定的实际视图去。 @Controller public class ForWardController { @RequestMapping(/forward)  public String forward(){  System.out.println(forward);  return forward:/index.jsp;  } } 此时将跳转到 /index.jsp 中，这个在视图处理器是无法实现的，因为 /index.jsp 不在 /WEB-INF/page 目录中。 forward 除了跳转到指定页面，也可以跳转到其他请求中。 @Controller public class ForWardController { @RequestMapping(/forward)  public String forward(){  System.out.println(forward);  return forward:/index.jsp;  } @RequestMapping(/forward2)  public String forward2(){  System.out.println(forward2);  return forward:/forward;  } } 此时 /forward2 请求将跳转到 /forward 请求，最终跳转到 /index.jsp 页面中。 使用 redirect 来实现重定向 redirect 使用方法和 forward 很像。 同样不会经过视图处理器。 @Controller public class RedirectController { @RequestMapping(/redirect)  public String redirect(){  System.out.println(redirect);  return redirect:/index.jsp;  } @RequestMapping(/redirect2)  public String redirect2(){  System.out.println(redirect2);  return redirect:/redirect;  } } 转发和重定向的区别    区别  转发 forward()  重定向 sendRedirect()                                                                    根目录  包含项目访问地址localhost:8080/项目地址/  不包含项目访问地址localhost:8080/    地址栏  不会发生变化访问前：./forward访问后：./forward  会发生变化访问前：./redirect访问后：./index.jsp    哪里跳转  服务器端进行的跳转  浏览器端进行的跳转    请求次数  1 次  2 次第 1 次是人为的第 2 次是自动的    请求域中数据  不会丢失  会丢失，因为是不同的请求   访问静态资源 如何在 jsp 页面中添加图片等静态资源？ 在 Spring MVC 的配置文件（不是 web.xml）中添加以下两个配置：  &lt;mvc:default-servlet-handler/&gt;  使 Spring MVC 能够处理静态资源 此时我们的项目会变得只能访问静态资源而不能处理动态请求。 所以配置一个使两者都能够正确访问的驱动。 &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;   自定义视图解析器 在前文中，我们使用 InternalResourceViewResolver 作为视图解析器。 该解析器可以给逻辑视图加上前缀和后缀来转换为实际视图。 注意： 当我们在 Spring MVC 的配置文件中没有指定视图解析器时，默认使用的就是 InternalResourceViewResolver 。 只不过其前缀和后缀为 null，此时我们返回页面时必须使用实际视图，而不能使用逻辑视图。 在 Spring MVC 中，视图解析器主要由两部分组成    ViewResolver  View     将逻辑视图转换为实际视图  与视图对应的类       所以自定义视图解析器就是实现 ViewResolver 和 View 这两个接口 MyViewController.java public class MyViewResolver implements ViewResolver {  @Override  public View resolveViewName(String viewName, Locale locale) throws Exception {  return new MyView();  } } MyView.java public class MyView implements View {  @Override  public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception {  response.sendRedirect(index.jsp);  } } 将所有的请求都转发到 /index.jsp 去 修改 Spring MVC 配置文件 删除 InternalResourceViewResolver，并把 MyViewResolver 加进去 springmvc.xml ... &lt;!--&lt;bean class=org.springframework.web.servlet.view.InternalResourceViewResolver&gt;--&gt;  t&lt;!--&lt;property name=suffix value=.jsp&gt;&lt;/property&gt;--&gt;  t&lt;!--&lt;property name=prefix value=/WEB-INF/page/&gt;&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;bean class=com.kky.viewResolver.MyViewResolver&gt; &lt;/bean&gt; ... 多个视图解析器的执行顺序 当 Spring MVC 的配置文件中配置了多个视图解析器时，谁在前先执行谁。 除此之外，可以实现 Ordered 接口来配置执行顺序。 当视图解析器实现了 Ordered 接口后，将根据其 order 的值来进行排序。 order 越小越先执行。 InternalResourceViewResolver 继承于 UrlBasedViewResolver，其 order = Integer.MAX_VALUE。 所以我们可以采取以下设计 viewName 是请求字符串，我们可以判断其请求是否包含某些特定字段决定执行逻辑 public class MyViewResolver implements ViewResolver, Ordered { @Override  public View resolveViewName(String viewName, Locale locale) throws Exception {  if (viewName.startsWith(kky:)) {   return new MyView();  } else {   return null;  }  } @Override  public int getOrder() {  return 0;  } } 或不实现 Ordered 接口，使用 @Order 注解 @Order(0) public class MyViewResolver implements ViewResolver, Ordered { @Override  public View resolveViewName(String viewName, Locale locale) throws Exception {  if (viewName.startsWith(kky:)) {   return new MyView();  } else {   return null;  }  } } Spring MVC 配置文件 ... &lt;bean class=org.springframework.web.servlet.view.InternalResourceViewResolver&gt;  t&lt;property name=suffix value=.jsp&gt;&lt;/property&gt;  t&lt;property name=prefix value=/WEB-INF/page/&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=com.kky.viewResolver.MyViewResolver&gt; &lt;/bean&gt; ... 此时虽然 InternalResourceViewResolver 在前，但是会先执行 MyViewResolver。 MyViewResolver 会判断请求是否以 kky:开头，如果是，则返回 MyView。 否则交由 InternalResourceViewResolver 处理。 自定义类型转换器 前端页面通过提交表单向后端发送数据，其内容全都是字符串类型。 但是我们经常使用实体类来接受这些数据，因为 Spring MVC 会自动为我们进行类型转换。 可以看到，所有的类型转换器都实现了 Converter 接口。 所以我们可以通过实现 Converter 接口来自定义类型转换器。 案例： 前端页面将传输一个格式为 xxx-xxx-xxx-xxx 的字符串，将其转换为 User 的 id name age password 前端页面 index.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp, request.getContextPath()); %&gt; &lt;body&gt; 请按照id-name-age-password的方式输入数据&lt;br&gt; &lt;form action=${ctp}/converter method=post&gt;  &lt;input type=text name=user&gt;&lt;br&gt;  &lt;input type=submit value=提交&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; MyConverter.java @Component public class MyConverter implements Converter&lt;String, User&gt; { @Override  public User convert(String source) {  User user = null;  if ((source != null) &amp;&amp; !.equals(source) &amp;&amp; (source.split(-).length == 4)){   user = new User();   user.setId(Integer.parseInt(source.split(-)[0]));   user.setName(source.split(-)[1]);   user.setAge(Integer.parseInt(source.split(-)[2]));   user.setPassword(source.split(-)[3]);  }  System.out.println(user);  return user;  } } 把我们自定义的类型转换器添加到 Spring MVC 配置文件中 &lt;mvc:annotation-driven conversion-service=conversionService&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=conversionService class=org.springframework.context.support.ConversionServiceFactoryBean&gt;  t&lt;property name=converters&gt;  t t&lt;set&gt;  t t t&lt;ref bean=myConverter&gt;&lt;/ref&gt;  t t&lt;/set&gt;  t&lt;/property&gt; &lt;/bean&gt;  要添加一个 conversionService 的驱动。 我们的 myConverter 之前已经通过 @Component 注解自动注入了，所以直接引入 converters 中。 此时我们的类型转换器就已经完成了，直接处理请求，无需关心类型转换问题。 MyConverterController.java @Controller public class MyConverterController { @RequestMapping(/converter)  public String testConverter(@RequestParam(user) User user, Model model) {  System.out.println(user);  model.addAttribute(user, user);  return success;  } } 在页面中输入 1-zhangsan-12-123456，结果 User{id=1, name='zhangsan', password='123456', age=12} 自定义日期格式化转换器 在 Spring MVC 中，同样会自动地把页面提交的字符串转为 java.util.Date 格式。 但是默认情况下，该字符串必须为 yyyy/mm/dd 的格式。 如果想要使用其他格式，请在对应实体类的属性上添加 @DateTimeFormat 注解。 public class User {  t... @DateTimeFormat(pattern = yyyy-mm-dd)  private Date birth;  t... } 此时如果前端页面提交的字符串是 2021-08-21，那么也能正确地进行格式转换。 注意 一般情况下，使用 @DateTimeFormat 注解不需要修改 Spring MVC 配置文件。 但是如果 Spring MVC 配置文件中显式声明了类型转换器，如 &lt;mvc:annotation-driven conversion-service=conversionService&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=conversionService class=org.springframework.context.support.ConversionServiceFactoryBean&gt;  t&lt;property name=converters&gt;  t t&lt;set&gt;  t t t&lt;ref bean=myConverter&gt;&lt;/ref&gt;  t t&lt;/set&gt;  t&lt;/property&gt; &lt;/bean&gt; 那么必须把 class 修改为 org.springframework.format.support.FormattingConversionServiceFactoryBean &lt;mvc:annotation-driven conversion-service=conversionService&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=conversionService class=org.springframework.format.support.FormattingConversionServiceFactoryBean&gt;  t&lt;property name=converters&gt;  t t&lt;set&gt;  t t t&lt;ref bean=myConverter&gt;&lt;/ref&gt;  t t&lt;/set&gt;  t&lt;/property&gt; &lt;/bean&gt; 修改后并不会影响原先的类型转换。 数据校验 数据校验分为前端校验和后端校验。 一般而言，我们会把一些简单的数据校验放在前端进行，这是为了减少客户端和服务器之间的通讯次数，提高用户体验。 比如说，现在很多网站在注册新用户时都必须提供手机号。 对于手机号最简单的校验就是校验它是否是 11 位纯数字。 这个很明显是前端就可以完成的校验，没有必要借助后端。 除此之外，一些复杂的数据校验会放在后端。 注册时的用户名或 id 必须是唯一的，此时必须在后端读取数据库才能完成唯一性校验。 值得一提的是，后端校验包括前端校验。 手机号是否是 11 位纯数字的校验不仅会在前端进行校验，还会在后端进行一次校验。 这是为了防止有些不怀好意之人不通过正常的流程提交数据，而是绕开我们在前端设下的数据校验直接把数据发送到后端。 现在使用的都是前端校验 + 后端校验 的方式。 既能满足用户的体验。 又能保证数据安全。 在这里不讲解前端校验，只讲解后端校验。 在 Spring MVC 中，后端校验使用的是 JSR303。 JSR303（Java Specification Requests—— Java 规范提案）是 Java 为 Bean 数据合法性校验提供的标准框架，包含在 JavaEE 6.0 中 。 其通过在 Bean 属性上添加注解表示约束性，并通过标准的验证接口对 Bean 进行验证。 JSR303: Hibernate Validator 扩展注解: Spring MVC 拥有自己的数据校验框架，同时支持JSR303标准的校验框架。 Spring MVC 本身没有提供 JSR303 的实现，需要导包。 其 Maven 依赖为 &lt;dependency&gt;  t&lt;groupId&gt;org.hibernate&lt;/groupId&gt;  t&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;  t&lt;version&gt;5.1.0.Final&lt;/version&gt; &lt;/dependency&gt; 不要使用太高的版本，可能会存在不兼容的问题。 新建实体类 Person.java public class Person { @NotNull  private Integer id;  @Length(min = 3,max = 10)  private String name;  private Integer age;  private String gender;  @Past  private Date birth;  @Email  private String email; //省略无参构造器，getter/setter 方法和 toString 方法 } 在 Person 类中给各个属性添加了适合的注解 id 应该非空 name 的长度在 3~10 birth 必须是过去的日期 email 必须是合法的邮箱地址 ValidationController.java @Controller public class ValidationController { @Validated  @RequestMapping(/validation)  public String validate(@Valid Person person, BindingResult bindingResult, Model model){  Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();  if(bindingResult.hasErrors()){   System.out.println(登陆失败);   //获取到当前所有的错误   List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors();   for (FieldError fieldError : fieldErrors) {    map.put(fieldError.getField(),fieldError.getDefaultMessage());   }   model.addAttribute(errors,map);   return forward:/login.jsp;  }else{   System.out.println(登陆成功);   return success;  }  } }  方法需要添加 @Validated 注解 需要验证的 bean 对象使用 @Valid 注解标明，Spring MVC 会自动进行验证 BindingResult 存储了错误信息。  从中读取所有的错误信息，放入一个 Map 中，并传入 Model，用于前端回显。  根据是否有错误来决定返回的页面    有错误，返回原页面，让用户重新输入。   无错误，跳转到成功页面。     前端页面需要将错误信息显示出来。 从 request 作用域中读取。 &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  t&lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;%  tpageContext.setAttribute(ctp, request.getContextPath()); %&gt; &lt;body&gt; &lt;form action=${ctp}/validation method=post&gt;  tid：&lt;input type=text name=id&gt;${errors.id}&lt;br&gt;  tname：&lt;input type=text name=name&gt;${errors.name}&lt;br&gt;  tage：&lt;input type=text name=age&gt;${errors.age}&lt;br&gt;  tgender：&lt;input type=text name=gender&gt;${errors.gender}&lt;br&gt;  tbirth：&lt;input type=text name=birth&gt;${errors.birth}&lt;br&gt;  temail：&lt;input type=text name=email&gt;${errors.email}&lt;br&gt;  t&lt;input type=submit value=login&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/08/14/02-usage/",
      "keywords" : "Java, SpringMVC"
    } ,
  
    {
      "title"    : "Java Spring MVC 03——使用方法（三）",
      "category" : "SpringMVC",
      "content": "Java Spring MVC 03——使用方法（三） Spring MVC 返回 JSON 数据 准备工作 导入相关依赖 pom.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;project xmlns=http://maven.apache.org/POM/4.0.0  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation=http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt;  &lt;artifactId&gt;springmv_ajax&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;dependencies&gt;  &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-context&lt;/artifactId&gt;   &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-web&lt;/artifactId&gt;   &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;  &lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;   &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;   &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;   &lt;version&gt;2.5&lt;/version&gt;   &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;   &lt;groupId&gt;javax.servlet&lt;/groupId&gt;   &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;   &lt;version&gt;2.0&lt;/version&gt;   &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;  &lt;dependency&gt;   &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;   &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;   &lt;version&gt;2.10.3&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;  &lt;dependency&gt;   &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;   &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;   &lt;version&gt;2.10.3&lt;/version&gt;  &lt;/dependency&gt;  &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;  &lt;dependency&gt;   &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;   &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;   &lt;version&gt;2.10.3&lt;/version&gt;  &lt;/dependency&gt;  &lt;/dependencies&gt; &lt;/project&gt; 与 JSON 相关的有三个包： jackson-core jackson-databind jackson-annotations Spring MVC 配置文件 springmvc.xml &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;beans xmlns=http://www.springframework.org/schema/beans  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xmlns:context=http://www.springframework.org/schema/context  xmlns:mvc=http://www.springframework.org/schema/mvc  xsi:schemaLocation=http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&gt; &lt;context:component-scan base-package=com.kky&gt;&lt;/context:component-scan&gt; &lt;bean class=org.springframework.web.servlet.view.InternalResourceViewResolver&gt;  &lt;property name=prefix value=/WEB-INF/page/&gt;&lt;/property&gt;  &lt;property name=suffix value=.jsp&gt;&lt;/property&gt;  &lt;/bean&gt;  &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;  &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;/beans&gt; web.xml 配置 DispatcherServlet &lt;?xml version=1.0 encoding=UTF-8?&gt; &lt;web-app xmlns=http://xmlns.jcp.org/xml/ns/javaee  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation=http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd  version=4.0&gt;  &lt;servlet&gt;  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  &lt;init-param&gt;   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;   &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;  &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;  &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt; &lt;/web-app&gt; 正式使用 新建实体类 User public class User { private Integer id;  private String name;  private Integer age;  private String gender; //省略无参构造器，getter/setter 方法，toString 方法 }  先复习一下 Spring MVC 的一般形式 @Controller public class AController {  t  t@RequestMapping(/aRequest)  tpublic String aMethod(){  t //业务逻辑  t treturn 要跳转的页面地址  t} } 即方法的返回值是 String ，然后 return 的是我们要跳转的页面地址。 但是在 JSON 中，我们使用另一种形式 JsonController.java @Controller public class JsonController { @ResponseBody  @RequestMapping(/json)  public List&lt;User&gt; json(){  List&lt;User&gt; list = new ArrayList&lt;User&gt;();  list.add(new User(1,zhangsan,12,男,new Date(),1234@qq.com));  list.add(new User(2,zhangsan2,12,男,new Date(),1234@qq.com));  list.add(new User(3,zhangsan3,12,男,new Date(),1234@qq.com));  return list;  } } 在使用了 @ResponseBody 注解后，我们不再跳转到某个页面去。 而是直接把内容返回到 Http Response Body 中，然后客户端会把内容直接显示。 即原来是 graph LR; A[某页面] --发送请求--&gt; B[服务器] B --跳转--&gt; C[另一个页面] 现在是 graph LR; A[某页面] --发送请求--&gt; B[服务器] B --返回内容并显示--&gt; A 除了 List，@ResponseBody 也可以返回字符串作为响应内容。 @Controller public class OtherController {  @ResponseBody  @RequestMapping(/testResponseBody)  public String testResponseBody(){  return &lt;h1&gt;hello,JSON&lt;/h1&gt;;  } } 通过 ajax 获取 JSON 数据 ajax.jsp &lt;%@ page import=java.util.Date %&gt; &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt;  &lt;script type=text/javascript src=script/jquery-1.9.1.min.js&gt;&lt;/script&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp,request.getContextPath()); %&gt; &lt;body&gt; &lt;%=new Date()%&gt; &lt;a href=${ctp}/json&gt;获取用户信息&lt;/a&gt; &lt;div&gt; &lt;/div&gt; &lt;script type=text/javascript&gt;  $(a:first).click(function () {  $.ajax({   url:${ctp}/json,   type:GET,   success:function (data) {    console.log(data)    $.each(data,function() {    var user = this.id+--+this.name+--+this.age+--+this.gender;    $(div).append(user+'&lt;br/&gt;');    })   }  });  return false;  }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这里引入了一个 js &lt;script type=text/javascript src=script/jquery-1.9.1.min.js&gt;&lt;/script&gt;  测试  点击后 使用 @RequestBody 获取请求体信息 /requestbody.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp,request.getContextPath()); %&gt; &lt;body&gt; &lt;form action=${ctp}/testRequestBody method=post&gt;  &lt;input name=username value=zhangsan&gt;&lt;br&gt;  &lt;input name=password value=123456&gt;&lt;br&gt;  &lt;input type=file name=file&gt;&lt;br&gt;  &lt;input type=submit value=提交&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 在 JsonController.java 添加方法 @RequestMapping(/testRequestBody) public void testRequestBody(@RequestBody String body){  tSystem.out.println(body); }  测试 随便选择某个文件，然后点击提交 username=zhangsan&amp;password=123456&amp;file=20210715123128.png  使用 @RequestParam 注解只能获取请求体中的单个参数 @RequestMapping(/testRequestBody) public void testRequestBody(@RequestParam(username) String username){  tSystem.out.println(username); } 而使用 @RequestBody 可以获取整个请求体 同时@RequestBody能够接受json格式的请求数据： /requestbody2.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;script src=scripts/jquery-1.9.1.min.js&gt;&lt;/script&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp, request.getContextPath()); %&gt; &lt;body&gt; &lt;a href=${ctp}/testRequestJson&gt;发送 JSON 数据&lt;/a&gt; &lt;/body&gt; &lt;script type=text/javascript&gt;  $(a:first).click(function () {  var user = {id: 1, name: zhangsan, age: 12, gender: man};  var jsonuser = JSON.stringify(user);  $.ajax({   url: ${ctp}/testRequestJson,   type: post,   data: jsonuser,   contentType: application/json,   success: function (data) {    alert(data)   }  });  return false;  }) &lt;/script&gt; &lt;/html&gt; 在 JsonController 中添加方法 @RequestMapping(/testRequestJson) public void testRequestJson(@RequestBody User user){  tSystem.out.println(user); } 测试 结果 User{id=1, name='zhangsan', age=12, gender='man'} 使用 HttpEntity 对象获取请求对象 @RequestMapping(/testHttpEntity) public void test(HttpEntity&lt;String&gt; httpEntity){  tSystem.out.println(httpEntity); } 即可获取 Http 请求的所有信息，无需添加注解 测试 [host:localhost:8080, connection:keep-alive, sec-ch-ua:Chromium;v=92, Not A;Brand;v=99, Google Chrome;v=92, sec-ch-ua-mobile:?0, upgrade-insecure-requests:1, user-agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36, accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9, sec-fetch-site:none, sec-fetch-mode:navigate, sec-fetch-user:?1, sec-fetch-dest:document, accept-encoding:gzip, deflate, br, accept-language:zh-CN,zh;q=0.9,en;q=0.8, cookie:name=zhangsan; JSESSIONID=7D7C9C05C14E005A5FC420CDB727B2C0; Idea-18645a00=2aaa6995-3701-4bf7-9c5b-f70fb70ac354; JSESSIONID=9F9DBC7950291B1AEB1E180C8D22A22C] 使用 ResponseEntity 设置响应内容 @RequestMapping(/testResponseEntity) public ResponseEntity&lt;String&gt; testResponseEntity() {  tString str = &lt;h1&gt;test response entity&lt;/h1&gt;;  tHttpHeaders httpHeaders = new HttpHeaders();  thttpHeaders.add(Set-Cookie, name=zhangsan);  treturn new ResponseEntity&lt;String&gt;(str, httpHeaders, HttpStatus.OK); } 测试 可以看到，cookie 中成功设置了 name=zhangsan 文件下载 @Controller public class DownloadController { @RequestMapping(/download)  public ResponseEntity&lt;byte[]&gt; download(HttpServletRequest request) throws Exception {  //获取要下载的路径  ServletContext servletContext = request.getServletContext();  //将相对路径转换为真实路径  String realPath = servletContext.getRealPath(/scripts/jquery-1.9.1.min.js);  //通过io流对文件进行读写  FileInputStream fileInputStream = new FileInputStream(realPath);  byte[] bytes = new byte[fileInputStream.available()];  fileInputStream.read(bytes);  fileInputStream.close();  //将下载内容设置到 ResponseEntity 中  HttpHeaders httpHeaders = new HttpHeaders();  httpHeaders.set(Content-Disposition, attachment;filename=jquery-1.9.1.min.js);  return new ResponseEntity&lt;byte[]&gt;(bytes, httpHeaders, HttpStatus.OK);  } } 文件上传 文件上传时不要直接使用普通的 IO 流上传，很麻烦，而且效率低。 使用 Apache Commons FileUpload，其 Maven 依赖为 &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt;  t&lt;groupId&gt;commons-io&lt;/groupId&gt;  t&lt;artifactId&gt;commons-io&lt;/artifactId&gt;  t&lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt;  t&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  t&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  t&lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; 同样地，Spring MVC 也为文件上传提供了直接的支持，通过即插即用的 MultipartResolver 实现的。 Spring 用 Jakarta Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResovler。 该功能需要手动地在 Spring MVC 配置文件中添加以下配置 &lt;bean id=multipartResolver class=org.springframework.web.multipart.commons.CommonsMultipartResolver&gt;  t&lt;property name=defaultEncoding value=UTF-8&gt;&lt;/property&gt;  t&lt;property name=maxUploadSize value=1024000&gt;&lt;/property&gt; &lt;/bean&gt; 该 bean 对象可以配置很多属性，该案例设置了默认编码格式和最大上传大小。 /upload.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp,request.getContextPath()); %&gt; &lt;body&gt; &lt;form action=${ctp}/upload method=post enctype=multipart/form-data&gt;  描述：&lt;input type=text name=desc&gt;&lt;br&gt;  文件：&lt;input type=file name=file&gt;&lt;br&gt;  &lt;input type=submit value=提交&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;  UploadController.java @Controller public class UploadController { @RequestMapping(/upload)  public void upload(@RequestParam(file) MultipartFile/*[]*/ multipartFile, @RequestParam(value = desc, required =   false) String desc) throws Exception {  //文件描述  System.out.println(desc);  t t  //文件名称  System.out.println(multipartFile.getOriginalFilename());  t t  t t//将文件传输到指定目录  multipartFile.transferTo(new File(d:    file     + multipartFile.getOriginalFilename()));  } }  测试  提交后 多文件上传 直接在 jsp 页面的表单中添加多个 &lt;input&gt; 标签 /upload.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp,request.getContextPath()); %&gt; &lt;body&gt; &lt;form action=${ctp}/upload method=post enctype=multipart/form-data&gt;  描述：&lt;input type=text name=desc&gt;&lt;br&gt;  文件：&lt;input type=file name=file&gt;&lt;br&gt;  文件：&lt;input type=file name=file&gt;&lt;br&gt;  文件：&lt;input type=file name=file&gt;&lt;br&gt;  &lt;input type=submit value=提交&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;  把处理方法的参数改为数组 UploadController.java @Controller public class UploadController { @RequestMapping(/upload)  public void upload(@RequestParam(file) MultipartFile[] multipartFile, @RequestParam(value = desc, required =   false) String desc) throws Exception {  //文件描述  System.out.println(desc);  for (MultipartFile file : multipartFile) {   if(!file.isEmpty()){    //文件名称    System.out.println(file.getOriginalFilename());    //将文件传输到指定目录    file.transferTo(new File(d:    file     + file.getOriginalFilename()));   }  }  } } 记得加入非空判断。 因为用户可以通过页面至多提交三个文件（不一定是三个）。 Spring MVC 拦截器 Spring MVC 提供了拦截器的机制，其种类多种多样，最常用的是 HandlerInterceptor 接口。 顾名思义，HandlerInterceptor 拦截的是 Handler。 什么是 Handler？ 平时用于处理请求的具体方法就是 Handler @Controller public class AController {  t  t@RequestMapping(/aRequest)  tpublic String aMethod(){  //业务逻辑  return 要跳转的页面地址  t} } 这就是 Handler，只不过因为 MVC 架构，很多人在命名时都命名为 Controller 罢了。 就像一个人有本名和外号一样，实际上指的是同一个。 HandlerInterceptor 接口有三个重要方法    method  说明     preHandle()  在 Handler 处理请求前调用。    postHandle()  在 Handler 处理请求后， DispatcherServlet 向客户端返回前调用。    afterCompletion()  在 DispatcherServlet 完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作。   postHandle() 和 afterCompletion() 是没有返回值的。 但是 preHandle() 是有返回值的，而且这个返回值很重要！ 该方法的返回值为 boolean 类型。 当返回值为 false 时，执行完该方法后  不会执行其他拦截器  不会执行该拦截器的其他方法。   拦截器是 责任链模式，一个拦截器连着另一个拦截器，组成一道链条。 当链条在某处被打断后，其剩余的部分将不会执行。 自定义拦截器 实现 HandlerInterceptor 接口，并简单实现三个重要方法。 MyInterceptor.java public class MyInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  System.out.println(this.getClass().getName()+----preHandle);  return true;  } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  System.out.println(this.getClass().getName()+----postHandle);  } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  System.out.println(this.getClass().getName()+----afterCompletion);  } } 此时 preHandle() 的返回值是 true。 在 Spring MVC 的配置文件中配置拦截器 &lt;mvc:interceptors&gt;  t&lt;bean class=com.kky.interceptor.MyInterceptor&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt; 配置好以后，任何请求都会在控制台输出以下信息： com.kky.interceptor.MyInterceptor----preHandle com.kky.interceptor.MyInterceptor----postHandle com.kky.interceptor.MyInterceptor----afterCompletion 如果把 preHandle() 的返回值改为 false。 不会执行剩余的拦截器（如果有的话） 本拦截器的其他方法也不会执行 com.kky.interceptor.MyInterceptor----preHandle 执行顺序 graph TB; A[preHandle()] --&gt; B[某 Handler]; B[某 Handler] --&gt;|执行完毕| C[postHandle()]; C --&gt;|页面跳转| D[afterCompletion()]; B --&gt;|抛出异常| D; 多个拦截器的执行顺序 再添加一个拦截器 public class SecondInterceptor implements HandlerInterceptor { public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  System.out.println(this.getClass().getName() + ----preHandle);  return true;  } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {  System.out.println(this.getClass().getName() + ----postHandle); } public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {  System.out.println(this.getClass().getName() + ----afterCompletion); } } Spring MVC 配置文件 &lt;mvc:interceptors&gt;  t&lt;bean class=com.kky.interceptor.MyInterceptor&gt;&lt;/bean&gt;  t&lt;bean class=com.kky.interceptor.SecondInterceptor&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt; 随便发送某个请求，查看执行顺序： com.kky.interceptor.MyInterceptor----preHandle com.kky.interceptor.SecondInterceptor----preHandle com.kky.interceptor.SecondInterceptor----postHandle com.kky.interceptor.MyInterceptor----postHandle com.kky.interceptor.SecondInterceptor----afterCompletion com.kky.interceptor.MyInterceptor----afterCompletion 可以看到    方法  执行顺序     perHandle()  顺序    postHandle()  逆序    afterCompletion()  逆序   拦截器跟过滤器的区别    区别  过滤器  拦截器     原理  函数回调  java 反射    是否依赖于 servlet 容器  是  否    作用于何种请求  所有请求  action 请求    是否可以访问 action 的上下文  不可以  可以       在 controller 的生命周期中，拦截器可以多次调用  而过滤器只能在web容器初始化的时候初始化一次，后续匹配的所有请求都会经过过滤器来进行过滤   Spring MVC 的国际化操作 如果你的网站需要给不同地区，不同语言的人使用，那么需要实现国际化。 国际化的实现是通过 Locale 类实现的。 该类封装了以下属性  地区  语言  字符集   命名十分严格。 zh_CN.GBK  zh 代表中文  CN 代表中国大陆  GBK 代表所使用的字符集是 GBK   根据客户端的 Locale 自动实现国际化 导包 &lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt; &lt;dependency&gt;  t&lt;groupId&gt;javax.servlet&lt;/groupId&gt;  t&lt;artifactId&gt;jstl&lt;/artifactId&gt;  t&lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; 创建国际化文件 在项目的 resources 目录中创建以下两个文件 login_zh_CN.properties  welcomeinfo=你好 username=姓名 password=密码 btn=登录   login_en_US.properties  welcomeinfo=Hello username=USERNAME password=PASSWORD btn=LOGIN   命名时使用统一的前缀，后缀要严格遵守 Locale 的命名规则（省略字符集）。 可以看到，两个文件一个是中文，一个是英文。 到时候会根据客户端的 Locale 来决定使用哪一份文件中的内容。 修改 Spring MVC 配置文件 springmvc.xml &lt;bean id=messageSource class=org.springframework.context.support.ResourceBundleMessageSource&gt;  t&lt;property name=basename value=login&gt;&lt;/property&gt; &lt;/bean&gt; 刚才两个文件的名字为 login_zh_CN.properties login_en_US.properties 可以看到，在 Spring MVC 配置文件中，我们只配置了文件名的前缀 login。 这是因为后缀是自动匹配的，所以命名 properties 文件时一定要严格遵守命名规则。 添加 Controller @Controller public class I18nController { @RequestMapping(/i18n)  public String i18n(){  return login;  } } 是的，Controller 十分简单，就只是单纯地接受请求，然后直接返回页面，什么操作都没有。 而国际化的处理会由 Spring MVC 帮我们自动完成。 创建页面 一共需要创建两个页面 /index.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp,request.getContextPath()); %&gt; &lt;body&gt; &lt;a href=${ctp}/i18n&gt;国际化页面&lt;/a&gt; &lt;/body&gt; &lt;/html&gt;  /web/WEB-INF/page/login.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;%@ taglib prefix=fmt uri=http://java.sun.com/jsp/jstl/fmt %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp,request.getContextPath()); %&gt; &lt;body&gt; &lt;h1&gt;&lt;fmt:message key=welcomeinfo&gt;&lt;/fmt:message&gt;&lt;/h1&gt; &lt;form action=${ctp}/login method=post&gt;  &lt;fmt:message key=username&gt;&lt;/fmt:message&gt;:&lt;input type=text name=username&gt;&lt;br&gt;  &lt;fmt:message key=password&gt;&lt;/fmt:message&gt;:&lt;input type=text name=password&gt;&lt;br&gt; &lt;input type=submit value=&lt;fmt:message key=btn/&gt;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 该页面取出对应的 properties 文件的内容并显示。 测试  点击后  在浏览器中修改语言和地区，以 Google 为例 添加语言并置顶。 注意：配置文件是 login_en_US.properties ，所以这里必须选择 英文（美国），否则无效。 重新测试，结果 通过超链接手动切换国际化 除了自动实现国际化，很多网站还有这样的功能。 用户可以随意选择语言。 基本步骤与 根据客户端的 Locale 自动实现国际化 相同。 在 jsp 页面通过超链接发送 locale 参数 添加拦截器对请求参数进行处理 修改 jsp /web/WEB-INF/page/login.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;%@ taglib prefix=fmt uri=http://java.sun.com/jsp/jstl/fmt %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;%  pageContext.setAttribute(ctp,request.getContextPath()); %&gt; &lt;body&gt; &lt;h1&gt;&lt;fmt:message key=welcomeinfo&gt;&lt;/fmt:message&gt;&lt;/h1&gt; &lt;form action=${ctp}/login method=post&gt;  &lt;fmt:message key=username&gt;&lt;/fmt:message&gt;:&lt;input type=text name=username&gt;&lt;br&gt;  &lt;fmt:message key=password&gt;&lt;/fmt:message&gt;:&lt;input type=text name=password&gt;&lt;br&gt; &lt;input type=submit value=&lt;fmt:message key=btn/&gt;/&gt; &lt;/form&gt; &lt;a href=${ctp}/i18n?locale=zh_CN&gt;中文&lt;/a&gt;&lt;br&gt; &lt;a href=${ctp}/i18n?locale=en_US&gt;英文&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 在 jsp 页面中添加两个超链接，并发送 locale 参数。 添加拦截器 Spring MVC 自带拦截器 &lt;bean id=localeResolver class=org.springframework.web.servlet.i18n.SessionLocaleResolver&gt;&lt;/bean&gt; &lt;mvc:interceptors&gt;  t&lt;bean class=org.springframework.web.servlet.i18n.LocaleChangeInterceptor&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt; id 必须是 localeResolver，否则无法生效。 自定义拦截器 public class MyLocaleResolver implements LocaleResolver {  @Override  public Locale resolveLocale(HttpServletRequest request) {  Locale locale = null;  String localeStr = request.getParameter(locale);  if (localeStr!=null &amp;&amp; !.equals(localeStr)){   locale = new Locale(localeStr.split(_)[0],localeStr.split(_)[1]);  }else{   locale = request.getLocale();  }  return locale;  } @Override  public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {  throw new UnsupportedOperationException(    Cannot change HTTP accept header - use a different locale resolution strategy);  } } 然后要把拦截器添加到 Spring MVC 中。 注意 使用 xml 方式或注解方式都可以，但是 id 必须为 localeResolver。 否则无法生效。 &lt;bean id=localeResolver class=com.kky.MyLocaleResolver&gt;&lt;/bean&gt; 或 @Component(localeResolver) public class MyLocaleResolver implements LocaleResolver {  t... } 测试  自定义异常处理器 Spring MVC 拥有一套非常强大的异常处理机制，能够处理项目中发生的各种异常。 除此之外，我们还可以自定义异常处理器。 自定义异常处理 ExceptionController.java @Controller public class ExceptionController { @RequestMapping(/exception1)  public String exception(){  int i = 10/0;  return success;  } } 可以看到，这里有一个 除 0 异常。 测试 可以看到，默认情况下会报 500 ，并且打印异常信息。 这样的异常处理明显是对用户不友好的，我们应该在发生异常后跳转到一个页面，并输出简要的错误信息。 新建   web  WEB-INF  page  error.jsp &lt;%@ page contentType=text/html;charset=UTF-8 language=java %&gt; &lt;html&gt; &lt;head&gt;  &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;出错了！&lt;/h1&gt; 错误信息是：${exce} &lt;/body&gt; &lt;/html&gt;  在 ExceptionController.java 中添加异常处理。 @Controller public class ExceptionController { @RequestMapping(/exception1)  public String exception(){  System.out.println(this.getClass().getName());  int i = 10/0;  return success;  } @ExceptionHandler(value = {ArithmeticException.class})  public ModelAndView handlerException1(Exception exception){  ModelAndView mv = new ModelAndView();  mv.setViewName(error);  mv.addObject(exce,exception);  return mv;  } } 注意，handlerException 只对 ExceptionController 中的异常有效。 重新测试，结果  可以用一个方法处理多个异常 @ExceptionHandler(value = {ArithmeticException.class, NullPointerException.class}) public ModelAndView handlerException(Exception exception){  ... } 这样的话，handlerException 就将处理 ArithmeticException 和 NullPointerException 两种异常。 多个异常处理方法 有时候，一个异常会对应多个异常处理方法。 类中可以定义多个异常处理方法。 @Controller public class ExceptionController { @RequestMapping(exception1)  public String exception(){  System.out.println(exception.......);  System.out.println(10/0);  return success;  } @ExceptionHandler(value = {ArithmeticException.class, NullPointerException.class})  public ModelAndView handlerException1(Exception exception){  ModelAndView mv = new ModelAndView();  mv.setViewName(error);  mv.addObject(ex,exception);  return mv;  } @ExceptionHandler(value = {Exception.class})  public ModelAndView handlerException2(Exception exception){  ModelAndView mv = new ModelAndView();  mv.setViewName(error);  mv.addObject(ex,exception);  return mv;  } } 注意： @Controller public class ExceptionController { .... @ExceptionHandler(value = {ArithmeticException.class})  public ModelAndView handlerException1(Exception exception){  ....  } @ExceptionHandler(value = {ArithmeticException.class})  public ModelAndView handlerException2(Exception exception){  ....  } } 这样的定义是不允许的，会报 500 错。 同时还可以定义一个全局的异常处理器。 MyGlobalExceptionHandler @ControllerAdvice public class MyGlobalExceptionHandler { @ExceptionHandler(value = {ArithmeticException.class,NullPointerException.class})  public ModelAndView handlerException1(Exception exception){  ModelAndView mv = new ModelAndView();  mv.setViewName(error);  mv.addObject(exce,exception);  return mv;  } @ExceptionHandler(value = {Exception.class})  public ModelAndView handlerException2(Exception exception){  ModelAndView mv = new ModelAndView();  mv.setViewName(error);  mv.addObject(exce,exception);  return mv;  } } 在添加了 @ControllerAdvice 注解后，该类就变成了全局的异常处理器。 可以处理整个项目中的异常。 注意： 类中定义的异常处理只对本类发生的异常有效。 全局的异常处理器对整个项目的异常有效。 当程序抛出的某异常匹配到多个异常处理方法时，只会执行一个方法。 匹配过程服从以下原则： 优先执行本类中的异常处理方法。 优先执行范围最小的异常处理方法。 举例： 当 ExceptionController 发生除 0 异常时，将执行本类中的 handlerExcepetion1 方法。 @Controller public class ExceptionController { .... @ExceptionHandler(value = {ArithmeticException.class, NullPointerException.class})  public ModelAndView handlerException1(Exception exception){  ....  } @ExceptionHandler(value = {Exception.class})  public ModelAndView handlerException2(Exception exception){  ....  } } 这是因为 handlerException1 处理的是 ArithmeticException 异常，该异常包括除 0 异常。 而且 ArithmeticException 的范围比 handlerException2 处理的 Exception 要小。 @ResponseStatus 注解 这是一个没什么用的注解，随便看看就好。 顾名思义，我们可以使用 @ResponseStatus 注解人为地设置 Response 的状态。 标注在方法上 ExceptionController.java @Controller public class ExceptionController { ... @ResponseStatus(reason = 我就是错了，不知道什么原因, value = HttpStatus.NOT_ACCEPTABLE)  @RequestMapping(/exception2)  public String exception2() {  System.out.println(exception2);  return success;  } ... } 把 HttpStatus 改为 OK @Controller public class ExceptionController { ... @ResponseStatus(reason = 我就是错了，不知道什么原因, value = HttpStatus.OK)  @RequestMapping(/exception2)  System.out.println(exception2);  return success;  } ... } 重新测试 一片空白，页面没有跳转，但是方法是执行了的。 控制台 exception2 所以不推荐把 @ResponseStatus 注解标注在方法上。 标注在类上 自定义异常 UserNameException.java 并添加 @ResponseStatus 注解 @ResponseStatus(reason = 名字错误,value = HttpStatus.NOT_ACCEPTABLE) public class UserNameException extends RuntimeException { } 在 ExceptionController.java 中添加方法 @Controller public class ExceptionController { ... @RequestMapping(/exception3)  public String exception3(String username) {  System.out.println(exception3);  if (admin.equals(username)) {   return success;  } else {   throw new UsernameException();  }  } ... } 测试 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/08/22/03-usage/",
      "keywords" : "Spring MVC, Java"
    } ,
  
    {
      "title"    : "面试题之——算法题中常用的 API",
      "category" : "interview",
      "content": "为了防止笔试中不允许使用 IDE，想不起常用 API 的尴尬。 记录一些常见的 Java API，面试前看一看。 Math    method  功能     double pow(double a, double b)  返回 a 的 b 次方   Map    method  功能     boolean containsKey(Object key)  判断是否含有该键    boolean containsValue(Object value)  判断是否含有该值    V get(Object key)  获得键对应的值    default V getOrDefault(Object key, V defaultValue)  获得键对应的值，如果值不存在，返回默认值    boolean isEmpty()  是否为空    V put(K key, V value)  存储键值对    V remove(Object key)default V remove(K key, V value)  删除键值对    int size()  大小   遍历  Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();    键值   for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){  System.out.println(entry.getKey()+----+entry.getValue()); }    Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) {  Map.Entry entry = it.next();  System.out.println(entry.getKey() + ---- + entry.getValue()); }     键   for (Integer i : map.keySet()) {  System.out.println(i); }    Iterator&lt;Integer&gt; it = map.keySet().iterator(); while (it.hasNext()) {  System.out.println(it.next()); }     值   for (Integer i : map.values()) {  System.out.println(i); }    Iterator&lt;Integer&gt; it = map.values().iterator(); while (it.hasNext()) {  System.out.println(it.next()); }     HashMap 没什么特殊的 TreeMap 需要排序时使用  构造方法  升序   Map&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;((o1, o2) -&gt; {  return o1 - o2; });     降序   Map&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;((o1, o2) -&gt; {  return o2 - o1; });       method  功能     boolean containsKey(Object key)  判断是否含有该键    boolean containsValue(Object value)  判断是否含有该值    V get(Object key)  获得键对应的值    default V getOrDefault(Object key, V defaultValue)  获得键对应的值，如果值不存在，返回默认值    boolean isEmpty()  是否为空    V put(K key, V value)  存储键值对    V remove(Object key)default V remove(K key, V value)  删除键值对    int size()  大小  ",
      "url"      : "https://kekaiyuan.github.io//2021/09/03/api/",
      "keywords" : "interview, API"
    } ,
  
    {
      "title"    : "非对称加密",
      "category" : "cate1",
      "content": "非对称加密 title: 非对称加密流程 participant 客户端 as A participant 服务器 as B Note over A: 生成密钥对 A A-&gt;B: 发送公钥 A Note over B: 生成密钥对 B B-&gt;A: 发送公钥 B Note over A: 使用  公钥 B 加密  数据 A-&gt;B: 发送密文 Note over B: 使用  私钥 B 解密  数据 Note over B: 使用  公钥 A 加密  数据 B-&gt;A: 发送密文 Note over A: 使用  私钥 A 解密  数据 非对称加密的安全性极高。 在网络中传递的只有公钥，并没有传递私钥。 第三方即使获取了公钥，也是无法解开密文的，密文必须使用私钥解密。 但是非对称加密的效率极低，比对称加密慢数千倍。 所以往往混合使用 使用非对称加密传递对称加密的密钥 使用对称加密传递一般数据 中间人攻击 非对称加密看上去很美，但它真的就是完美无缺的了吗？ 非对称加密依然可以被破解。 title: 中间人攻击 participant 客户端 as A participant 中间人 as C participant 服务器 as B participant B Note over A: 生成密钥对 A A-&gt;B: 发送公钥 A Note over B: 生成密钥对 B B-&gt;C: 发送公钥 B Note over C: 截取公钥 B Note over C: 生成密钥对 C C-&gt;A: 发送公钥 C Note over A: 使用  公钥 C 加密  数据 A-&gt;C: 发送密文 Note over C: 截取密文 Note over C: 使用  私钥 C 解密  数据 Note over C: 修改明文 Note over C: 使用  公钥 B 加密  修改后的明文 C-&gt;B: 发送修改后的密文 Note over B: 使用  私钥 B 解密  修改后的密文 Note over B: 执行错误操作 真实案例  南京90后小伙从网上学来了一种小技巧，只花1分钱就能成功充值上百元话费，结果因涉嫌盗窃罪被警方批捕。 据央视新闻报道，小伙无业，在一个“薅羊毛”的聊天群里，于是“先是用1分钱充了200元成功到账，然后就开始反复充值，一共到账58笔、26000余元。” 除了这名90后小伙，聊天群的其他数十位网友，仅仅两天就通过这个攻略，“薅”走了160多万元话费。 经调查，江苏某电子商务公司的网上话费充值平台由于没有设置校验环节，导致支付环节存在技术漏洞，从而被黑客利用。 日前，小刘等人因涉嫌盗窃罪，被南京市检雨花台区检察院正式批捕。 这就是中间人攻击。 原先  甲通过平台充值 200 元话费，平台会根据甲提供的支付手段（银行卡/支付宝/微信钱包）扣除 200 元。   中间人攻击  乙先通过平台充值 200 元话费，然后截取平台发送给支付方的消息，修改金额为 0.01 元。  并且平台没有设置校验环节。    我给用户充值了 200 元，但是我有没有扣除用户 200 元呢？     解决方法 中间人攻击的关键在哪儿？ 在于客户端无法分辨服务器和中间人。 服务器说“我是服务器”。 中间人也说“我是服务器”。 最终客户端使用了中间人的公钥来加密明文，使得明文被中间人修改了。 在现实生活中，如何分辨一个人呢？ 要求他出示身份证，用机器扫描这张身份证是不是真的。 再人脸识别这个人和身份证是否匹配。 在网络中，也有类似于身份证的东西——证书。 最正规，最值得信赖的证书是由 CA（数字证书颁发机构） 颁发的。  这是最权威的，在互联网类似于国家背书的身份证一样。   技术能力强的程序员可以自己实现证书。  这个证书就没什么可信度了，类似于街头的小公司。    有的小公司虽然小，但是是个正经公司。   有的是皮包公司。   有的是传销组织。   ……     对于一般用户来说，他们不需要担心自己的电脑（即客户端）合不合法，他们只担心访问的网站（服务器）合不合法。 客户端发出请求后，服务器会在响应报文中放入自己的数字证书，以便客户端检查得到的消息是否是正确的。 各类浏览器都会实现对于证书的解析，有问题的会进行如下提示： 这就是证书有问题的网站：它无法证明它是自己。 尽量不要使用此类网站，如果一定要使用，请注意： 谨慎填写任何有用的信息，包括但不限于  个人信息  任何账号密码   谨慎进行任何金钱操作。 具体实现 我们已经知道了非对称加密和解决方法，接下来看一看具体实现。 通过仔细观察中间人攻击的流程，我们可以发现两个关键点： 中间人把服务器的公钥换成了自己的。 中间人修改了明文。 所以要防御中间人攻击，我们必须解决这两点。 数字证书 数字签名 数字证书 数字证书中到底有什么呢？ 数字证书中存储了网站的各种相关信息（包括域名）。 最重要的是，它存储了网站的公钥。 原本，我们通过网络直接传递公钥。 但现在，我们通过数字证书传递公钥。  服务器通过提交各类信息和自己的公钥向专业机构申请证书。 专业机构在验证信息后，会形成证书。 并且将证书使用自己的私钥加密（机构也有属于自己的密钥对）。 专业机构将加密后的证书交给服务器，服务器之后发送响应报文时会带上这张证书。 客户端（浏览器）有一个证书管理器，其中有受信任的根证书颁发机构列表。 客户端收到响应报文后，会在列表中寻找能解开数字证书的公钥。 一般而言，会发生以下两种安全问题：  证书的颁发机构不受信任。  证书的内容被修改了。   如果证书没问题，则客户端使用证书中记载的服务器的公钥解开报文。 数字签名 数字签名又称为摘要。 为了防止正文不被修改，我们往往采用数字签名（又称为摘要）的方式。 将整篇正文做 Hash 运算，得到一个散列值（一般是 128 位）。 使用发送方的私钥将签名加密，附在正文后一起发送。 接收方收到数据后，先使用发送方的公钥将正文和签名都解开。 接收方再做一遍 Hash 运算，把结果和收到的签名进行比对。  一致：说明正文没有发生修改。  不一致：说明正文被修改了。   这种方法是很难破解的： 不同的内容很难有一样的散列值。 我是张三1和我是张三2的散列值完全不一样。 即使散列值相同了，修改后的内容大概也是一团糟。  我是张三。 好的，你是张三。  $#^^*(**(&amp;^%$#%@#%*&amp;(*))) 不好意思，我听不懂。  此时接收方是无法识别的。   数字证书就采用了数字签名的方式保证自身的正确性。  用机构的私钥加密。  用机构的公钥解密。   很多网站在传递数据时也会使用数字签名。 ",
      "url"      : "https://kekaiyuan.github.io//2021/09/08/asymmetric/",
      "keywords" : "keyword1, keyword2"
    } ,
  
    {
      "title"    : "Commit Message 之 Angular 规范",
      "category" : "CodeStandards",
      "content": "Commit Message 之 Angular 规范 序言 规范化的 Commit Message 有如下好处： 使阅读者清晰地知道每个 commit 的变更内容。 基于 Commit Message 进行过滤查找。 基于 Commit Message 生成 Change Log。 为特定类型的 Commit Message 设置触发器，使其能够触发构建或者发布流程。 feat, fix 触发 CI 流程。  确定语义化版本的版本号。      Commit Message 类型   映射版本        fix   PATCH      feat   MINOR      带有 BREAKING CHANGE   MAJOR     Commit Message 规范有许多种，Angular 规范是使用者最多的。 Angular 规范是语义化的 所有的 Commit Message 都应该属于某个确定的，有意义的类型，使其通过类型在语义上可读。 Angular 规范是规范化的 所有的 Commit Message 必须遵循预先定义好的规范，这样做除了增加可读性，更使得我们可以通过各类工具来管理。 在 Angular 规范中，Commit Message 包含以下三个内容： Header Body Footer &lt;type&gt;[optional scope]: &lt;description&gt; // 空行 [optional body] // 空行 [optional footer(s)] 要点如下： Header 是必需的，而 Body 和 Footer 可以省略。 [optional scope] 代表作用域，可省略，使用时用()括起来。 &lt;type&gt;[optional scope] 后紧跟 : 号，: 号后紧跟一个空格。 两个空行也是必不可少的。 Commit Message 并不是越长越好，为了保证可读性，一般会将其限制为 50/72/100 个字符。 以下是一个符合 Angular 规范的 Commit Message： fix($compile): couple of unit tests for IE9 # Please enter the Commit Message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # On branch master # Changes to be committed: # ... Older IEs serialize html uppercased, but IE9 does not... Would be better to expect case insensitive, unfortunately jasmine does not allow to user regexps for throw expectations. Closes #392 Breaks foo.bar api, foo.baz should be used instead Header Header 部分只有一行，包含三个字段：    type  必选    scope  可选    subject  必选   type type 用来说明 Commit Message 的类型，可以归为两大类 Development 一般指项目管理类的变更，不会影响最终用户和生产环境的代码。 比如 CI 流程、构建方式等的修改。 遇到这类修改，通常也意味着可以免测发布。 Production 这类修改会影响最终的用户和生产环境的代码。 提交时一定要慎重，做好充足的测试。   类别  类型  说明    Production  feat  新增功能    Production  fix  修复 BUG    Production  perf  提高代码性能的变更    Production  refactor  其他代码类的变更，不属于 feat, fix, perf 和 style。例如简化代码、重命名变量、删除冗余代码。    Development  style  代码格式类的变更。 t例如格式化代码，删除空行等。    Development  test  新增测试用例或更新现有测试用例。    Development  ci  持续集成和部署相关的改动。例如修改 Jenkins, GitLab CI 等 CI 配置文件或者更新 systemed unit 文件。    Development  docs  文档类的更新。例如修改用户文档或者开发文档等。    Development  chore  其他类型。例如构建流程、依赖管理或者辅助工具的变动等。   Angular 规范所定义的九种类型非常地全面，完全可以满足大部分人的使用需求。 当然，你可以自定义专属的 type。 type 是什么不重要，重要的是保证项目中的每个 Commit Message 都是合乎 type 定义的。 scope subject subject 是 commit 的简短描述。 如果使用英文： 必须以动词开头 使用现在时 不能加英文句号 当然，使用英文是有一定要求的。 提交人的英文要好，进行准确地表达。 阅读者的英文也得好，能够看懂 Commit Message。 所以使用中文也是可以的。 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2021/11/11/angular/",
      "keywords" : "Commit Message, Angular"
    } ,
  
    {
      "title"    : "数据结构——十大排序算法",
      "category" : "数据结构",
      "content": "数据结构——十大排序算法 冒泡排序 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2022/02/07/sort/",
      "keywords" : "数据结构, 排序"
    } ,
  
    {
      "title"    : "微服务架构——微服务简介",
      "category" : "微服务",
      "content": "微服务技术对比       Dubbo  Spring Cloud  Spring Cloud Alibaba     年份             注册中心  Zookeeper,Redis  Euraka,Consul  Nacos,Euraka    服务远程调用  Dubbo 协议  Feign（http协议）  Dubbo,Feign    配置中心  无  Spring Cloud Config  Spring Cloud Config,Nacos    服务网关  无  Spring Cloud Gateway,Zuul  Spring Cloud Gateway,Zuul    服务监控和保护  dubbo-admin（功能弱）  Hystrix  Sentinel   Dubbo Dubbo 的诞生时间很早，所以比起目前主流的微服务架构少了很多组件。 没有配置中心和服务网关 Zookeeper 是集群管理工具，Redis 是缓存 这两个都不是专业的注册中心，Dubbo 只是用这两个工具实现了简单的注册中心 在服务监控和保护方面，自带了 dubbo-admin，但是功能非常弱，只有基础功能 它的重点是提出了服务远程调用的概念，并且定义了严格的 dubbo 协议。 在项目量级不够时，可以使用 Dubbo 实现简单的分布式服务。 Spring Cloud 目前全世界范围内最流行的微服务框架。 Spring Cloud 除了把各种第三方公司的组件整合进来，还做了一个很重要的事——基于 SpringBoot 实现了组件的自动装配，简化流程，实现了良好的开箱即用体验。 开发中一定要注意 Spring Cloud 和 Spring Boot 两者版本是否兼容。 Spring Cloud Alibaba Dubbo 并不是一套成熟的微服务架构，所以阿里在经过一段时间后，也是推出了属于自己的微服务架构——Spring Cloud Alibaba。 既然开头是 Spring Cloud，说明 Spring Cloud Alibaba 是继承于 Spring Cloud 的，很多东西一脉相承。 除此之外，Spring Cloud Alibaba 还把 Dubbo 整合了进来。 所以 Spring Cloud Alibaba 可以视为 Dubbo 和 Spring Cloud 两种微服务架构的整合版。 比如 Nacos 即支持 Dubbo，又支持 Feign。 Spring Cloud Alibaba 最近的热度越来越高，有赶超 Spring Cloud 的趋势。 企业需求 当今企业的架构需求可以概括为以下四种：       技术栈  服务接口风格  服务调用方式     Spring Cloud+ Feign  Spring Cloud  Restful  Feign    Spring Cloud Alibaba+ Feign  Spring Cloud Alibaba  Restful  Feign    Spring Cloud Alibaba+ Dubbo  Spring Cloud Alibaba  Dubbo  Dubbo    Dubbo  Dubbo  Dubbo  Dubbo   源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2022/02/07/introduce/",
      "keywords" : "微服务简介"
    } ,
  
    {
      "title"    : "read——《唤醒护理》读后感",
      "category" : "read",
      "content": "21 世纪 10 年代，是国内互联网行业蓬勃发展的一年。 诸多行业形成了寡头格局，搜索引擎是百度，社交软件是腾讯，电商是阿里和拼多多，短视频平台是抖音、快手……得益于互联网的种种特性，这些巨头都赚得盆满钵满，催生了无数的亿万富翁。 除了新兴的互联网企业外，无数传统行业公司也开始进行技术转型，与互联网相结合，尝试在新时代中乘上浪头。 这个时代有个响亮的名字——互联网 +，+ 什么不重要，重要的是必须要有互联网，这是这个时代唯一的根，其它的只是延伸出的枝叶。 尽管许多行业已经形成了半垄断格局，新入行的企业唯一的生存之道只有挑拣一些大企业还未关注到的细节，努力耕耘，在这个垂直领域中做精做强，然后以一个好价格，把自身卖给大企业。 想和大企业硬碰硬，那无疑是鸡蛋碰石头，粉身碎骨。 而有些行业，尚处于迷雾之中，竞争十分激烈，鹿死谁手尚未得知。 医疗行业就是其中一个，也是蕴藏价值十分巨大的一个行业。 毫无疑问，医疗是涉及全中国上下十四亿人的一个巨型行业，谁能分得一杯羹，谁就将收获无尽的财富。 我曾入职过一家做医疗搜索引擎的公司，这家公司面向消费者，试图开发一个真实、绿色、权威的搜索引擎，帮助用户解决身边的医疗问题。 这个搜索引擎都有什么功能呢？可以查询医院、医生和药品的数据，并且从这三大块数据延伸出了无数的服务。 经过亲身实践后，我个人的理解是这样的路在中国还行不通。 中国最大的医疗问题，是看病难，老百姓没有地方看病，是医院数量远小于病人群体的难题。 病人知道得再多也没有用，他抢不到号。有些大医院的专家号，排到几个月后都不是什么稀罕事。 医疗行业当下的入局之道，是从企业入手，从医院入手，使用互联网解放从医人员，提高医院的生产力，使得其可以接收更多的病人。 这也是当今市场最需要的东西，国家也出台过许多文件和政策，推动医院的信息化建设。 医院是一个非常复杂的结构体，内部可以拆分为多个子系统。 现在这些面向医院的医疗企业，也大多只在一个垂直领域深耕，还没有哪家企业可以大包大揽地说它可以负责一个医院所有部门的信息化建设。 有做供应链的，有生产手术辅助设备，有大型的陪护公司…… 在 2022 年 2 月 14 日，我入职了连帆科技，这依然是一家医疗企业，它所针对的领域是护患领域，即患者的护理。 传统护理的两大缺陷： 病情监控不及时 病人经历手术后，会陷入一段时间的危险期。在此期间内，一些手术带来的后遗症随时会带走病人的生命，其中最常见的就是出血和感染。 所以此时需要有人时刻关注病人的各项指标：心跳、血压、体温…… 这项工作不可能由医生来做，只能由护士来做。 而传统护理在这一方面，病人处于被动地位，他只能期冀于护士多多走动，多关心自己，以方面各种潜在危险。 除此之外，陪同在病人身边的更多时候是不懂医的家属。 当病人的身体指标走向异常时，家属们并没有意识到危险，从而耽误最好的治疗时机。 教育指导缺位 手术的成功，除了医生的参与，更需要病人的参与。饮食和生活习惯，可能会导致走向两个截然不同的结果。 这个事情在过去是缺失的，医生出于事务的繁忙，往往只能对病人做一些简单的交待，详细的教育指导，需要由护士搭配完成。 一个很常见的情况是，很多病人在术后会安静地卧床，不进行任何地活动，但这往往会导致肌肉萎缩。 现在有许多康复体操，动作很小，幅度很轻，不会影响病人的伤痛处，但是能很好地活动肌肉，避免肌肉萎缩，这正是护士需要教给病人的。 除此之外还有很多功能训练，能够帮助病人快速恢复，饮食方面亦如此。 过于死板 还有一个比较常见的问题是，在医疗方面，许多问题都显得过于一刀切了。 人和人之间是不同的，每个人的各项身体能力不一样，导致他们的恢复速度也不一样。 比如说经历手术后，病人需要经历一段时间才能够进食或喝水。 这个时间段在不知经历怎样的历程后，变成了一个十分统一的数字，6 小时内不能喝水，24 小时内不能进食。 这是一件很不合理的事情，仔细想想，年轻人和老人的恢复速度能一样吗，运动爱好者和宅男的恢复速度呢？ 很明显，这是一个因人而异的问题。 当肠胃恢复蠕动后，即可进食喝水。 关键点在于是否能够听到病人的肠鸣音。 但是护士们很少去听肠鸣音，更多的是不会。 在国外，随身携带听诊器的往往是护士，而不是医生。 还有一个常见的问题就是何时能够下地走路，也是陷入了一样的窘境，一个因人而异的问题，却诞生出了一个通用的标准。 这两大缺陷只要是经历住院的人都深有体会，无论你是病人，还是陪护。 结果也很显而易见 病人恢复延迟 不合格的护理，导致病人恢复时间变长，像术后因为并发症经历更大手术的严重案例也并不是没有发生过。 这会导致病人超预期地占用医院资源，导致医院的生产力下降。 同时也浪费了病人的时间，影响了病人正常应有的生活和工作节奏。 医疗环境恶劣 因为护理现状的缺陷，所以导致一个病人往往需要多位家属和护工。有钱人家可以住在医院附近的酒店，但是更多的穷人则只能睡在楼梯，大厅等地方，导致医院人满为患，不负重荷，环境脏乱。尤其是空气浑浊，很容易发生交叉感染，对呼吸病患者尤其不友好。 最终结果：各方面都不满意 病人不满意 护士只是按规章办事，严格遵循医嘱，病人并没有感受到贴心的关照。 医生不满意 医生普遍感觉护士就只是打针输液，执行医嘱，没有实现更多的价值。 护士向医生报告病情有两大特点：  死板地转述病人的状况，没有自己的判断，只是充当了一个传话筒。  护士只负责观察生命体征是否正常，而当病人生命体征不正常时，其实已经处于一个很危险的状况了，就算及时联系上医生，等医生赶到时，往往也错过了最佳的时机，接下来的就是生死未卜的尝试了。 医生最怕的就是规定时间之外的，护士的电话，尤其是在凌晨。   护士也不满意 挣钱少，干的活又脏又累，也没有一个良好的晋升通道。 很多护士往往会选择跳槽，从事医疗相关的工作，例如销售。 对症下药 护理人员数量不足 美国医院护患比是 5:1，甚至可以达到 6:1。 而我国的护患比普遍小于 0.4:1。 所以有相当一部分护士，他们不是不想不做，而是没有办法做好。 过度治疗占用大量时间 过去我国存在一个很严重的问题：过度治疗。 一些不良医生为了钱财，会给病人开出超出实际的药量，不但没有效果，甚至会产生副作用。 而用药是需要护理人员执行的，特别是打针输液。 这一事实无疑也加重了护理人员的负担。 当然，这一情况在近年有很大的改善。 专业技能不足 很多护士缺少专业技能的学习和培训，导致他们无法对病人做出专业的护理。 病人的心理状态，很多病人会产生轻生的念头，并且会在冲动之下付诸行动。 但是自杀行为是有迹可循的，比如拒绝交流，拒绝进食，拒绝治疗。 所以这需要护士除了医学知识以外，更应该懂一些基本的心理学，能够判断病人的心理状态。 护士积极性低 护士收入低 大锅饭 医疗是一个十分传统的行业。互联网诞生多少年了，医疗行业才开始接受互联网，从此也可见一斑。 许多医院现在内部依然奉行论资排辈那一套，要么学历高，要么资历高，除此之外，别无他法。 在这种情况下，护理工作做得好不好似乎也不那么重要了。 同工不同酬 很多医院的护士分为编制内和编制外，编制内的护士各项工资和福利能达到编制外护士的两倍。 编制外护士是一个非常大的群体，在某些医院，能极端地达到 80% 的占比。 职业生涯缺乏设计 职业荣誉感低 工作内容过于重复，十分枯燥。 医护配合被动机械 医生下什么医嘱，护士就执行，也不追究背后原因，更不会尝试对其提出建议。 查房时，医生查医生的，护士查护士的，护士缺失了很宝贵的学习机会。 排版僵化死板 有些医院排班并没有考虑实际情况，做出合理的排班。 而是很死板的一刀切。  功能化排班 将护士按照负责内容分为几类： 比如说把一天分为三个时间段，每个时间段 8 个小时。 很明显，早上比下午忙，因为有很多病人会选择早上出院和住院。   从病本位到人本位的转变 源码链接 该文章源码链接 Github ",
      "url"      : "https://kekaiyuan.github.io//2022/02/14/wake-up-the-nurse/",
      "keywords" : "医疗，护理"
    } ,
  
    {
      "title"    : "Windows",
      "category" : "Windows",
      "content": "常用命令 查看端口 netstat -ano | findstr 端口号 查看进程 tasklist | findstr 进程号 杀死进程 taskkill /f /t /im 进程名 ",
      "url"      : "https://kekaiyuan.github.io//wiki/Windows/",
      "keywords" : "Windows"
    } ,
  
    {
      "title"    : "Android Studio",
      "category" : "Android",
      "content": "本文主要记录 Android Studio 的使用技巧等，使用过程中遇到的问题详见我的另一篇博客 Android Studio 遇到问题集锦。 快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command 导航与跳转    功能  快捷键 for win  快捷键 for mac     Find Action  C-S-a  Cmd-S-a    最近使用的文件  C-e  Cmd-e    Outline  C-F12  Cmd-F12    定位到导航条  M-Home  Cmd-Up    快速打开类定义  C-n  Cmd-n    跳转至指定符号  C-S-M-n  Cmd-S-M-n    快速打开文件  C-S-n  Cmd-S-o    在…中选定当前文件  M-F1  M-F1    最近编辑过的文件  C-S-e  Cmd-S-e    打开光标所在变量类定义  C-S-b  Cmd-S-b    跳到变量/函数/类定义  C-b/鼠标左键  Cmd-b/鼠标左键/Down    导航 Back/Forward  C-M-Left/Right  Cmd-[/]    Super Method  C-u  Cmd-u    Implementations  C-M-b  Cmd-M-b    Method Hierarchy  C-S-h  Cmd-S-h    Type Hierarchy  C-h  C-h    Call Hierarchy  C-M-h  C-M-h    Find Usages  M-F7  M-F7    Show Usages  C-M-F7  Cmd-M-F7    搜索 Everywhere  双击 S  双击 S    搜索文本  C-S-f  Cmd-S-f    打开文件所在目录  M-F1 8  M-F1 8    打开设置  C-M-s  Cmd-,   切换至指定的工具窗口    功能  快捷键 for win  快捷键 for mac     Project  M-1  Cmd-1    Terminal  M-F12  M-F12    Editor  Esc  Esc   编辑    功能  快捷键 for win  快捷键 for mac     注释/取消注释（//）  C-/  Cmd-/    注释/取消注释（/**/）  C-S-/  C-S-/    格式化代码  C-M-l  Cmd-M-l    智能 Import  C-M-o  C-M-o    Undo  C-z  Cmd-z    Redo  C-S-z  Cmd-S-z    删除行  C-y  Cmd-x    复制行  C-c  Cmd-c    复制当前行到下一行  C-d  Cmd-d    在下面另起一行  S-Enter  S-Enter    在上面另起一行  C-M-Enter  Cmd-M-Enter    上/下移动代码行  M-S-Up/Down  M-S-Up/Down    上/下一处引用  C-M-Up/Down  Cmd-M-Up/Down    关闭浮动窗口  S-Esc  S-Esc    单步  F8  F8    步入  F7  F7    继续执行  F9  Cmd-M-r    执行直到返回  S-F8  S-F8    执行到光标处  M-F9  M-F9    运行当前应用  S-F10  C-r    调试当前应用  S-F9  C-d    开/关断点  C-F8/鼠标左键  Cmd-F8    查看所有断点  C-S-F8  Cmd-S-F8    自动生成  M-Insert  Cmd-n    隐藏底部视图  S-Esc  S-Esc    删除一个单词  C-Backspace  M-delete    重构 - 重命名  S-F6  S-F6   注：  在 Windows 下格式化代码的 Ctrl+Alt+l 和 QQ 锁热键冲突了，我去 QQ 的设置里删除了QQ 锁热键。 在 Windows 下打开 Settings 的 Ctrl+Alt+s 与 QQ 打开消息盒子热键冲突了，我删除了 QQ 里的该热键。 折叠    功能  快捷键 for win  快捷键 for mac     折叠当前代码块  C-S-.       展开当前代码块  鼠标左键       折叠当前折叠区域  C–       展示当前折叠区域  C-+      小技巧 快速在 Activity/Fragment 与 Layout 文件之间跳转 在 Activity/Fragment 里点击类名前的小图标跳转到关联的 Layout XML 文件： 在 Layout XML 文件里点击根节点前的小图标跳转到关联的 Activity/Fragment： 插件  android-styler Android Studio / IDEA plugin that helps to create styles   Alibaba Java Coding Guidelines 阿里巴巴 Java 代码规范检测插件   Android Parcelable Code Generator 一键自动生成 Parcelable 代码   Lombok Plugin Lombok 注解支持   GsonFormat 根据 Gson 库使用的要求，根据 Json 数据生成 Java 实体   intellij-javadocs 自动生成/删除指定区域或文件的 javadoc。 打包  Gradle编译打包小结 Gradle构建Android项目 设置 此部分与 Intellj IDEA 通用。 在工程视图里隐藏指定类型文件 比如要隐藏 Vim 打开文件产生的 *.swp 文件，操作步骤：  在 Android Studio 里打开 File - Settings - Editor - File Types；   在 Ignore files and folders 里加上 *.swp，点 OK 保存。 屏蔽 IDE 的某些弹出通知 有些 IDE 通知经常弹出，而你却并不想看到它，比如 Usage Statistics，Vcs Notifications 等，屏蔽步骤：  在 Android Studio 里打开 File - Settings - Appearance &amp; Behavior - Notifications；   在界面上找到你想屏蔽的 Group，将 Popup 列改为 No popup，点 OK 保存即可。 定制自动生成的 Getter、Setter 默认行为下，如果一个类有成员变量 mUser，那么生成的 Getter/Setter 的名字会叫做 getmUser 和 setmUser，但我期望的是 getUser 和 setUser，这可以通过修改设置来实现：  在 Android Studio 里打开 File - Settings - Editor - Code Style - Java   在右侧找到 Code Generation 这个 tab，在 Naming 的 Prefer longer names 里，field 的 Name prefix 里填上 m，Static field 的 Name prefix 里填上 s。  设置 logcat 缓冲区条数 logcat 默认缓冲区条数不大，在日志比较多的时候经常出现想要的信息被冲掉的情况，所以一般都将缓冲区条数设置大一些，方法：  关闭 Android Studio；   给 Android Studio 安装目录下的 bin/idea.properties 文件添加如下内容： idea.cycle.buffer.size=1024000   这个数字可以根据需求修改。   启动 Android Studio。 设置生成注释时的 author 默认情况下文件头注释里的 author 是当前登录操作系统的用户名，如 Administrator 或 Lenovo 等，如果我们想替换成自己的名字，方法是打开 Android Studio 可执行程序，比如 studio64.exe 同目录下的 studio64.exe.vmoptions，在最下面加入这样一行： -Duser.name=mazhuang 然后重新启动 Android Studio 即可。 此方法同样适用于 IntelliJ Idea，修改 idea64.exe.vmoptions 即可。 修改新建 Activity 的默认布局 现在新建 Activity 等，layout 文件里的默认布局为 ConstraintLayout，这个布局被吹得神乎其技，但我还没有用惯……所以希望新建 Activity 的默认布局改为 RelativeLayout。 在 StackOverflow 上搜索到解决方案： 链接：How to switch from the default ConstraintLayout to RelativeLayout in Android Studio 简述：  找到 Android Studio 安装目录，打开子目录 plugins/android/lib/templates/activities/common/root/res/layout，在下面应该能看到 simple.xml.ftl 文件，这就是我们新建 Activity 时的 layout 模板了；   备份 simple.xml.ftl 文件；   打开 simple.xml.ftl 文件，可以看到如下内容：  &lt;?xml version=1.0 encoding=utf-8?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android=http://schemas.android.com/apk/res/android xmlns:tools=http://schemas.android.com/tools xmlns:app=http://schemas.android.com/apk/res-auto android:layout_width=match_parent android:layout_height=match_parent &lt;#if hasAppBar &amp;&amp; appBarLayoutName??&gt; app:layout_behavior=@string/appbar_scrolling_view_behavior tools:showIn=@layout/${appBarLayoutName} &lt;/#if&gt; tools:context=${packageName}.${activityClass}&gt; &lt;#if isNewProject!false&gt; &lt;TextView &lt;#if includeCppSupport!false&gt;  android:id=@+id/sample_text &lt;/#if&gt;  android:layout_width=wrap_content  android:layout_height=wrap_content  android:text=Hello World!  app:layout_constraintBottom_toBottomOf=parent  app:layout_constraintLeft_toLeftOf=parent  app:layout_constraintRight_toRightOf=parent  app:layout_constraintTop_toTopOf=parent /&gt; &lt;/#if&gt; &lt;/android.support.constraint.ConstraintLayout&gt;   将这些内容修改为：  &lt;?xml version=1.0 encoding=utf-8 &lt;RelativeLayout xmlns:android=http://schemas.android.com/apk/res/android xmlns:tools=http://schemas.android.com/tools android:layout_width=match_parent android:layout_height=match_parent &gt; &lt;/RelativeLayout&gt;   重启 Android Studio。 同理，如果要修改新创建的 BlankFragment、ListFragment 等的默认布局，可以在 Android Studio 安装目录下的 plugins/android/lib/templates/other 下找到对应的模板内容并修改。 这样修改之后，会导致一个问题，就是 Android Studio 升级会失败，提示： Some conflicts were found in the installation area. Some on the conficts below do not have a solution, so the patch cannot be applied. Press Cancel to exit.   File  Action  Problem  Solution     plugins/android/lib/templates/activities/common/root/res/layout/simple.xml.ftl  Validate  Modified  NONE   解决方案： 将备份的文件贴回去，然后等 Android Studio 升级完成之后再改成我们想要的版本即可。 安装 Android Studio 后不显示 logcat 窗口 新建或打开一个简单的 Android 工程，编译运行后，窗口就会自动出来了。 其它信息 Android Plugin 与 Gradle 版本对应 https://developer.android.com/studio/releases/gradle-plugin.html ",
      "url"      : "https://kekaiyuan.github.io//wiki/android-studio/",
      "keywords" : "Android, Android Studio"
    } ,
  
    {
      "title"    : "Axure",
      "category" : "tools",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command 常用操作    功能  Windows  Mac OS X     当前页面下新建页面  C-Return       预览  F5       生成 HTML 文件  F8       置于顶层  C-S-]       置于底层  C-S-[       上移一层  C-]       下移一层  C-[       开关左侧功能栏  C-M-[       开关右侧功能栏  C-M-]      操作多个元件    功能  Windows  Mac OS X     左对齐  C-M-l       左右居中  C-M-c       右对齐  C-M-r       顶部对齐  C-M-t       上下居中  C-M-m       底部对齐  C-M-b       组合  C-g     ",
      "url"      : "https://kekaiyuan.github.io//wiki/axure/",
      "keywords" : "Axure RP"
    } ,
  
    {
      "title"    : "Badminton",
      "category" : "Hobbies",
      "content": "视频  李在福《Play To Win》完整版   李在福《追球》全集 图文  超全羽毛球技术图解 公众号  和蔡赟聊羽毛球 微信号：caiyunliaoyumaoqiu   羽毛球 微信号：yu-mao-qiu  ",
      "url"      : "https://kekaiyuan.github.io//wiki/badminton/",
      "keywords" : "羽毛球"
    } ,
  
    {
      "title"    : "中文文案排版指北（简体中文版）",
      "category" : "Copywriting",
      "content": "GitHub repository: mzlogin/chinese-copywriting-guidelines 统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。 Other languages:  Chinese Traditional English  目录  空格   中英文之间需要增加空格  中文与数字之间需要增加空格  数字与单位之间无需增加空格  全角标点与其他字符之间不加空格  -ms-text-autospace to the rescue?   标点符号   不重复使用标点符号   全角和半角   使用全角中文标点  数字使用半角字符  遇到完整的英文整句、特殊名词，其內容使用半角标点   名词   专有名词使用正确的大小写  不要使用不地道的缩写   争议   链接之间增加空格  简体中文使用直角引号   工具 谁在这样做？ 参考文献 空格 「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格 正确：  在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误：  在LeanCloud上，数据存储是围绕AVObject进行的。 在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法：  在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格 正确：  今天出去买菜花了 5000 元。 错误：  今天出去买菜花了 5000元。 今天出去买菜花了5000元。 数字与单位之间无需增加空格 正确：  我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。 错误：  我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。 另外，度／百分比与数字之间不需要增加空格： 正确：  今天是 233° 的高温。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误：  今天是 233 ° 的高温。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格 正确：  刚刚买了一部 iPhone，好开心！ 错误：  刚刚买了一部 iPhone ，好开心！ -ms-text-autospace to the rescue? Microsoft 有个 -ms-text-autospace 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号 不重复使用标点符号 正确：  德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误：  德国队竟然战胜了巴西队！！ 德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！ 她竟然对你说「喵」？！？！？？！！ 全角和半角 不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。 使用全角中文标点 正确：  嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误：  嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎! 嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎! 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI! 核磁共振成像(NMRI)是什么原理都不知道?JFGI! 数字使用半角字符 正确：  这件蛋糕只卖 1000 元。 错误：  这件蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。 遇到完整的英文整句、特殊名词，其內容使用半角标点 正确：  乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。 错误：  乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词 专有名词使用正确的大小写 大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。 正确：  使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误：  使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写 正确：  我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。 错误：  我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。 争议 以下用法略带有个人色彩，既：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格 用法：  请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法：  请提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号 用法：  「老师，『有条不紊』的『紊』是什么意思？」 对比用法：  “老师，‘有条不紊’的‘紊’是什么意思？” 工具    仓库  语言     vinta/paranoid-auto-spacing  JavaScript    huei90/pangu.node  Node.js    huacnlee/auto-correct  Ruby    sparanoid/space-lover  PHP (WordPress)    nauxliu/auto-correct  PHP    hotoo/pangu.vim  Vim    sparanoid/grunt-auto-spacing  Node.js (Grunt)    hjiang/scripts/add-space-between-latin-and-cjk  Python   谁在这样做？    网站  文案  UGC     Apple 中国  Yes  N/A    Apple 香港  Yes  N/A    Apple 台湾  Yes  N/A    Microsoft 中国  Yes  N/A    Microsoft 香港  Yes  N/A    Microsoft 台湾  Yes  N/A    LeanCloud  Yes  N/A    知乎  Yes  部分用户达成    V2EX  Yes  Yes    SegmentFault  Yes  部分用户达成    Apple4us  Yes  N/A    豌豆荚  Yes  N/A    Ruby China  Yes  标题达成    PHPHub  Yes  标题达成   参考文献  Guidelines for Using Capital Letters Letter case - Wikipedia Punctuation - Oxford Dictionaries Punctuation - The Purdue OWL How to Use English Punctuation Corrently - wikiHow 格式 - openSUSE 全角和半角 - 维基百科 引号 - 维基百科 疑问惊叹号 - 维基百科 ",
      "url"      : "https://kekaiyuan.github.io//wiki/chinese-copywriting-guidelines/",
      "keywords" : "中文文案排版指北"
    } ,
  
    {
      "title"    : "Eclipse",
      "category" : "Eclipse",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift A –&gt; Alt    功能  快捷键     显示所有快捷键  C-S-l    开/关注释  C-/    显示 outline  C-o    当前打开的文件列表  C-e    快速查找打开文件  C-S-r    查找  C-h    查找后跳到下一处  C-.    Undo  C-z    Redo  C-y    跳到指定行  C-l    自动补全  A-/    自动解决导入包问题  C-S-o    返回  A-Left    反返回  A-Right    步进  F5    单步  F6    执行到返回  F7    继续执行  F8    删除当前行  C-d    删除前一个词  C-Backspace    删除后一个词  C-Delete    缩进  Tab    减少缩进  S-Tab    在下面新起一行  S-Enter    在上面新起一行  C-S-Enter   Q&amp;A  如何解决 Mac OS X 下安装的是 Java 1.8，运行 Eclipse 时提示「您需要安装旧 Java SE 6 运行环境才能打开「Eclipse.app」。」的问题？  更改 /Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Info.plist 文件里的 JVMCapabilities 段如下（默认只有 CommandLine）：  &lt;key&gt;JVMCapabilities&lt;/key&gt;   &lt;array&gt;    &lt;string&gt;JNI&lt;/string&gt;    &lt;string&gt;BundledApp&lt;/string&gt;    &lt;string&gt;WebStart&lt;/string&gt;    &lt;string&gt;Applets&lt;/string&gt;    &lt;string&gt;CommandLine&lt;/string&gt;   &lt;/array&gt;   然后重启电脑。 没有找到为何这样改的解释，按名称猜想应该是说在这几种环境下启动 Java 具有跨版本的兼容性吧。  ",
      "url"      : "https://kekaiyuan.github.io//wiki/eclipse/",
      "keywords" : "Eclipse"
    } ,
  
    {
      "title"    : "Emacs",
      "category" : "Emacs",
      "content": "约定：C- 前缀表示 Ctrl，M- 前缀表示 Alt，S- 前缀表示 Shift，上档字符比如 @ 的实际按键应为 Shift+2。 目录  移动 编辑 缓冲区 窗口 文件 代码 命令 重复 外部命令 模式 显示 搜索 帮助 右键菜单 插件   evil-nerd-commenter  function-args  hexl-mode  ido  jedi  projectile  python  package   其它需求   统计字数   移动 上 C-p 下 C-n 左 C-b 右 C-f 前一个词首 M-b 后一个词尾 M-f 跳到某一行 M-gg 行首 C-a 行尾 C-e 句首/前一个句首 M-a 名尾/前一个句尾 M-e 向前一个段落 M-{ 向后一个段落 M-} 下翻页 C-v 上翻页 M-v 跳到文首 M-&lt; 跳到文尾 M-&gt; 当前光标行移动到屏显上/中/下部 C-l 编辑 选取块 C-@ 复制 M-w 剪切 C-w 粘贴 C-y 全选 C-x h 切换只读/编辑模式 C-x C-q 交换当前字符与前一字符 C-t 交换当前单词与后一单词 M-t 交换当前行与上一行 C-x C-t 撤消 C-/ 或 C-x u 撤消撤消 C-g C-/ 当前单全大写 M-u 当前单词全小写 M-l 缓冲区 查看所有打开的缓冲区 C-x C-b 切换缓冲区 C-x b 关闭缓冲区 C-x k 关闭 emacsclientw.exe 打开的缓冲区 C-x # 窗口 关闭其它窗口 C-x 1 关闭当前窗口 C-x 0 在下面分割出一个窗口 C-x 2 在右边分割出一个窗口 C-x 3 依次切换到其它窗口 C-x o 文件 打开文件 C-x C-f 保存文件 C-x C-s 保存所有打开的文件 C-x s 在当前位置插入某文件内容 C-x i 代码 注释选中块 C-x r t 反注释选中块 C-x r k 注释/反注释 M-; 格式化光标之前的代码 C-M-   与上一行合并 M-^ 带注释前缀换行 M-j 解释运行当前 elisp 语句/函数 C-M-x 命令 输入命令 M-x 运行 SHELL shell 运行 ESHELL eshell 列出 elpa 上可用包 list-packages 安装插件 package-install 格式化输出 JSON json-pretty-print-buffer elisp 交互解释器 ielm 解释运行当前 Buffer eval-buffer 中止一个操作 C-g 对选中区域执行命令 M-| 重复 重复操作 50 次 M-50 命令 外部命令 输入外部命令 M-! 模式 打开/关闭某个模式 M-x 模式名 显示 放大字体 C-x C-= 缩小字体 C-x C– 重置字体 C-x C-0 自定义颜色 M-x customize-face default 搜索 渐进的搜索 C-s 往回搜索 C-r 按了回车之后继续搜索 C-s C-s 按了回车之后往回搜索 C-r C-r 帮助 查看变量的文档 C-h v 查看函数的文档 C-h f 查看某快捷键说明 C-h k 打开 Tutorial C-h t 打开帮助文档 C-h i 右键菜单 将如下代码命令为 .reg 文件，运行后可为鼠标右键添加菜单项「Edit with Emacs」（运行之前将 exe 路径先替换为自己的）。 前提是在配置文件里添加了 (server-start)。 Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT  *  shell  Edit with Emacs] [HKEY_CLASSES_ROOT  *  shell  Edit with Emacs  command] @=  D:    emacs    bin    emacsclientw.exe   -a   D:    emacs    bin    runemacs.exe     %1   插件 evil-nerd-commenter 注释/反注释 M-; 注释多行 M-9 M-; function-args 提示函数参数 M-i 显示本文件大纲选择某项后跳转 C-M-j 跳转到函数定义（显示函数参数的时候有效） M-j hexl-mode 进入十六进制模式 M-x hexl-mode 退出十六进制模式 M-x hexl-mode-exit 输入十六进制数 M-x hexl-insert-hex-char ido 切换到上一个选项 C-r 切换到下一个选项 C-s jedi 显示光标处 Python 模块或函数的文档 C-c ? projectile 显示/刷新当前项目文件列表 C-c p f python 打开 Python 交互式Shell C-c C-p package 升级已安装的包 U 标记要安装的包 i 标记要删除的包 d 取消标记 u 执行操作 x 上一行 p 下一行 n 刷新包列表 r 重置缓冲区 g 退出窗口 q 其它需求 统计字数 （前提是 shell 下能运行 wc 程序）  选中要统计区域 M-| wc -c ",
      "url"      : "https://kekaiyuan.github.io//wiki/emacs/",
      "keywords" : "Emacs, 快捷键"
    } ,
  
    {
      "title"    : "Excel",
      "category" : "Office",
      "content": "小技巧 查找重复项  选中查找区域； 开始-样式-条件格式-突出显示单元格规则-重复值，在弹出的对话框中设置重复值格式； 此时如果重复值，已经被标记为指定的格式。 在汇总行上方插入行后自动求和 比如有以下表格： 当前 B5 单元格的公式为 =SUM(B2:B4)，但是在汇总行上面插入一行新的记录后，汇总数据不会自动更新。 这时候可以使用以下两个公式，实现在汇总行上面插入新的行后，汇总数据自动求和： =SUM(INDIRECT(B2:B&amp;ROW()-1)) =SUM(OFFSET(B1,,,ROW()-1,)) 参考：http://www.icanzc.com/excel/3689.html ",
      "url"      : "https://kekaiyuan.github.io//wiki/excel/",
      "keywords" : "Excel, Office"
    } ,
  
    {
      "title"    : "Git",
      "category" : "Git",
      "content": "常用命令    功能  命令     添加文件/更改到暂存区  git add filename    添加所有文件/更改到暂存区  git add .    提交  git commit -m msg    从远程仓库拉取最新代码  git pull origin master    推送到远程仓库  git push origin master    查看配置信息  git config –list    查看文件列表  git ls-files    比较工作区和暂存区  git diff    比较暂存区和版本库  git diff –cached    比较工作区和版本库  git diff HEAD    从暂存区移除文件  git reset HEAD filename    查看本地远程仓库配置  git remote -v    回滚  git reset –hard 提交SHA    强制推送到远程仓库  git push -f origin master    修改上次 commit  git commit –amend    推送 tags 到远程仓库  git push –tags    推送单个 tag 到远程仓库  git push origin [tagname]    删除远程分支  git push origin –delete [branchName]    远程空分支（等同于删除）  git push origin :[branchName]    查看所有分支历史  gitk –all    按日期排序显示历史  gitk –date-order   Q&amp;A 如何解决gitk中文乱码，git ls-files 中文文件名乱码问题？ 在~/.gitconfig中添加如下内容 [core] quotepath = false [gui] encoding = utf-8 [i18n] commitencoding = utf-8 [svn] pathnameencoding = utf-8 参考 http://zengrong.net/post/1249.htm 如何处理本地有更改需要从服务器合入新代码的情况？ git stash git pull git stash pop stash 查看 stash 列表： git stash list 查看某一次 stash 的改动文件列表（不传最后一个参数默认显示最近一次）： git stash show stash@{0} 以 patch 方式显示改动内容 git stash show -p stash@{0} 应用某次 stash 改动内容： git stash apply stash@{0} 如何合并 fork 的仓库的上游更新？ git remote add upstream https://upstream-repo-url git fetch upstream git merge upstream/master 如何通过 TortoiseSVN 带的 TortoiseMerge.exe 处理 git 产生的 conflict？ 将 TortoiseMerge.exe 所在路径添加到 path 环境变量。 运行命令 git config --global merge.tool tortoisemerge 将 TortoiseMerge.exe 设置为默认的 merge tool。  在产生 conflict 的目录运行 git mergetool，TortoiseMerge.exe 会跳出来供你 resolve conflict。   也可以运行 git mergetool -t vimdiff 使用 -t 参数临时指定一个想要使用的 merge tool。   不想跟踪的文件已经被提交了，如何不再跟踪而保留本地文件？ git rm --cached /path/to/file，然后正常 add 和 commit 即可。 如何不建立一个没有 parent 的 branch？ git checkout --orphan newbranch 此时 git branch 是不会显示该 branch 的，直到你做完更改首次 commit。比如你可能会想建立一个空的 gh-pages branch，那么： git checkout --orphan gh-pages git rm -rf . // add your gh-pages branch files git add . git commit -m init commit submodule 的常用命令 添加 submodule git submodule add git@github.com:philsquared/Catch.git Catch 这会在仓库根目录下生成如下 .gitmodules 文件并 clone 该 submodule 到本地。 [submodule Catch] path = Catch url = git@github.com:philsquared/Catch.git 更新 submodule git submodule update 当 submodule 的 remote 有更新的时候，需要 git submodule update --remote 当在本地拉取了 submodule 的远程更新，但是想反悔时： git submodule update --init 删除 submodule 在 .gitmodules 中删除对应 submodule 的信息，然后使用如下命令删除子模块所有文件： git rm --cached Catch clone 仓库时拉取 submodule git submodule update --init --recursive 删除远程 tag git push origin --delete tag [tagname] 基于某次 commit 创建 tag git tag &lt;tag name&gt; &lt;commit id&gt; git tag v1.0.0 ef0120 清除未跟踪文件 git clean 可选项：    选项  含义     -q, –quiet  不显示删除文件名称    -n, –dry-run  试运行    -f, –force  强制删除    -i, –interactive  交互式删除    -d  删除文件夹    -e, –exclude  忽略符合 的文件    -x  清除包括 .gitignore 里忽略的文件    -X  只清除 .gitignore 里忽略的文件   忽略文件属性更改 因为临时需求对某个文件 chmod 了一下，结果这个就被记为了更改，有时候这是想要的，有时候这会造成困扰。 git config --global core.filemode false 参考：How do I make Git ignore file mode (chmod) changes? 忽略除某后缀名以外的所有文件 忽略除了 .c 后缀名以外的所有文件。 * !*.c !*/ gitignore 里，*、?、[] 可用作通配符。 patch 将未添加到暂存区的更改生成 patch 文件： git diff &gt; demo.patch 将已添加到暂存区的更改生成 patch 文件： git diff --cached &gt; demo.patch 合并上面两条命令生成的 patch 文件包含的更改： git apply demo.patch 将从 HEAD 之前的 3 次 commit 生成 3 个 patch 文件： （HEAD 可以换成 sha1 码） git format-patch -3 HEAD 生成 af8e2 与 eaf8e 之间的 commits 的 patch 文件： （注意 af8e2 比 eaf8e 早） git format-patch af8e2..eaf8e 合并 format-patch 命令生成的 patch 文件： git am 0001-Update.patch 与 git apply 不同，这会直接 add 和 commit。 只下载最新代码 git clone --depth 1 git://xxxxxx 这样 clone 出来的仓库会是一个 shallow 的状态，要让它变成一个完整的版本： git fetch --unshallow 或 git pull --unshallow 基于某次 commit 创建分支 git checkout -b test 5234ab 表示以 commit hash 为 5234ab 的代码为基础创建分支 test。 恢复单个文件到指定版本 git reset 5234ab MainActivity.java 恢复 MainActivity.java 文件到 commit hash 为 5234ab 时的状态。 设置全局 hooks git config --global core.hooksPath C:/Users/mazhuang/git-hooks 然后把对应的 hooks 文件放在最后一个参数指定的目录即可。 比如想要设置在 commit 之前如果检测到没有从服务器同步则不允许 commit，那在以上目录下建立文件 pre-commit，内容如下： #!/bin/sh CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD) git fetch origin $CURRENT_BRANCH HEAD=$(git rev-parse HEAD) FETCH_HEAD=$(git rev-parse FETCH_HEAD) if [ $FETCH_HEAD = $HEAD ]; then  echo Pre-commit check passed  exit 0 fi echo Error: you need to update from remote first exit 1 查看某次 commit 的修改内容 git show &lt;commit-hash-id&gt; 查看某个文件的修改历史 git log -p &lt;filename&gt; 查看最近两次的修改内容 git log -p -2 应用已存在的某次更改 / merge 某一个 commit git cherry-pick &lt;commit-hash-id&gt; cherry-pick 有更多详细的用法，可以参见帮助文档。 命令行自动补全 在 shell 里加载 git-completion 系列脚本，详见 https://github.com/git/git/tree/master/contrib/completion 文件每一行变更明细 git blame &lt;filename&gt; 找回曾经的历史 git reflog 列出 HEAD 曾指向过的一系列 commit，它们只存在于本机，不是版本仓库的一部分。 还有： git fsck 记住 http(s) 方式的用户名密码 在有些情况下无法使用 git 协议，比如公司的 git 服务器设置了 IP 白名单，只能在公司内网使用 ssh，那么在外面就只能使用 http(s) 上传下载源码了，但每次都手动输入用户名/密码特别惨，于是乎就记住吧。 设置记住密码（默认 15 分钟）： git config --global credential.helper cache 自定义记住的时间（如下面是一小时）： git config credential.helper 'cache --timeout=3600' 长期存储密码： git config --global credential.helper store git commit 使用 vim 编辑 commit message 中文乱码 这个问题在 Windows 下出现了，没找到能完美解决的办法，一种方法是在 vim 打开后输入： :set termencoding=GBK 这就有点太麻烦了，折衷的方法是改为使用 gVim 或其它你喜欢的编辑器来编辑 commit message： git config --global core.editor gvim 参考： How do I make Git use the editor of my choice for commits? 转：git windows中文 乱码问题解决汇总 另外在升级 Vim 到 8.1 之后，由于 PATH 环境变量里加的还是 vim80 文件夹，导致 git commit 时提示： error: cannot spawn gvim: No such file or directory error: unable to start editor 'gvim' Please supply the message using either -m or -F option. 使用 which gvim 查看： $ which gvim /usr/bin/which: no gvim in xxxxxxx 将 PATH 里添加的 vim80 路径改为 vim81 后解决。 git log 中文乱码 只在 Windows 下遇到。 git config --global i18n.logoutputencoding gbk 编辑 git 安装目录下 etc/profile 文件，在最后添加如下内容： export LESSCHARSET=utf-8 参考：Git for windows 中文乱码解决方案 git diff 中文乱码 只在 Windows 下遇到，目前尚未找到有效办法。 统计代码行数 CMD 下直接执行可能失败，可以在右键，Git Bash here 里执行。 统计某人的代码提交量 git log --author=$(git config --get user.name) --pretty=tformat: --numstat | gawk '{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf added lines: %s removed lines : %s total lines: %s  ,add,subs,loc }' 仓库提交都排名前 5 如果看全部，去掉 head 管道即可。 git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5 仓库提交者（邮箱）排名前 5 这个统计可能不太准，可能有同名。 git log --pretty=format:%ae | gawk -- '{ ++c[$0]; } END { for(cc in c) printf %5d %s  ,c[cc],cc; }' | sort -u -n -r | head -n 5 贡献者排名 git log --pretty='%aN' | sort -u | wc -l 提交数统计 git log --oneline | wc -l 参考：Git代码行统计命令集 修改文件名时的大小写问题 修改文件名大小写时，默认会被忽略（在 Windows 下是这样），让 git 对大小写敏感的方法： git config --global core.ignorecase false 或者使用 git mv oldname newname 也是可以的。 修复 gitk 在 macOS 下显示模糊的问题 gitk 很方便，但是在 Mac 系统下默认显示很模糊，影响体验。 根据网上搜索的结果，解决方法有两种，我采用第一种解决，第二种未尝试。 方法一：  重新启动机器，按 command + R 等 Logo 和进度条出现，会进入 Recovery 模式，选择顶部的实用工具——终端，运行以下命令：  csrutil disable   重新启动机器。   编辑 Wish 程序的 plist，启动高分辨率屏支持。  sudo gvim /System/Library/Frameworks/Tk.framework/Versions/Current/Resources/Wish.app/Contents/Info.plist   在最后的 &lt;/dict&gt; 前面加上以下代码  &lt;key&gt;NSHighResolutionCapable&lt;/key&gt; &lt;true/&gt;   更新 Wish.app。  sudo touch Wish.app   再次用 1 步骤的方法进入 Recovery 模式，执行 csrutil enable 启动对系统文件保护，再重启即可。 参考：Mac 中解决 gitk 模糊问题 方法二： brew cask install retinizer open /System/Library/Frameworks/Tk.framework/Versions/Current/Resources/ 打开 retinizer，将 Wish.app 拖到 retinizer 的界面。 参考：起底Git-Git基础 clone 时指定 master 以外的分支 git clone -b &lt;branch name&gt; --single-branch &lt;repo address&gt; 获取当前分支名称 git symbolic-ref --short -q HEAD 解决 no man viewer handled the request 运行命令 git stash --help 报错： warning: failed to exec 'man': Invalid argument fatal: no man viewer handled the request 原因是 Windows 下没有 man 命令。 可以修改 git 配置让命令的帮助文档通过浏览器打开。 git config --global help.format web 比较两个分支的差异 显示出所有差异详情： git diff &lt;branch_name_1&gt; &lt;branch_name_2&gt; 显示有差异的文件列表： git diff &lt;branch_name_1&gt; &lt;branch_name_2&gt; --stat 显示指定文件的差异详情： git diff &lt;branch_name_1&gt; &lt;branch_name_2&gt; &lt;filename&gt; 查看 A 分支有，B 分支没有的提交： git log &lt;branch_name_A&gt; ^&lt;branch_name_B&gt; git 操作时报警告 警告信息： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @  WARNING: POSSIBLE DNS SPOOFING DETECTED!  @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ The ECDSA host key for gitlab.xxxx.com has changed, and the key for the corresponding IP address 121.40.151.8 is unknown. This could either mean that DNS SPOOFING is happening or the IP address for the host and its host key have changed at the same time. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!  @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the ECDSA key sent by the remote host is SHA256:bud2tDwxl9687vMOUUBGXlwZhjxDTu7eVF43ojAu1Pw. Please contact your system administrator. Add correct host key in /c/Users/mzlogin/.ssh/known_hosts to get rid of this message. Offending ECDSA key in /c/Users/mzlogin/.ssh/known_hosts:1 ECDSA host key for gitlab.xxxx.com has changed and you have requested strict checking. Host key verification failed. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 解决方案： rm ~/.ssh/known_hosts 然后重新操作即可。 删除不存在对应远程分支的本地分支 （本小节有效性存疑，有时候并不好使。） $ git remote show origin develop      tracked master     tracked feature/new-ui    tracked refs/remotes/origin/feature/test stale (use 'git remote prune' to remove) ... 其中 feature/test 就是不存在远程分支的本地分支。 $ git remote prune origin 清除完成。 ",
      "url"      : "https://kekaiyuan.github.io//wiki/git/",
      "keywords" : "Git, 版本控制"
    } ,
  
    {
      "title"    : "GitHub",
      "category" : "GitHub",
      "content": "打开/下载文件加速  项目内的文件 比如要下载 https://github.com/junegunn/vim-plug/plug.vim，那可以将 github.com 替换成 cdn.jsdelivr.net/gh，最终地址 https://cdn.jsdelivr.net/gh/junegunn/vim-plug/plug.vim 参考 https://mazhuang.org/2020/05/01/cdn-for-github-pages/   Releases 里的文件 比如要下载 https://github.com/PowerShell/PowerShell/releases/download/v7.1.0-preview.6/PowerShell-7.1.0-preview.6-win-x64.zip，可以将 github.com 替换成 download.fastgit.org，最终地址 https://download.fastgit.org/PowerShell/PowerShell/releases/download/v7.1.0-preview.6/PowerShell-7.1.0-preview.6-win-x64.zip 参考 https://toolwa.com/github/  ",
      "url"      : "https://kekaiyuan.github.io//wiki/github/",
      "keywords" : "GitHub"
    } ,
  
    {
      "title"    : "实用网站",
      "category" : "Recommends",
      "content": "如遇网站打不开，请记得科学上网 数据结构可视化 Data structure visualizations visualgo  部分中文   fmdca380  visualgo的国内版，内容略少   sorting 十大经典排序算法（动图演示） MySQL MySQL 5.6 中文参考手册 MySQL 5.7 64位下载教程 Mac下干净彻底地卸载 MySQL MAC安装Mysql超详细完整教程(图文并茂) Java windows系统下安装JDK8 MyBatis mybatis自动生成代码工具（逆向工程） Tomcat Tomcat 乱码 小工具 取名 印记中文 正则表达式大全 在线工具大全 极速数据 找资源 Windows 在鼠标右键中添加 cmd 选项（管理员模式） 加密 BCrypt 密码加密和解密 JWT 常见三种加密（MD5、非对称加密，对称加密） 非对称加密源码 Redis Windows Redis 安装教程 Markdown sequence 图 IDEA JRebel 安装教程 idea,eclipse中注解使用的计算机用户名修改 PowerDesigner PowerDesigner 安装教程 RestTemplate 使用RestTemplate访问https实现SSL请求 Linux Mac 安装 brew（最新教程，绝对可行，一行代码搞定，不报错） Http Mac使用Charles成功代理连接手机进行抓包！！！ Cron 表达式 在线Cron表达式生成器 ",
      "url"      : "https://kekaiyuan.github.io//wiki/good-sites/",
      "keywords" : "网站，推荐"
    } ,
  
    {
      "title"    : "善用佳软",
      "category" : "Recommends",
      "content": "好的软件总是给人一种相见恨晚的感觉。 软件列表    功能  Windows  Mac OS X     文本编辑  gVim  MacVim    离线 API 文档  Zeal  Dash / devdocs.io    UML  Visio / draw.io  draw.io    流程图  Visio / draw.io  draw.io / ProcessOn.com    文件查找  Everything  Alfred    文件内容查找  FileLocator  Alfred    Android 开发  Android Studio  Android Studio    Android 虚拟机  Genymotion  Genymotion    Android 当无线鼠标、键盘、远程桌面等  WiFi Mouse  WiFi Mouse    源码阅读  Source Insight  IDE/Vim    笔记  OneNote  OneNote    终端  Windows Terminal / Cmder  zsh    视频播放器  QQ 影音  mpv    下载  迅雷精简版  迅雷    录制屏幕生成 GIF  LICEcap  LICEcap    打开 CHM 文档     ichm    阅读 EPUB 电子书  Neat Reader  iBook   亮点 Cmder  alias 在 Cmder 下可以很方便地像在类 Unix 系统下使用 alias 功能，比如： alias blog=cd /d d:  github  mzlogin.github.io   然后就能愉快地使用 blog 命令在任意目录进入 blog 仓库的目录了。 Genymotion 配置好后，那启动速度，嗖嗖地，秒 Android SDK 自带的八条街。 mpv 不像 MPlayerX 和 Perian 那样无故卡死转码半天就是最大的亮点了。 ",
      "url"      : "https://kekaiyuan.github.io//wiki/good-soft/",
      "keywords" : "软件, 推荐"
    } ,
  
    {
      "title"    : "IDA Pro",
      "category" : "Debug",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command    功能  快捷键     搜索文本  M-t    返回上一个位置  Esc    前进到下一位置  C-Enter    显示伪 C 代码  F5    跳转到地址  g  ",
      "url"      : "https://kekaiyuan.github.io//wiki/ida-pro/",
      "keywords" : "debug, IDA Pro"
    } ,
  
    {
      "title"    : "IntelliJ IDEA",
      "category" : "Tools",
      "content": "版本：Community 2020.03 快捷键 Ctrl+P：构造方法提示 使用 Jdk 中的方法时报错 修改File/Project Structure/Project Settings/Modules的Language level与使用的jdk版本一致 自动声明变量 =号左边的东西不用写，将=号右边的东西写完后+.var+回车 //=号左边东西不写，右边写好 new File(test.txt) //+.var new File(test.txt).var //按下回车 File file = new File(abc.txt); 自动生成 SerialVersionUID 勾选File/Settings/Editor/Inspections/Java/Serializable issues/Serializable class without 'serialVersionUID'，右边窗口里Severity可选择警告的等级和作用范围，上边窗口里Profile可选择该设置是对当前项目生效还是对IDEA生效 这样当实体类继承了Serializable却没有定义serialVersionUID时类名会高亮警告，把鼠标移动到类名上即可自动生成serialVersionUID 关联中文 API 文档 下载中文API的chm文件  链接：https://pan.baidu.com/s/1a3vvEx5089kbVx48ufTidQ 提取码：3lkw   反编译chm文件为html文件  在chm文件所在目录打开cmd窗口，输入 hh -decompile doc 文件名全称（包括后缀） 例如：hh -decompile doc jdk api 1.8_google.CHM   打开File/Project Structure/SDKSs/Documentation Paths 点击下方+号添加刚才反编译出的html的文件夹 之后把鼠标移到代码上即可查看相关的中文说明 通过 Maven 导入 Jar 包 举例如何导入 Spring 的 Jar 包，其他能在 Maven 上搜到的 Jar 包都是同样的流程。 项目名右键Add Framework Support/勾选Maven/OK后会生成pom.xml文件 在&lt;project&gt;&lt;/project&gt;标签内加入&lt;dependencies&gt;&lt;/dependencies&gt;标签，然后在&lt;dependencies&gt;&lt;/dependencies&gt;标签内加入我们需要的依赖项的代码 maven 网址https://mvnrepository.com/ 搜索spring context 选择需要的版本 复制代码 把代码粘贴进&lt;dependencies&gt;&lt;/dependencies&gt;标签中 打开 Maven 窗口，右键 Reload project 项目，等待下载完成 和 Github 的通信太慢 当cmd里和Github的通信没问题，而Idea却太慢时。 找到Idea的安装目录下的bin文件夹。 找到runnerw.exe和runnerw(64).exe 修改这两个文件的文件名或者直接删除他们 版本：Community 2021.06 并发启动代码 在网络开发中，经常需要启动多个客户端测试代码，如何将同一个 class 同时运行多个 在左侧 Project 窗口找到要并发启动的文件，右键 Modify Run Configuration 在 Build and run 窗口，点击 Modify options ， 勾选 Allow multify instances 完成 Maven can’t resolve 当 Maven 下载包下到一半时出现网络问题断开，重新下载时已下载的部分文件会发生冲突，将已下载文件全部删除即可。 打开 Setting ， 输入 maven ，打开 local repository，把相关的文件删除，重新 reload Gradle 项目控制台乱码 help / edit custom vm options 加上 -Dfile.encoding=utf-8 重启 IDEA 修改 File Header 打开 File / Settings / Editor / File and Code Templates/Includes 在 File Header 里添加 /** * * ${DESCRIPTION} * * @author 柯凯元 * @date ${YEAR}-${MONTH}-${DAY} ${TIME} */  自动换行 打开 File / Settings / Editor / Code Style 勾选 Wrap on typing ，左侧 Hard wrap at 设置每行的长度。 Ctrl + L 代码排版时自动换行 打开 File / Settings / Editor / Code Style / Java / Wrapping and Braces 勾选 Ensure right margin is not exceeded ",
      "url"      : "https://kekaiyuan.github.io//wiki/intellij-idea/",
      "keywords" : "IDEA, Java"
    } ,
  
    {
      "title"    : "Kindle",
      "category" : "Tools",
      "content": "越狱资源  Kindle Paperwhite 1 代越狱教程 Kindle 越狱资源及插件下载详细步骤 用插件 BookFere Tools 清理无用 sdr 文件夹 问题解决 切换亚马逊账号导致 Kindle Launcher 无法打开 提示语类似「您的设备不再被授权为开发设备」之类的，但 KOReader、KPVBooklet 和 ScreenSaver 等插件工作正常，推测越狱没有失效，只是 KUAL 相关的这个 Kindle Launcher 打不开了。 解决方法：  点击一个 PDF 文件打开 KOReader； 进入文件浏览器，找到 /mnt/us/mkk/developer.keystore，长按复制； 进到 /var/local/java/keystore 目录，长按粘贴； 重启 Kindle。 KPVBooklet 安装后无法在主页直接打开 PDF 和 EPUB 文件 KPVBooklet 最新版 v0.66 安装到 Kindle Paperwhite 1 代 5.6.1.1 固件会出现此问题，点击 PDF 文件提示「无法启动选定的应用程序」。 解决方法： 到官网仓库 https://github.com/koreader/kpvbooklet/releases 下载安装 v0.6.4 版本可正常工作。看 Issue #46 里的讨论，是 v0.6.5 和 v0.6.6 换了打包的人员，有可能使用的 JDK 版本等有差异导致的。 ",
      "url"      : "https://kekaiyuan.github.io//wiki/kindle/",
      "keywords" : "Kindle"
    } ,
  
    {
      "title"    : "Linux/Unix",
      "category" : "Linux",
      "content": "类 Unix 系统下的一些常用命令和用法。 实用命令 chown 更改文件所有者和组。 比如某文件夹当前所有者是 root，需要更改为 admin： chown -R admin:admin test chmod 修改文件权限。 fuser 查看文件被谁占用。 fuser -u .linux.md.swp id 查看当前用户、组 id。 lsof 查看打开的文件列表。  An open file may be a regular file, a directory, a block special file, a character special file, an executing text reference, a library, a stream or a network file (Internet socket, NFS file or UNIX domain socket.) A specific file or all the files in a file system may be selected by path. 查看网络相关的文件占用 lsof -i 查看端口占用 lsof -i tcp:5037 查看某个文件被谁占用 lsof .linux.md.swp 查看某个用户占用的文件信息 lsof -u mazhuang -u 后面可以跟 uid 或 login name。 查看某个程序占用的文件信息 lsof -c Vim 注意程序名区分大小写。 ",
      "url"      : "https://kekaiyuan.github.io//wiki/linux/",
      "keywords" : "Linux"
    } ,
  
    {
      "title"    : "Mac OS X",
      "category" : "Mac",
      "content": "快捷键约定： C –&gt; Ctrl S –&gt; Shift M –&gt; Alt/Option Cmd –&gt; Command Mac 键盘快捷键官方参考 窗口    功能  快捷键     显示桌面  F11    上/下一个桌面/工作区  C-Left/Right    切换窗口全屏状态  C-Cmd-F    隐藏当前程序的所有窗口  Cmd-H    最小化窗口  Cmd-M    关闭窗口  Cmd-W    关闭当前程序  Cmd-Q    新建标签  Cmd-T    新建窗口  Cmd-N    调度中心  C-Up    当前应用的所有窗口  C-Down   程序    功能  快捷键     打开 emoji 表情窗口  C-Cmd- 空格    打开 Spotlight  C- 空格    切换输入法  Cmd- 空格    打开 Alfred  M- 空格    打开 Finder 并查找  C-M- 空格    打开 Launchpad  四指合拢   音量    功能  快捷键     微调音量  M-S-音量加/音量减   命令行 快捷键    功能  按键     移动光标至行首  C-a    移动光标至行尾  C-e    清屏  C-l    删除光标前的所有文字。如果光标位于行尾则删除整行。  C-u    与退格键相同  C-h    检索使用过的命令  C-r    终止当前执行  C-c    退出当前 shell  C-d    将执行中的任何东西放入后台进程。fg 可以将其恢复。  C-z    删除光标之前的单词  C-w    删除光标后的所有文字  C-k    将光标前的两个文字进行互换  C-t    光标向前移动一个单词  C-f    光标向后移动一个单词  C-b    将光标前的两个单词进行互换  Esc + t    自动补全文件或文件夹的名称  Tab   命令    按键 / 命令  描述     cd  Home 目录    cd [folder]  切换目录    cd ~  Home 目录，例如 ‘cd ~/folder/’    cd /  根目录    ls  文件列表    ls -l  文件详细列表    ls -a  列出隐藏文件    ls -lh  文件详细列表中的文件大小以更友好的形式列出    ls -R  递归显示文件夹中的内容    sudo [command]  以超级用户身份执行命令    open [file]  打开文件 ( 相当于双击一个文件 )    top  显示运行中的进程，按 q 终止    nano [file]  打开编辑    pico [file]  打开编辑    q  退出    clear  清屏   命令历史    按键/命令  描述     history n  列出最近执行过的 n 条命令    ctrl-r  检索之前执行过的命令    ![value]  执行最近以 ‘value’ 开始的命令    !!  执行最近执行过的命令   文件管理    按键/命令  描述     Cmd-Shift-.  显示/恢复隐藏文件    touch [file]  创建一个新文件    pwd  显示当前工作目录    ..  上级目录, 例如.    ‘ls -l ..’  上级目录的文件详细列表    ‘cd ../../’  向上移动两个层级    .  当前目录    cat  连接    rm [file]  移除文件, 例如 rm [file] [file]    rm -i [file]  移除时出现确认提示    rm -r [dir]  移除文件及内容    rm -f [file]  强制移除    cp [file] [newfile]  复制文件    cp [file] [dir]  复制文件到指定目录    mv [file] [new filename]  移动 / 重命名, 例如 mv -v [file] [dir]   目录管理    按键/命令  描述     mkdir [dir]  创建新目录    mkdir -p [dir]/[dir]  创建子目录    rmdir [dir]  移除目录 ( 仅限目录下没有内容时 )    rm -R [dir]  移除目录及内容   管道 - 连接多个带有输出的命令    按键/命令  描述     more  按当前窗口大小输出内容    &gt; [file]  输出至指定文件, 注意文件将会覆盖    » [file]  在制定文件的末尾附加内容    &lt;  从文件中读取内容   帮助    按键/命令  描述     [command] -h  显示帮助信息    [command] –help  显示帮助信息    [command] help  显示帮助信息    reset  重置当前终端    man [command]  显示指定命令的帮助信息    whatis [command]  显示指定命令的简述   搜索  使用 find 命令，例如： find ~ -iname aapt   使用 mdfind 命令，例如： 全局搜索 mdfind -name aapt   或搜索指定文件夹 mdfind -onlyin ~/Library aapt   使用 locate 命令，例如： locate aapt   复制文件路径  在 Finder 下 先按键 Cmd-i，然后从弹出的窗口里复制。   在 Terminal 下 pwd|pbcopy   Safari    功能  快捷键     定位到地址栏  Cmd-L    切换标签  Cmd-S-Left/Right    收藏页面  Cmd-D   保存 Safari 里正在播放的视频 $ su # cd /private/var/folders # ls nk zz # cd nk # ls zy3770994vqg83xvmbc9pd0m0000gn # cd zy3770994vqg83xvmbc9pd0m0000gn/T # open . 然后复制里面叫 FlashTmp.xxx 的文件，改名为 FlashTmp.flv。（操作过程中保持视频在播放状态） Terminal    功能  快捷键     新建标签  Cmd-T    上 / 下个标签  Cmd-{/}    删除光标前的输入  C-U   WireShark 使用 WireShark 1.99 开发版，可以不依赖于 X11，界面基于 Qt，更加美观，符合 Mac 界面风格。 截图    功能  快捷键     全屏截图保存到桌面  Cmd-S-3    全屏截图并复制  Cmd-C-S-3    选区截图保存到桌面  Cmd-S-4    选区截图并复制  Cmd-C-S-4    窗口截图保存到桌面  Cmd-S-4 空格    窗口截图并复制  Cmd-C-S-4 空格    QQ 截图  Cmd-S-A   去除窗口截图时的阴影 defaults write com.apple.screencapture disable-shadow -bool TRUE Killall SystemUIServer 如果要保留窗口截图时的阴影，则将 TRUE 改为 FALSE。 调整选区大小 使用选区模式选中一个区域并松开鼠标前，  按住空格并移动鼠标，可以保持区域大小不变，并移动区域； 按住Shift并移动鼠标，就可以保持区域的其它三个边不变，移动一个边的位置； 按住Alt并移动鼠标，就可以对称的调整区域大小。 截图标注 使用预览工具可以完成截图标注。 延时截图 使用系统自带的 Grab 工具，运行后选择菜单的 Capture - Timed Screen。 iBooks 里的电子书保存路径 /Users/&lt;username&gt;/Library/Containers/com.apple.BKAgentService/Data/Documents/iBooks/Books 安装 mpv 没有图形界面 使用 brew options mpv 可以看到有个 --with-bundle 是安装时创建 .app 文件。 brew install mpv --with-bundle brew linkapps mpv 屏幕取色 使用 Mac 自带的“数码测色计”。 问题解决 No Xcode or CLT version detected 报错信息： ~/github/hs-airdrop$ npm install &gt; bcrypto@5.0.3 install /Users/username/github/hs-airdrop/node_modules/bcrypto &gt; node-gyp rebuild No receipt for 'com.apple.pkg.CLTools_Executables' found at '/'. No receipt for 'com.apple.pkg.DeveloperToolsCLILeo' found at '/'. No receipt for 'com.apple.pkg.DeveloperToolsCLI' found at '/'. gyp: No Xcode or CLT version detected! gyp ERR! configure error gyp ERR! stack Error: `gyp` failed with exit code: 1 gyp ERR! stack  at ChildProcess.onCpExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16) gyp ERR! stack  at ChildProcess.emit (events.js:210:5) gyp ERR! stack  at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) gyp ERR! System Darwin 19.3.0 gyp ERR! command /usr/local/Cellar/node/12.12.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js rebuild gyp ERR! cwd /Users/username/github/hs-airdrop/node_modules/bcrypto gyp ERR! node -v v12.12.0 gyp ERR! node-gyp -v v5.0.5 gyp ERR! not ok npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! bcrypto@5.0.3 install: `node-gyp rebuild` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the bcrypto@5.0.3 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. 解决方法： sudo xcode-select -s /Applications/Xcode.app/Contents/Developer 通过扩展坞连接的键盘鼠标卡顿断电 我用 MacBook Pro 16 寸 2019 款，通过 biaze 五口扩展坞连接键盘、鼠标、显示器、网线，一直好好的，突然有一天键盘鼠标开始经常卡顿、断电。参考 https://support.apple.com/zh-cn/HT201295，重置 SMC 问题也没有解决。 尝试过插别的接口、换扩展坞、只接以上几种设备之一和之二等，都没解决。最后用了个别的鼠标试了下，好了。欲哭无泪。 参考  你可能不知道的 Mac 技巧 - 截图，Gif 制作及 App 推荐 terminal-mac-cheatsheet ",
      "url"      : "https://kekaiyuan.github.io//wiki/mac/",
      "keywords" : "Mac"
    } ,
  
    {
      "title"    : "Markdown",
      "category" : "Markdown",
      "content": "目录  超链接 列表 强调 标题 表格 代码块 图片 锚点 Inline Attribute Emoji Footnotes mermaid sequence flowchart mathjax mindmap 超链接 [靠谱-ing](https://mazhuang.org) &lt;https://mazhuang.org&gt; 靠谱-ing https://mazhuang.org 列表 1. 有序列表项 1 2. 有序列表项 2 3. 有序列表项 3   有序列表项 1   有序列表项 2   有序列表项 3 * 无序列表项 1 * 无序列表项 2 * 无序列表项 3   无序列表项 1   无序列表项 2   无序列表项 3 - [x] 任务列表 1 - [ ] 任务列表 2 任务列表 1 任务列表 2 强调 ~~删除线~~ **加黑** *斜体* 删除线 加黑 斜体 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 Tips: # 与标题中间要加空格。 表格 | HEADER1 | HEADER2 | HEADER3 | HEADER4 | | ------- | :------ | :-----: | ------: | | content | content | content | content |   HEADER1  HEADER2  HEADER3  HEADER4     content  content  content  content   :—– 表示左对齐 :—-: 表示中对齐 —–: 表示右对齐 代码块 print 'Hello, World!'   list item1   list item2 print 'hello'   图片 ![本站favicon](/favicon.ico)  锚点 * [目录](#目录) 目录 Inline Attribute Span Inline Attribute 详情参考 https://kramdown.gettalong.org/syntax.html#span-ials Block Inline Attribute 详情参考 https://kramdown.gettalong.org/syntax.html#block-ials 给块/元素添加 class、id、内嵌样式等： ![本站favicon](/favicon.ico){:.center} Hello, *world*{:#world} Hello, *world*{: style=color:red} Hello, world Hello, world 结合自定义的样式，有些场景比较有用。 Emoji :camel: :blush: :smile: Footnotes This is a text with footnote1. mermaid sequenceDiagram  Alice--&gt;&gt;John: Hello John, how are you?  John--&gt;&gt;Alice: Great! sequence Andrew-&gt;China: Says Hello Note right of China: China thinks  about it China--&gt;Andrew: How are you? Andrew-&gt;&gt;China: I am good thanks! flowchart st=&gt;start: Start e=&gt;end op1=&gt;operation: My Operation sub1=&gt;subroutine: My Subroutine cond=&gt;condition: Yes or No? io=&gt;inputoutput: catch something... st-&gt;op1-&gt;cond cond(yes)-&gt;io-&gt;e cond(no)-&gt;sub1(right)-&gt;op1 mathjax When   ((a   e 0)  ), there are two solutions to   ((ax^2 + bx + c = 0)  ) and they are [x = {-b   pm   sqrt{b^2-4ac}   over 2a}.] mindmap # topic ## topic2 ### topic2.1 ### topic2.2 ## topic3 &lt;!--Note--&gt; 这是一个备注 &lt;!--/Note--&gt; ### topic3.1 ### topic3.2 #### topic3.2.1 #### topic3.2.2 #### topic3.2.3 #### topic3.2.4 #### topic3.2.5 ### topic3.4 ### topic3.5 ### topic3.6   Here is the footnote 1 definition. &#8617;  ",
      "url"      : "https://kekaiyuan.github.io//wiki/markdown/",
      "keywords" : "Markdown"
    } ,
  
    {
      "title"    : "MPV",
      "category" : "Tools",
      "content": "Mac OS X 下最好用的播放器，没有之一。 快捷键 参考：mpv keybindings    按键  功能     RIGHT  前进 5 秒    LEFT  后退 5 秒    UP  前进 60 秒    DOWN  后退 60 秒    [  0.9091 倍速播放    ]  1.1 倍速播放    {  0.5 倍速播放    }  2.0 倍速播放    Backspace  还原到 1.0 倍速    Space 或 p  播放/暂停    .  下一帧    ,  上一帧    9 或 /  音量 -2    0 或 *  音量 +2    f  切换是否全屏    v  显示/隐藏字幕    T  切换是否前端显示    s  截屏，有字幕    S  截屏，无字幕    o  显示进度条与时间，2 秒后消失    I (大写 i)  显示当前文件名    1  对比度 -1    2  对比度 +1    3  亮度 -1    4  亮度 +1    5  Gamma 值 -1    6  Gamma 值 +1    7  饱和度 -1    8  饱和度 +1    l (小写 L)  设置/清除 A-B 循环点    j/J  选择字幕    #  切换声道    q  退出   命令行参数 参考：OPTIONS 参考  MPV使用小记 ",
      "url"      : "https://kekaiyuan.github.io//wiki/mpv/",
      "keywords" : "mpv"
    } ,
  
    {
      "title"    : "MySQL",
      "category" : "MySQL",
      "content": "使用 启动与停止 macOS mysql.server start mysql.server stop mysqladmin -u root -p shutdown mysql -u root -p Windows（使用管理员权限的 CMD） net start mysql net stop mysql 连接 mysql -u 用户名 -p密码 -h 服务器IP地址 -P 服务器端MySQL端口号 -D 数据库名 授权 授权远程登录 grant 权限1,权限2,…权限n on 数据库名称.表名称 to 用户名@用户地址 identified by '连接口令'; 修改密码 方法1： 用SET PASSWORD命令 mysql -u root mysql&gt; SET PASSWORD FOR 'root'@'localhost' = PASSWORD('newpass'); 方法2：用 mysqladmin mysqladmin -u root password newpass 如果root已经设置过密码，采用如下方法 mysqladmin -u root password oldpass newpass 方法3： 用UPDATE直接编辑user表 mysql -u root mysql&gt; use mysql; mysql&gt; UPDATE user SET Password = PASSWORD('newpass') WHERE user = 'root'; mysql&gt; FLUSH PRIVILEGES; 在丢失root密码的时候，可以这样 mysqld_safe --skip-grant-tables&amp; mysql -u root mysql mysql&gt; UPDATE user SET password=PASSWORD(new password) WHERE user='root'; mysql&gt; FLUSH PRIVILEGES; 命令行执行脚本 mysql -u root -p111111 -Dtest &lt; test.sql 其它问题 MySQL 5.7 在 Windows 下安装后无法直接运行，需要步骤：  mysqld install mysqld –initialize-insecure 自动生成无密码的 root 用户或 mysqld –initialize 自动生成带随机密码的 root 用户 net start mysql Mysql -u root 常用 SQL 查看 -- 查看表的创建语句 desc tb_name; show create table tb_name; -- 查看表的索引 show index from table_name; 修改 -- 修改列属性 alter table tb_name modify column_name int auto_increment; （如果是修改主键，不能带 primary key，不然会报 ERROR 1068 (42000): Multiple primary key defined） dump -- dump 库 mysqldump -u root -p db_name &gt; 1.txt -- dump 表 mysqldump -u root -p db_name tb_name &gt; 1.txt -- dump 表不带数据 mysqldump -u root -p --no-date db_name tb_name &gt; 1.txt 数据库状态 show engine INNODB status; 脏页相关 -- flush 脏页时是否刷新邻居 show VARIABLES like 'innodb_flush_neighbors'; -- 设置该值 set global innodb_flush_neighbors = 0; -- 查看脏页比例 select VARIABLE_VALUE into @a from PERFORMANCE_SCHEMA.global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty'; select VARIABLE_VALUE into @b from PERFORMANCE_SCHEMA.global_status where VARIABLE_NAME = 'Innodb_buffer_pool_pages_total'; select @a/@b; 磁盘空间相关 查看数据库内磁盘占用空间： SELECT table_name,  TABLE_SCHEMA,  ( DATA_LENGTH + INDEX_LENGTH + DATA_FREE ) / 1024 / 1024 MB,  TABLE_ROWS  FROM  information_schema. TABLES  WHERE  TABLE_SCHEMA NOT IN ('information_schema','mysql')  ORDER BY  MB DESC  LIMIT 0,  50 查看表中数据、索引、已分配给表但没有使用空间： SELECT table_name,  TABLE_SCHEMA,  DATA_LENGTH/ 1024 / 1024 _DATA, INDEX_LENGTH/ 1024 / 1024 _INDEX, DATA_FREE/ 1024 / 1024 _DATA_FREE,  TABLE_ROWS  FROM  information_schema. TABLES  WHERE  TABLE_SCHEMA NOT IN ('information_schema','mysql')  ORDER BY  _DATA DESC  LIMIT 0,  50 查看数据库的文件大小： SELECT file_name, concat(TOTAL_EXTENTS,'M') as 'FIle_size' FROM INFORMATION_SCHEMA.FILES order by TOTAL_EXTENTS DESC 阻塞问题排查/解决 -- 查看有哪些表是打开的 show open tables -- where in_use &gt; 0; -- 查看进程 show [full] processlist; -- 查看 Sending data 状态的进程 select * from information_schema.`PROCESSLIST` where db = 'db_name' and state = 'Sending data' order by time desc; -- 批量生成 kill &lt;pid&gt;; 语句 select concat(kill , id, ;) from information_schema.`PROCESSLIST` where db = 'db_name' and state = 'Sending data' order by time desc; -- 批量生成 kill &lt;pid&gt;; 语句并将结果集写到文件 select concat(kill , id, ;) from information_schema.`PROCESSLIST` where db = 'db_name' and state = 'Sending data' order by time desc into outfile '/tmp/a.txt'; -- 执行文件 source /tmp/a.txt -- 杀掉指定进程 kill &lt;pid&gt;; -- 查看正在锁的事务 select * from information_schema.INNODB_LOCKS; -- 查看等待的事务 select * from information_schema.INNODB_LOCK_WAITS; -- 查看线程相关数量 show global status like 'Thread%' -- 查看缓存线程数配置 show VARIABLES like 'thread_cache_size' SQL 技巧 -- 在原值后面附加内容，以值的最右几位为条件 update table_name set col1 = concat(col1, 'xxx') where right(col1, 1) = '?'; -- limit 示例 SELECT * FROM Orders LIMIT 30; SELECT * FROM Orders LIMIT 10 OFFSET 15; -- 第 16 到第 25 个结果 SELECT * FROM Orders LIMIT 15, 10; -- 等价于上面 ",
      "url"      : "https://kekaiyuan.github.io//wiki/mysql/",
      "keywords" : "MySQL"
    } ,
  
    {
      "title"    : "Navicat",
      "category" : "Tools",
      "content": "版本：Navicat Premium 11.1.9 破解版 Github 连接 Oracle 数据库 工具 / 选项 /  ",
      "url"      : "https://kekaiyuan.github.io//wiki/navicat/",
      "keywords" : "Navicat"
    } ,
  
    {
      "title"    : "OllyDbg",
      "category" : "debug",
      "content": "快捷键 Ctrl –&gt; C Shift –&gt; S Alt –&gt; M    功能  快捷键     设置/取消断点  F2    执行到光标所在行  F4    步过  F8    步进  F7    运行  F9    暂停  F12    回到应用层  M-F9    打开文件  F3    重新调试  C-F2    打开应用程序输入表  C-n    寻找表达式  C-g    打开断点窗口  M-b    切换断点状态  空格    添加备注  ;  ",
      "url"      : "https://kekaiyuan.github.io//wiki/ollydbg/",
      "keywords" : "debug, ollydbg"
    } ,
  
    {
      "title"    : "OneNote",
      "category" : "Tools",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command 调整文本格式    功能  Windows  Mac OS X     高亮选中文本  C-S-h 或 C-M-h       插入超链接  C-k  Cmd-k    复制选中文本的格式（格式刷）  C-S-c  Cmd-M-c    应用格式刷到选中文本  C-S-v  Cmd-M-v    打开光标下的链接  Enter  Enter    加黑  C-b  Cmd-b    斜体  C-i  Cmd-i    下划线  C-u  Cmd-u    删除线  C-Hyphen(-)  C-Cmd-Hyphen(-)    上标  C-S-=  Cmd-M-S-=    下标  C-=  Cmd-M-=    无序列表标记  C-Period(.)  Cmd-Period(.)    有序列表标记  C-Slash(/)  Cmd-Slash(/)    标题一  C-M-1  Cmd-M-1    标题六  C-M-6  Cmd-M-6    正文，清除格式  C-S-n  Cmd-S-n    增加段落缩进  M-S-Right  Cmd-]    减少段落缩进  M-S-Left  Cmd-[    左对齐  C-l  Cmd-l    右对齐  C-r  Cmd-r    增大选中文本字体  C-S-&gt;       减小选中文本字体  C-S-&lt;       在当前页面显隐基准线  C-S-r      视图    功能  Windows  Mac OS X     显示/隐藏功能区     Cmd-M-R    放大页面     Cmd-+    缩小页面     Cmd-Hyphen(-)    重置缩放     Cmd-0   插入元素    功能  Windows  Mac OS X     插入日期  M-S-d  Cmd-d    插入时间  M-S-t       插入日期+时间  M-S-f  Cmd-S-d   注：在 Windows 下插入的日期格式取决于系统的「日期、时间和区域格式设置」里的设置。 表格    功能  Windows  Mac OS X     在当前行下面新建行  C-Enter  Cmd-Enter    在当前行上面新建行  光标移到行首，Enter  光标移到行首，Enter    在当前列右边新建列  C-M-r  C-Cmd-r    在当前列左边新建列     C-Cmd-l    在当前单元格开始新段落  M-Enter  M-Enter   选择与移动    功能  Windows  Mac OS X     移动光标到页面标题并选中  C-S-t  Cmd-S-t    将段落上移  M-S-Up  Cmd-M-Up    将段落下移  M-S-Down  Cmd-M-Down    返回上一个访问过的页面  M-Left  C-Cmd-Left    前进到后一个访问过的页面  M-Right  C-Cmd-Right    到页面顶端     Cmd-Up    到页面底端     Cmd-Down    到上一个段落     M-Up    到下一个段落     M-Down   分区与页面    功能  Windows  Mac OS X     新建页面到当前分区最后面  C-n  Cmd-n    在当前页面下新建同级页面  C-M-n  Cmd-n    在当前页面下新建子页面  C-M-S-n       增加页面层级  C-M-]  Cmd-M-]    减少页面层级  C-M-[  Cmd-M-[    选中当前页面  C-M-g  Cmd-S-a    上移当前选中页面  M-S-Up  Cmd-M-Up    下移当前选中页面  M-S-Down  Cmd-M-Down    返回访问的上一页  M-Left  C-Cmd-Left    返回访问的下一页  M-Right  C-Cmd-Right    停靠到桌面  C-M-d       显示上一个分区  C-S-Tab       显示下一个分区  C-Tab       显示当前分区的上一个页面  C-Page Up  Cmd-Page Up    显示当前分区的下一个页面  C-Page Down  Cmd-Page Down    显示当前分区的第一个页面  M-Home  M-Home    显示当前分区的最后一个页面  M-End  M-End   小技巧  搜索带特殊字符如「空格」等，用 将搜索关键字括起来。   删除「我的模板」 在 Windows 下的 C:  Users  &lt;username&gt;  AppData  Roaming  Microsoft  Templates 里找到文件 我的模板.one，双击打开将显示你所有的模板页面，删除你想要删除的然后关闭即可。 参考  OneNote 2010 的键盘快捷键 Keyboard shortcuts in OneNote for Windows 10 ",
      "url"      : "https://kekaiyuan.github.io//wiki/onenote/",
      "keywords" : "OneNote, GTD"
    } ,
  
    {
      "title"    : "PHP",
      "category" : "php",
      "content": "Q &amp; A 如何查看 php.ini 文件路径？ 新建一个 test.php 文件，内容如下： &lt;?php phpinfo(); ?&gt; 然后在浏览器使用 url 访问 test.php，会显示 php 相关的配置、插件等大量相关信息，在其中 Loaded Configuration File 一项即可找到所有生效的 php.ini 文件路径。 或者，更简单地可以直接运行命令输出以上信息（如果安装了多个版本的 php，那注意使用正确的 php 命令）： php -r phpinfo(); 本地运行一个 php 文件 php [-f] test.php 几种错误提示及对应的解决办法 提示： PHP Fatal error: Uncaught Error: Call to undefined function socket_create() 解决办法： 在 php.ini 文件中配置启用扩展 php_curl.dll。 提示： PHP Fatal error: Uncaught Error: Call to undefined function curl_init() 解决办法： 在 php.ini 文件中配置启用扩展 php_curl.dll。 提示： The openssl extension is required for SSL/TLS protection but is not available. If you can not enable the openssl extension, you can disable this error, at your own risk, by setting the 'disable-tls' option to true 解决办法： 在 php.ini 文件中配置启用扩展 php_openssl.dll。 在开发环境下直接在页面显示出错信息 修改 php.ini 文件，配置 display_errors = On。 安装 Memcache（not Memcached）for php7 当前（2016-10-19）Memcache 扩展并未有官方的支持办法，所以从源码编译安装。 步骤：  下载解压源码 wget https://github.com/websupport-sk/pecl-memcache/archive/NON_BLOCKING_IO_php7.zip unzip NON_BLOCKING_IO_php7.zip cd pecl-memcache-NON_BLOCKING_IO_php7   编译 /usr/local/php7/bin/phpize &amp;&amp; ./configure --enable-memcache --with-php-config=/usr/local/php7/bin/php-config &amp;&amp; make   注意 phpize 和 php-config 要使用 php7 下的。   放置 so 文件到正确位置 cp modules/memcache.so /usr/local/php7/lib/php/extensions/no-debug-non-zts-20151012/memcache.so   目标路径可以在 phpinfo() 的 extension_dir 字段找到。   配置 echo 'extension=memcache.so' &gt; /usr/local/php7/etc/php.d/memcache.ini   目标路径可以在 phpinfo() 的 Scan this dir for addtional .ini files 字段找到。   重启服务使扩展生效 service php-fpm restart   参考 Memcache extension with PHP 7 on CentOS fails to install。 修改 php.ini 后让配置生效 service php-fpm restart ",
      "url"      : "https://kekaiyuan.github.io//wiki/php/",
      "keywords" : "php"
    } ,
  
    {
      "title"    : "PowerShell",
      "category" : "Windows",
      "content": "使用 PowerShell 打造 Windows 下的顺手终端。 与 Cmder 配合使用 搭配 Cmder 一起服用，才最好。 配置文件位置 PowerShell 6 默认配置文件 ~/Documents/WindowsPowerShell/Microsoft.PowerShell_profile.ps1。 PowerShell 7 默认配置文件 &lt;我的文档&gt;/PowerShell/Microsoft.PowerShell_profile.ps1 Cmder 的 PowerShell 配置文件 &lt;cmd_install_path&gt;/config/user-profile.ps1。 alias 快速进入某目录 例：通过 src 命令快速进入 d:  sources   目录。 function Enter-Sources {  cd d:  sources   } Set-Alias src Enter-Sources 快速打开当前文件夹 例：通过 e. 命令快速在资源管理器打开当前文件夹。 function Open-Current-Directory {  explorer . } Set-Alias e. Open-Current-Directory git 相关命令 ## gs=git status function Git-Status {  git status } Set-Alias gs Git-Status ## ga=git add . function Git-Add-All {  git add . } Set-Alias ga Git-Add-All ## gg=gitk function Git-Gui {  gitk } Set-Alias gg Git-Gui ## gpull=git pull origin &lt;current branch&gt; function Git-Pull-Current-Branch {  $currentBranch = git symbolic-ref --short -q HEAD  git pull origin $currentBranch } Set-Alias gpull Git-Pull-Current-Branch ## gpush=git push origin &lt;current branch&gt; function Git-Push-Current-Branch {  $currentBranch = git symbolic-ref --short -q HEAD  git push origin $currentBranch } Set-Alias gpush Git-Push-Current-Branch ## g1=add、commit、push 一条龙 function Git-Commit-And-Push {  git add .  git commit -m $args[0]  Git-Push-Current-Branch } Set-Alias g1 Git-Commit-And-Push objdump function Obj-Dump {  D:  Android  sdk  dk-bundle  toolchains  x86_64-4.9  prebuilt  windows-x86_64  bin  x86_64-linux-android-objdump.exe $args } Set-Alias objdump Obj-Dump 快捷键映射 从 Linux/macOS 的 bash 甚至 Windows 的 cmd 下切换过来后，发现 ctrl-u、ctrl-k 等快捷键不可用了，各种不顺手，PSReadLine 拯救你。 # ctrl-k, ctrl-u, ctrl-a, ctrl-e, ctrl-b, ctrl-f, etc Import-Module PSReadLine Set-PSReadLineOption -EditMode Emacs 常用命令 查看 PATH 环境变量 type env:path 或者将它们每个一行显示： (type env:path) -split ';' 还可以过滤： (type env:path) -split ';' | sls bin 参考  用 PowerShell 快速查看 PATH 环境变量 ",
      "url"      : "https://kekaiyuan.github.io//wiki/powershell/",
      "keywords" : "Windows, PowerShell"
    } ,
  
    {
      "title"    : "Python",
      "category" : "Python",
      "content": "模块 requests 优雅简单的 HTTP 模块。 BeautifulSoup 很好用的 HTML/XML 解析器。 json JSON 编码解码器。 应用举例：  格式化 JSON 文件 python -m json.tool src.json &gt; dst.json   在 Vim 里格式化 JSON： :%!python -m json.tool   CGIHTTPServer 简单实用的 HTTP 服务器。 应用举例：  运行一个简易的 HTTP 服务器 python -m CGIHTTPServer 80   base64 方便地进行 base64 编解码的模块。 应用举例：  解码 base64 echo aGVsbG93b3JsZA== | python -m base64 -d   则能看到输出 helloworld   问题解决 Your PYTHONPATH points to a site-packages dir 报错信息： ~/github/hs-airdrop$ npm install &gt; bcrypto@5.0.3 install /Users/username/github/hs-airdrop/node_modules/bcrypto &gt; node-gyp rebuild Your PYTHONPATH points to a site-packages dir for Python 3.x but you are running Python 2.x! PYTHONPATH is currently: /usr/local/lib/node_modules/npm/node_modules/node-gyp/gyp/pylib You should `unset PYTHONPATH` to fix this. gyp ERR! configure error gyp ERR! stack Error: `gyp` failed with exit code: 1 gyp ERR! stack  at ChildProcess.onCpExit (/usr/local/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16) gyp ERR! stack  at ChildProcess.emit (events.js:210:5) gyp ERR! stack  at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12) gyp ERR! System Darwin 19.3.0 gyp ERR! command /usr/local/Cellar/node/12.12.0/bin/node /usr/local/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js rebuild gyp ERR! cwd /Users/username/github/hs-airdrop/node_modules/bcrypto gyp ERR! node -v v12.12.0 gyp ERR! node-gyp -v v5.0.5 gyp ERR! not ok npm ERR! code ELIFECYCLE npm ERR! errno 1 npm ERR! bcrypto@5.0.3 install: `node-gyp rebuild` npm ERR! Exit status 1 npm ERR! npm ERR! Failed at the bcrypto@5.0.3 install script. npm ERR! This is probably not a problem with npm. There is likely additional logging output above. npm ERR! A complete log of this run can be found in: npm ERR!  /Users/username/.npm/_logs/2020-02-19T14_14_34_524Z-debug.log 解决方法： 删除 /usr/local/lib/python3.7/site-packages/ 文件夹下的 sitecustomize.pyc，将 sitecustomize.py 文件重名为 sitecustomize.py~，安装成功之后再改回来。 ",
      "url"      : "https://kekaiyuan.github.io//wiki/python/",
      "keywords" : "Python"
    } ,
  
    {
      "title"    : "Qt Creator",
      "category" : "Qt",
      "content": "快捷键（for mac） 参考：http://doc.qt.io/qtcreator/creator-keyboard-shortcuts.html C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command    功能  快捷键     自动完成  C-Space    显示/隐藏侧边栏  Cmd-0    切换已打开的文件  M-Tab    上/下一行  C-p/C-n    前进/后退一个字符  C-f/C-b    删除一个单词  M-Del    构建  Cmd-b    运行  Cmd-r    调试  Cmd-y    注释  Cmd-/    换行  Cmd-Return    跳到定义  F2    切换头文件与源文件  F4    前进/后退  M-Cmd-Left/Right    打开定位器  Cmd-k  ",
      "url"      : "https://kekaiyuan.github.io//wiki/qt-creator/",
      "keywords" : "Qt, Qt Creator"
    } ,
  
    {
      "title"    : "Scoop",
      "category" : "Windows",
      "content": "指定 Scoop 安装目录 环境变量： SCOOP='D:  Applications  Scoop' 指定安装程序自定义目录 设置 SCOOP 环境变量后，程序会默认安装在 %SCOOP%  apps 目录下。 还可以自定义全局安装目录： SCOOP_GLOBAL='D:  Applications  ScoopApps' 这样需要 scoop install -g &lt;appname&gt; 来全局安装，需要使用管理员权限执行。 加快下载速度 scoop install aria2 软件下载 安装到默认目录： scoop install &lt;appname&gt; 安装到全局安装目录： scoop install -g &lt;appname&gt; 软件搜索： scoop search &lt;appname&gt; 列出已知 bucket： scoop bucket known 添加 bucket： scoop bucket add &lt;bucketname&gt; 查看软件信息 列出已安装软件： scoop list 查看某软件信息： scoop info &lt;appname&gt; ",
      "url"      : "https://kekaiyuan.github.io//wiki/scoop/",
      "keywords" : "scoop, windows"
    } ,
  
    {
      "title"    : "Skill Tree",
      "category" : "mindmap",
      "content": "# 技能树 ## Java 后端开发 ## Android 开发 ## Windows 开发 ## 通用技能 ### 操作系统 #### Windows #### Linux #### macOS ### 编辑器 #### Vim #### Visual Studio Code ### 标记语言 #### Markdown ### 版本控制 #### Git #### SVN ",
      "url"      : "https://kekaiyuan.github.io//wiki/skill-tree/",
      "keywords" : "技能树, 思维导图, mindmap, 脑图"
    } ,
  
    {
      "title"    : "Source Insight",
      "category" : "Tools",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt    功能  快捷键     返回  M-,    前进  M-.    跳到定义  C-=    查找引用  C-/    搜索  C-f    向下搜索  F4    向上搜索  F3    高亮当前单词  S-F8   Q&amp;A  新建工程后函数跳转等遇到 symbol not found 如何解决？ 打开菜单里的「Project」-「Synchronize Files」（快捷键 Alt + Shift + S），勾选 Force all files to be re-parsed 后点击 OK，等待 Source Insight 重新解析工程里的文件完成即可。   如何在标题栏里显示文件全路径？ 打开菜单里的「Options」-「Preferences」-「Display」，取消勾选 Trim long path names with ellipses。  ",
      "url"      : "https://kekaiyuan.github.io//wiki/source-insight/",
      "keywords" : "Source Insight"
    } ,
  
    {
      "title"    : "Swimming",
      "category" : "Hobbies",
      "content": "蛙泳 我目前能游出最远距离的泳姿。 视频  蛙泳教学完整版 动作时序图 要领  先划手，后收腿，先伸胳膊后蹬腿。 腿部动作时一定要勾脚，大腿不要收太多。 收腿放松，蹬腿用力，蹬完一定要漂一会，把握好节奏，不要快蹬快收。 手部划水动作不要过大，不要超过肩部。 两手开始外分时就抬头吸气。 自由泳 视频  值得一看的自由泳教学视频 ",
      "url"      : "https://kekaiyuan.github.io//wiki/swimming/",
      "keywords" : "游泳, 蛙泳"
    } ,
  
    {
      "title"    : "Wiki Template",
      "category" : "cate1",
      "content": "Content here ",
      "url"      : "https://kekaiyuan.github.io//wiki/template/",
      "keywords" : "keyword1, keyword2"
    } ,
  
    {
      "title"    : "Java 版本冲突",
      "category" : "Java",
      "content": "springboot 2.5.6 与 hibernate-validator 7.0.1 Fianl 冲突。 会导致 @NotNull @Max @Min 等注释失效。 ",
      "url"      : "https://kekaiyuan.github.io//wiki/version-confilict/",
      "keywords" : "版本冲突"
    } ,
  
    {
      "title"    : "Vim",
      "category" : "Vim",
      "content": "移动 以字（符）为单位    功能  按键     上  k    下  j    左  h    右  l   以单词为单位    功能  按键     前一个单词尾  ge    后一个单词首  w    本单词首（已在本词首则跳到前一单词首）  b    本单词尾（已在本词尾则跳到后一单词尾）  e   以屏幕为单位    功能  按键     向下翻页  CTRL-f    向上翻页  CTRL-b    向下翻半页  CTRL-d    向上翻半页  CTRL-u    向上一行  CTRL-y    向下一行  CTRL-e    光标移到屏幕上方  H    光标移到屏幕中间  M    光标移到屏幕下方  L    光标所在位置移到屏幕上方  zt    光标所在位置移到屏幕中间  zz    光标所在位置移到屏幕下方  zb   行号    功能  按键     跳到第 num 行  :num 或 numG 或 numgg   文件    功能  按键     跳到文件头  gg    跳到文件尾  G   编辑 复制    功能  按键     复制光标所在单词  yiw    复制光标所在行  yy   粘贴    功能  按键     在光标之后粘贴  p    在光标之前粘贴  P   剪切    功能  按键     剪切选中区域  d    剪切光标所在行  dd   替换    功能  按键     将全文中的 str1 替换为 str2  :%s/str1/str2/g    将 1 到 5 行中的 str1 替换为 str2  :1,5s/str1/str2/g   大小写    功能  按键     将选中内容大小写互换  ~    将选中内容全转为小写  gu    将选中内容全转为大写  gU    将当前行变成小写  guu    将当前行变成大写  gUU    将匹配内容替换为大写  :%s/xxx/  U&amp;/g    将匹配内容替换为小写  :%s/xxx/  L&amp;/g   注：&amp; 代表正则表达式全部匹配项，另外还有   1、’  2’、…、  9 代表第 1 到 9 个匹配项。 选择    功能  按键     选中上一次选择的区域  gv    选中括号内区域  vi{、vi[、vi(   搜索    功能  按键     向下查找字符串  /str    向上查找字符串  ?str    查找下一个  n    查找上一个  N    向下查找光标所在单词  *    向下查找光标所在单词  #   正则表达式    功能  按键     匹配单词左边界    &lt;    匹配单词右边界    &gt;    去重  :g/^  (.*  )$    1/d   常用    功能  按键     删除空行  :g/^$/d    撤销/UNDO  u    重做/REDO  C-r    统计行/单词/字符/字节数  g C-g    去掉 UTF-8 BOM  :set nobomb    保留 UTF-8 BOM  :set bomb   全局    功能  按键     退出  :q    强制执行  !    执行外部命令  :!   文件操作    功能  按键     打开  :e    打开文件对话框  :bro e    保存  :w    另存为对话框  :bro w    查看历史文件列表  :ol    查看并打开历史文件  :bro ol    重命名当前文件  :f filename   vimdiff    功能  按键     移动到上一个不同处  [c    移动到下一个不同处  ]c    该差异点使用当前文件的  dp    该差异点使用其它文件的  do    手动刷新重新比较  :diffupdate   Buffer    功能  按键     查看 Buffer 列表  :ls    转到 Buffer 列表中的下一个 Buffer  :bn    转到 Buffer 列表中的上一个 Buffer  :bp    转到 Buffer 列表中的 num 号 Buffer  :bnum    你之前待过的一个 Buffer  :b#    从 Buffer 列表中删除 num 号 Buffer  :bdnum   组合命令 可以使用 | 来组合命令，比如 cmd1 | cmd2。 代码    功能  按键     格式化代码  gg=G    去除 1-20 行首的行号  :1,20s/^    s  *[0-9]  *    s  *//g    展开全部折叠  zR    展开当前层级折叠  zr    全部折叠  zM    当前层级折叠  zm    切换折叠/展开  za    递归折叠/展开当前大区块  zA    折叠当前区块  zc    递归折叠当前大区块  zC    展开当前区块  zo    递归展开当前大区块  zO    格式化 json 数据  :%!python -m json.tool    缩进当前行  &gt;&gt;    反缩进当前行  &lt;&lt;   modeline 写法： vim: set ft=markdown: vim: ft=markdown // vim: noai:ts=4:sw=4 /* vim: noai:ts=4:sw=4 */ 插件 CtrlP 基础按键 C-p    功能  按键     刷新列表  F5    切换文件/缓冲区/MRU  C-f/b    切换全路径搜索/文件名搜索  C-d    切换正则表达式模式  C-r    上/下一个选项  C-k/j    在新标签/垂直分割/水平分割打开文件  C-t/v/x    历史选择记录的上/下一条  C-p/n    创建文件和它的父路径  C-y    标记并打开多个文件  C-z C-o    退出 CtrlP  C-c   LeaderF    功能  按键     打开文件  Leader-f    打开缓冲区  Leader-b    打开 MRU  Leader-m（自定义的）    退出  C-c    切换模糊查找和正则查找  C-r    粘贴  C-v    清空输入  C-u    上/下一个选项  C-k/j    在新标签/垂直分割/水平分割打开文件  C-t/]/v    刷新列表  F5   vim-table-mode    功能  按键     删除列  Leader-tdc    删除行  Leader-tdd    重新格式化表格  Leader-tr   命令行 打开 Vim 时跳转到指定行： vim +[num] filename num 表示行号，不填则跳转到文件末尾。 ",
      "url"      : "https://kekaiyuan.github.io//wiki/vim/",
      "keywords" : "Vim"
    } ,
  
    {
      "title"    : "Visio",
      "category" : "Tools",
      "content": "小问题记录 连接线箭头 如果在 Visio 2013/2016 里画流程图，发现连接线没有箭头，检查一下「设计」菜单里是否将主题设置成了「无主题」，如果是，取消掉就好了。 鼠标悬停提示 把鼠标悬停在图形上四周应该有几个小三角提示，如果没有，检查「视图」里是否勾选了「自动连接」，如果没有，勾选上。 调整导出 PNG 大小 导出 PNG 时，填好保存位置和文件名之后，会弹出一个「PNG 输出选项」，在其中调整大小即可。 ",
      "url"      : "https://kekaiyuan.github.io//wiki/visio/",
      "keywords" : "Visio"
    } ,
  
    {
      "title"    : "Visual Studio Code",
      "category" : "Tools",
      "content": "快捷键 C –&gt; Ctrl S –&gt; Shift M –&gt; Alt Cmd –&gt; Command    功能  Windows  Mac OS X     打开文件  C-o       打开文件夹  C-k C-o       关闭文件夹  C-k f       命令面板  C-S-p       资源管理器  C-S-e       搜索  C-S-f       Git  C-S-g       调试  C-S-d       插件  C-S-x       Markdown 侧边预览  C-k v       Markdown 预览  C-S-v      使用 VSCode 作为 mergetool 编辑 ~/.gitconfig 文件，添加如下内容： [merge]  tool = vscode [mergetool vscode]  cmd = code --wait $MERGED 需要的时候执行 git mergetool 就会调起了。 参考：https://blog.kulman.sk/using-vscode-as-git-merge-tool/ VSCodeVim 支持按键重复 在 macOS，默认情况 VSCodeVim 模式下是不支持按键重复的，比如你在 Normal 模式下长按 L，结果光标只向右移动了一次，而没有像你预期的那样一直移动。 启用按键重复的方法在插件的 REAME 有说明，链接：https://github.com/VSCodeVim/Vim#mac 方法： 按需执行下面的某一行命令并重启 VSCode。 $ defaults write com.microsoft.VSCode ApplePressAndHoldEnabled -bool false  # For VS Code $ defaults write com.microsoft.VSCodeInsiders ApplePressAndHoldEnabled -bool false # For VS Code Insider $ defaults write com.visualstudio.code.oss ApplePressAndHoldEnabled -bool false # For VS Codium $ defaults delete -g ApplePressAndHoldEnabled       # If necessary, reset global default 如果有需要，调整「系统偏好设置」—「键盘」里的「按键重复」和「重复前延迟」。 ",
      "url"      : "https://kekaiyuan.github.io//wiki/visual-studio-code/",
      "keywords" : "Visual Studio Code"
    } ,
  
    {
      "title"    : "Visual Studio",
      "category" : "Tools",
      "content": "地球上最好用的 C++ 开发环境，没有之一。现在也有免费的社区版了，可惜以前密集写 C++ 代码的时候没赶上。 快捷键    功能  快捷键     快速打开 anything  C-,    当前打开文件  C-M-Down    切换头/源文件  C-ko    返回  C–    前进  C-S–    跳转到定义  F12    在新窗口展示定义  M-F12    跳转到声明  C-M-F12    上/下移动行  M-Up/Down    在上面插入行  C-Enter    在下面插入行  C-S-Enter    折叠/展开当前代码段  C-mm    注释  C-kc    取消注释  C-ku    选中单词大写  C-S-u    选中单词小写  C-u    调试  F5    执行  C-F5    设置断点  F9    步过  F10    步入  F11   插件  Go To Definition Make ctrl+click perform a “Go To Definition” on the identifier under the cursor.   Visual Assist Productivity tool for C/C++ and C# that improves IDE features related to navigation, refactoring, code generation, and coding assistance. 参考  visual studio 2013 快捷键大全、VS2013常用快捷键完整页 ",
      "url"      : "https://kekaiyuan.github.io//wiki/visual-studio/",
      "keywords" : "Visual Studio"
    } ,
  
    {
      "title"    : "Windows Terminal",
      "category" : "Tools",
      "content": "Windows Terminal 是微软打造的一款新的控制台终端，目前还在 Preview 版本，但经过一些配置已经可以用得不错。 自定义主题 可以到 https://github.com/mbadolato/iTerm2-Color-Schemes 的 windowsterminal 下寻找合适的主题。 自定义配置文件位置 我想将配置文件放到 HOME 目录下，然后通过 git 管理，通过以下办法可以做到： 首先剪切 ~/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/RoamingState/profiles.json 文件到 ~/Windows-terminal-profiles.json，然后管理员权限打开 PowerShell，执行 New-Item -ItemType SymbolicLink -Path ~/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/RoamingState/profiles.json -Target ~/windows-terminal-profiles.json 我的 Windows Terminal 文件见 https://github.com/mzlogin/config-files/blob/master/windows-terminal-profiles.json 通过 git 管理 PowerShell 配置 管理员权限打开 PowerShell，执行 New-Item -ItemType SymbolicLink -Path ~/Documents/WindowsPowerShell/Microsoft.PowerShell_profile.ps1 -Target ~/powershell.ps1 如果是使用 PowerShell 7 Preview，执行 New-Item -ItemType SymbolicLink -Path &lt;我的文档&gt;/PowerShell/Microsoft.PowerShell_profile.ps1 -Target &lt;个人目录&gt;/powershell.ps1 上面两个目录需要使用绝对路径，不然会报错。 我的 PowerShell 配置见 https://github.com/mzlogin/config-files/blob/master/powershell.ps1 自定义快捷键 比如在 json 配置文件的 globals – keybindings 里添加如下内容，可以将 Windows Terminal 的复制粘贴映射为 ctrl+c 和 ctrl+v（这里真的要吐槽下，为什么不给默认映射上呢？）： Updated 2020-04-26： 下面这些不用再手动映射了，新版本里都给了默认映射。 { command: copy, keys: [ctrl+c] }, { command: paste, keys: [ctrl+v] } split pane 和 move focus within panes： { command : splitHorizontal, keys: [ alt+- ] }, { command : splitVertical, keys: [ alt+     ] }, { command : closePane, keys: [ alt+w ] }, { command : moveFocusLeft, keys: [ alt+left ] }, { command : moveFocusRight, keys: [ alt+right ] }, { command : moveFocusUp, keys: [ alt+up ] }, { command : moveFocusDown, keys: [ alt+down ] } 参考：https://github.com/microsoft/terminal/blob/master/doc/user-docs/UsingJsonSettings.md ",
      "url"      : "https://kekaiyuan.github.io//wiki/windows-terminal/",
      "keywords" : "Windows Terminal"
    } 
  
]

