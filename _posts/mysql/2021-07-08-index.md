---
layout: post
title: Mysql 之——索引
categories: [cate1, cate2]
description: Mysql 之——索引
keywords: keyword1, keyword2
mermaid: true
---

索引是任何数据库中都十分**重要**的一个技术点。

索引是放在磁盘的，是持久化的数据。<br>
只是在使用的时候为了加快速度加载到内存。

## 索引面试题

- 索引是帮助 MySQL 高效获取数据的数据结构
- 索引存储在文件系统中
- 索引的文件存储形式与存储引擎有关
- 索引文件的结构
	- hash
	- 二叉树
	- B树
	- B+树

B+树的优势在哪儿？
- hash 表
	- hash 表适用于等值查询，而业务中更多的是范围查询。
	- hash 表在使用的时候需要把全部的数据加载到内存，比较耗费内存空间。

树
在树的结构中，左子树的值小于根节点，根节点小于右子树，多叉树从左到右是有序的

```mermaid
graph LR;
A[多叉树] --> B[二叉树] 
B --> C[AVL树]
```


二叉树：左右子树不平衡

AVL树是一颗严格意义上的平衡树，最高子树跟最低子树高度之差不能超过1，因此在进行元素插入的时候回进行 1 到 N 此的旋转，严重影响插入的性能

红黑树是基于AVL树的一个升级，损失了部分查询的性能，来提升插入的性能，在红黑树中最低子树跟最高子树高度之差不超过 2 倍即可，在插入的时候，不需要进行 N 多次的旋转操作，而且还加入了变色的特性，来满足插入和查询性能的平衡

二叉树及其 N 多的变种都不能支撑索引。原因是树的深度无法控制或者插入数据的性能比较低。



不同的数据引擎，数据文件和索引文件存放的位置是不同的，因此有了分类
- 聚簇索引
	- 数据和文件放在一起<br>
		InnoDB<br>
		
		| 文件后缀 | 文件内容 |
		| :----: | :----: |
		| .frm | 表结构 |
		| .idb | 数据和索引 |


- 非聚簇索引
	- 数据和索引单独一个文件<br>
		MyISAM<br>
		
		| 文件后缀 | 文件内容 |
		| :----: | :----: |
		| .frm | 表结构 |
		| .myi | 索引 |
		| .myd | 数据 |



一般情况下找不到 .idb文件，因为 mysql 默认使用 innodb ，其中默认把所有的数据和索引存放在同一个文件中

打开 mysql 命令行，输入
```
show variables like 'innodb_file_per_table';
```
```
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | OFF   |
+-----------------------+-------+
```
这个参数的意思是要不要给innodb中的每一个表建立单独的文件，可以看到是 off ，也就是不

set global innodb_file_per_table=off;


表太小不需要建索引，速度反而会慢
没索引：直接查
有索引：先查索引，再查表

非聚簇索引
给普通列建索引，先查到主键。
再去查主键索引，查到数据。
要查两颗B+树，回表


## 索引的分类
mysql索引的五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。<br>
通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。
###  主键索引

主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键。<br>
主键往往使用自动递增的方式，为了保证并发下主键不会发生冲突，有一个自增锁。<br>
当我 insert 10 条 sql 数据失败了回滚，但是自增锁依然往后递增了 10 次<br>
自动递增时索引更新的花费最低（直接插到最右边）。<br>
如果不是自动递增，当主键值在中间时，会引起多个磁盘块的更新。<br>
不仅会造成页分裂，还会造成每个页都不满

如果你没有为你的表定义 PRIMARY KEY，MySQL 会选择第一个只有 NOT NULL 列的 UNIQUE 索引作为主键，InnoDB 使用它作为聚集索引。<br>
如果表中没有这样的索引，InnoDB 会在内部生成一个聚集索引，其中的行按照 InnoDB 分配给此类表中行的 rowID 进行排序。<br>
行 ID 是一个 6 字节的字段，随着插入新行而单调增加。<br>
因此，按行 ID 排序的行在物理上是按插入顺序排列的。

###  唯一索引
索引列的所有值都只能出现一次，即必须唯一，值可以为空。

### 普通索引

基本的索引类型，值可以为空，没有唯一性的限制。（覆盖索引） <br>
覆盖索引<br>
select * from test where name = 'xxx' 要回表
select id from test where name = 'xxx' 不需要回表

mysiam 没有回表

### 全文索引，MyISAM支持，Innodb在5.6之后支持
全文索引的索引类型为FULLTEXT。全文索引可以在varchar、char、text类型的列上创建<br>
倒排索引

真正的全文索引一般不使用数据库实现，使用 Lucene，Solr，ElasticSearch 等全文检索引擎实现

### 组合索引

多列值组成一个索引，专门用于组合搜索（最左匹配原则）

id，name，age，address

如果使用 name 和 age 组合索引
最左匹配就是先匹配 name，name符合了再去匹配 age


----------


**组合索引的顺序非常重要**

加入现在需要建立两个索引： (name ,age) 和 (age) 

如果组合索引的顺序是先 name 再 age
那么还要单独建一个 age 的索引
就需要建立两颗索引树

如果组合索引的顺序是先 age 再 name
那么不需要再单独建 age 的索引
就只需要建立一颗索引树

----------

现在需要建立三个索引：(name ,age ) ,(name) ,(age)

有两种实现方案：
1. 建立 (name ,age) 和 (name) 两颗索引树
2. 建立 (age,name) 和 (age) 两颗索引树

哪种更好？

第二种方案更好。<br>
因为 age 字段是 int 类型，name 字段是字符串类型，age 字段所占据的空间更小。<br>
第一种方案是 name\*2 + age\*1 ，而第二种方案是 name + age\*2。<br>
第二种方案所占据的空间更小。


----------

### 索引下推
现在有这样一张表 test

| id | name | age | sex |
| :--: | :--: | :--: | :--: |
| 1 | zhangsan | 10 | man |
| 2 | zhangsan | 20 | man |
| 3 | zhangsan | 30 | man |
| 4 | zhangsan | 40 | man |

建立了联合索引 (name ,age)

现在要执行这样的语句 `select * from test where name = 'zhangsan' and age = 10;`

在 Mysql 5.6 之前，是没有索引下推的，也就是说尽管这是一颗联合索引树，但是在搜索引擎的眼里，age 字段是被忽略的

(name ,age)索引树

| id | name | age | 
| :--: | :--: | :--: |
| 1 | zhangsan | ~~10~~ |
| 2 | zhangsan | ~~20~~ |
| 3 | zhangsan | ~~30~~ |
| 4 | zhangsan | ~~40~~ |

此时该语句的执行过程是先从索引树里找出 `name = 'zhangsan'` 的 id，然后再去 id 的索引树下找出 `age = 10` 的数据。<br>
即：(name ,age) 索引树会返回符合`name = 'zhangsan'`的 4 个 id 值，在 (id) 索引树中检索`age = 10` 的数据。

但在 Mysql 5.6 之后，有了索引下推，此时进行搜索时，搜索引擎不会忽略 age 字段

| id | name | age |
| :--: | :--: | :--: |
| 1 | zhangsan | 10 |
| 2 | zhangsan | 20 |
| 3 | zhangsan | 30 |
| 4 | zhangsan | 40 |

此时在这颗联合索引树上查找时，搜索引擎不仅会对 name 做匹配，同时会对 age 做匹配。<br>
即：(name ,age) 索引树会返回符合`name = 'zhangsan' and age = 10`的 1 个 id 值，在 (id) 索引树中直接返回数据。


## 存储引擎

|  | MyISAM | InnoDB |
| :-: | :-: | :-: |
| 索引类型 | 非聚簇索引 | 聚簇索引 |
| 支持事务 | 否 | 是 |
| 支持表锁 | 是 | 是 |
| 支持行锁 | 否 | 是 |
| 支持外键 | 否 | 是 |
| 支持全文索引 | 是 | 是（5.6后支持） |
| 适合操作类型 | 大量select | 大量insert、delete、update |



## 索引优化

索引越少越好，索引是需要持久化存储的，需要占用磁盘空间，使用时还需要加载到内存，占用内存空间。
更新数据时还要维护索引。






## 源码链接
该文章源码链接 [Github](url)