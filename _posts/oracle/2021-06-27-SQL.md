---
layout: post
title: SQL之——查询
categories: SQL
description: SQL之——查询
keywords: SQL
---

SQL之——查询

SQL 语言指的是结构化查询语言 (Structured Query Language)，具有定义、查询、更新和控制等多种功能，是关系数据库的标准语言。

## SQL分类
- DML 
	- Data Manipulation Language 数据操纵语言
	- 针对**数据**
	- 关键字
		- SELECT 
		- INSERT 
		- UPDATE 
		- DELETE
- DDL
	- Data definition language 数据定义语言 
	- 针对**表**
	- 关键字
		- CREATE 
		- ALTER 
		- DROP 
		- RENAME 
- DCL 
	- Data Control Language 数据控制语言
	- **权限、事务**
	- 关键字
		- GRANT 
		- REVOKE
- Transaction
	- commit 
	- rollback 
	- savepoint
	
## 查看表
- `Select * from tab;`<br>
	查看用户下的所有表
- `Select * from user_tables;`<br>
	详细查询当前用户下的所有表
- `desc 表名;` 或 `describe dept;`<br>
	查看表结构
- `select table_name from user_tables; `<br>
	查看所有表
- `comment on table emp is ‘雇员表';`<br>
	 为表添加注释
- `comment on column emp.Empno is '雇员工号';`<br>
	  为列添加注释
	
## SQL 语句
### select
- Select-from-where句型
	```
	SELECT [DISTINCT] {*,column alias,..}
	FROM table alias
	Where 条件表达式
	```
	- alias 指别名，我们可以更改表或列的名字，以方便我们操作
		- Column alias
		- Column "alias"
			- 当别名中带有空格时，必须使用引号
		- Column as alias
		- **别名**可以是中文
	- 检索单个列<br>
		  `select col from tableName;`
	- 检索多个列<br>
		  `select col1, col2,col3 from tableName;`
	- 检索所有列
		- `select * from tableName;`
		- \* 称为通配符
			- 优点<br>
				书写方便、可以检索未知列
			- 缺点<br>
				降低检索的性能
			- 当只检索固定列的数据时，不要使用 \* ，效率低
			- 表过大，越要避免使用 \* ，否则很容易卡死
	- 给检索出的列起个别名
		- `select job "gong zuo" from emp;`
		- `select job as "gong zuo" from emp;`
	- 表别名
		- `Select e.* from emp e;`
		- `Select e.empno,e.deptno from emp e;`
	- distinct
		- 可将检索结果去重。
		- 当检索多个列，有一个字段不一样都不会被去重。


### where
- where 后面跟的是条件表达式
- 条件比较


#### ＝ , !＝ , <> , < , > , <= , >= , any , some , all
- != 和 <> 都表示不等于
- any , some , all 后面跟的是一堆数值
	- any 取其中任意一个<br>
	  `select sal from emp where sal > any(1000 , 1500 , 3000);`<br>
	  sal 只要大于 1000,1500,3000 中任意一个值即可。<br>
	  可以将 any 理解为**最小值**
	- some 和 any 一样，取**最小值**<br>
	  `select sal from emp where sal > some(1000 , 1500 , 3000);`
	- all 表示所有，即**最大值**<br>
	  `select sal from emp where sal > some(1000 , 1500 , 3000);`<br>
	  检索大于 3000 的 sal
	  
#### is null , is not null
- 在 SQL 语法中， null 表示一个特殊的含义，不能使用 = 和 != 进行比较
- 判断某字段是否为空，必须使用 is null 或 is not null


#### between x and y
- 找到**大于等于** x 的值和**小于等于** y 的值
- 包含 x 和 y 的值
- 以下语句等价
	- `select sal from emp where sal between 1500 and 3000;`
	- `select sal from emp where sal >= 1500 and sal <= 3000;`


#### in（list）, not in（list） 
- 需要进行某些值的等值判断的时候使用
- in 和 not in 会从后面的 list 列表中逐一比对
- `select * from emp where deptno in (10,20);`等价于<br>
   `select * from emp where deptno = 10 or deptno = 20;`
- `select * from emp where deptno not in (10,20);`等价于<br>
   `select * from emp where deptno != 10 or deptno != 20;`
   
   
#### exists（sub－query） 
- 相关子查询
- 现在要查询部门编号为10和20的员工，要求使用exists实现
	- 在 SQL 中，select 等同于一次循环，使用相关子查询等于使用双重循环
	- 在相关子查询中，要将外层循环和内层循环联系到一起，否则容易输出整张表
	- ```
		select *
			from emp e
			where exists (select deptno
							from dept d
							where (d.deptno = 10 or d.deptno = 20)
							and e.deptno = d.deptno)
	   ```
	- exists 等同于逻辑判断<br>
	  对于外层的 select 语句的每一个结果，exists 都会使用内层的语句进行一次判断：是否存在满足条件的语句
		- 若存在，则为 true ，外层 select 有效。
		- 若不存在，则为 false ，外层 select 无效。<br>
	  所以相关子查询必须把 外层select 和 内层select 联系起来，否则 内层select 的结果将恒定为固定值。
	- 同时使用 or 和 and，要用 () 把 or 语句括起来保证执行顺序。  


#### like , escape 
- **模糊查询**
- 在 like 的语句中，需要使用占位符或通配符
	- _ 占位符，可替换为**一个**任意字符
	- % 通配符，可替换为**无数个**任意字符
	- 不能过度使用通配符。如果其他操作符能达到目的，就不要使用通配符。
	- 确实需要使用通配符时，除非绝对必要，否则不要把通配符用到搜索模式最开始处，因为这样搜索起来是最慢的。
- 查询名字以 S 开头的用户<br>
	`select * from emp where ename like('S%');`
- 查询名字以 S 开头且倒数第二个字符为 T 的用户<br>
   `select * from emp where ename like('S%T_');`
- escape **自定义转义字符**<br>
  查询名字中带 % 的用户<br>
  `select * from emp where ename like ('%a%%') escape ('a') `<br>
  此时的 a 被定义为转义字符，等同于 Java 中的 '\'，'a%' 表示 '%' 这个符号，不再是通配符。
- 使用 like 时要注意，因为效率**比较低**。
- 使用 like 可以参考使用索引，但是要求不能以 % 开头，查询次数会爆炸。
  - 我现在要查询含有 “Java” 的文章。<br>
	如果使用 “%Java%”。<br>
	每篇文章程序都要从头读到尾进行匹配。<br>
	如果有一万篇文章，每篇一千字。<br>
	那么程序就要遍历整整一千万字。
- 涉及到大文本的检索的时候，可以使用某些框架。
  - luence
  - solr
  - elastic search
					  
### order by
- 进行排序操作
- 按照单个列排序<br>
  `select * from XXX where XXX order by col`
- 升序排序<br>
  `order by col (asc)`<br>
  默认情况下升序，asc 可省略。
- 降序排序<br>
  `order by col desc`
- 按照多个列排序（优先级）<br>
  `order by col1 desc(asc), col2 desc(asc)`<br>
  先根据 col1 进行排序，当有数据 col1 字段相等时，再根据 col2 进行排序。<br>
  不同字段可以使用不同的排序顺序。
- 排序按照自然顺序进行
	- 如果是数字，比较数值
	- 如果是字符串，比较字典序
- 每次在执行 order by 的时候是做了全排序，效率很低，需要耗费大量的内存。<br>
  如果数据量很大，慎用 order by 。<br>
  可以在凌晨进行 order by 的操作，因此此时服务器访问量很低。<br>
  以前很多网站凌晨关闭，其一个目的就是整理数据。

### 使用计算字段
当我们需要对数据进行**转换**、**计算**或**格式化**时，往往直接在数据库检索时就完成这些操作。<br>
而不是先检索出原始数据，然后在客户机应用程序中对数据进行操作。

比如数据库中存储了员工的月薪，现在需要检索年薪。<br>
那么我们会直接在检索时就完成月薪 \*12 的操作。<br>
而不是先检索拿到月薪，然后在应用程序中完成 \*12 。

- 计算字段并不实际存在于数据库表，而是临时数据。
- Sql 允许 select 子句中出现 + , - , \* , / 以及列名和常数的表达式
- 拼接字段  \|\| ,  concat()
	- 拼接字符串
	- `select 'my name is ' || ename from emp;`等价于<br>
	  `select concat('my name is ',ename) from emp;`<br>
	  结果
	  ```
		'MYNAMEIS'||ENAME
		---------------------
		my name is SMITH
		my name is ALLEN
		my name is WARD
		my name is JONES
		my name is MARTIN
	  ```
	- 首选 \|\| ( mysql 中 \|\| 表示 or ，一般用 concat() )
- 数学计算
	- 通过月薪计算年薪。
	  `select ename , sal*12 as "年薪" from emp;`
	- 做数学计算时一定要注意，100 + null 的结果是 **null**

## 通用函数 nvl
Sql 中允许列值为空，空值用保留字 NULL 表示。<br>
NULL 丌同与 0 或者空格，它就是代表了一个丌确定的内容。<br>
任何含有 null 值的数学表达式最后的结果都为空值。

当进行数学计算时，我们希望能够把 null 视为 0 。<br>
此时就需要使用 nvl 函数。

nvl ( arg1 , arg2 ) 
- 如果 arg1 为 null ，返回 arg2 。
- 如果 arg1 不为 null，返回 arg1 。

现有该语句：<br>
`select ename , (sal+comm) * 12 as "annual salary" from emp;`<br>
ename 是员工名字，sal 是月薪，comm 是月度津贴，现需要计算年薪。<br>
但是因为有部分员工的 comm 是 null，所以计算结果如下：
```
ENAME              年薪
---------- ----------
SMITH      
ALLEN           22800
WARD            21000
JONES      
MARTIN          31800
BLAKE      
```
此时我们想要将 null 视为 0 。<br>
`select ename , (sal + nvl(comm ,0)) * 12 as "annual salary" from emp;`<br>
结果正常
```
ENAME      annual salary
---------- -------------
SMITH               9600
ALLEN              22800
WARD               21000
JONES              35700
MARTIN             31800
```

### 并集，全集，交集，差集
- 并集
	将两个集合中的所有数据都进行显示，**去重**
	```
	select * from emp where deptno =30 union
	select * from emp where sal >1000;
	```
- 全集
	将两个集合的数据全部显示，**不去重**
	```
	select * from emp where deptno =30 union all
	select * from emp where sal >1000;
	```
- 交集
	两个集合中交叉的数据集，只显示一次
	```
	select * from emp where deptno =30 intersect 
	select * from emp where sal >1000;
	```
- 差集
	包含在A集合而不包含在B集合中的数据，跟A和B的集合顺序相关
	```
	select * from emp where deptno =30 minus 
	select * from emp where sal >1000;
	```



## 注意
SQL 中关系运算符的优先级：not > and > or<br>
当在同一条语句中使用不同的运算符时，最好用 () 括起来。<br>
保证语句的执行顺序，减少出错概率。

SQL 中的单行注释为 --

## SQL 优化问题
- AND: 把检索结果较少的条件放到后面
- OR: 把检索结果较多的条件放到后面

## SQL 函数
函数一般是在数据上执行的，它给数据的转换和处理提供了方便。<br>
函数只是将取出的数据进行处理，不会改变数据库中的值。<br>
![enter description here](/images/posts/oracle/function/function.png)

Sql函数可以分为组函数和单行函数。
- 组函数又被称作聚合函数，用于对**多行数据**进行操作，并返回一个**单一**的结果<br>
    组函数仅可用于**选择列表**或查询的 **having** 子句
- 单行函数对**单个数值**进行操作，并返回一个值。
![enter description here](/images/posts/oracle/function/functiontype.png)

### oracle 函数大全
[oralce 函数大全](https://github.com/kekaiyuan/resource/blob/main/API/oracle%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8.chm)


### 单行函数
#### 分类
![enter description here](/images/posts/oracle/function/singlefunction.png)

在oracle中存在数值的隐式转换和显式转换
     
隐式转换指的是字符串可以转换为数值或者日期

而显式转换则是使用 oracle 的转换函数



#### 单行函数的嵌套
- 单行函数可被嵌入到任何层
- 嵌套函数从最深层到最低层求值
![enter description here](/images/posts/oracle/function/nest.png)

### 组函数
组函数基于多行数据返回单个值

#### 常用的组函数
- avg()<br>
    返回某列的平均值
- min()<br>
    返回某列的最小值
- max()<br>
    返回某列的最大值
- sum()<br>
    返回某列值的和
- count()<br>
    返回某列的行数
	
#### 用法
- AVG and SUM 适用于**数字**类型数据
- MIN and MAX 适用亍**任何**数据类型
- COUNT 返回某列的行数，默认统计所有行，如果需要统计不重复的行，使用 distinct 关键字<br>
    `select count(distinct deptno) from emp;`
- COUNT 一般用来获取表中的记录条数，获取条数的时候可以使用 \* 或者某一个具体的列<br>
   甚至可以使用纯数字来代替，但是从运行效率的角度考虑，建议使用数字或者某一个具体的列，而不要使用 *
	- ~~count ( * )~~
	- count (1)
	- count (arg)<br>
		最好使用主键的列名，因为 count 会跳过空值，而主键是非空的。
- 组函数一律**跳过空值**，如果需要将空值代入计算，使用 NVL 函数。

	
#### 数据分组
组函数处理的是 “一组数据”，如果没有分组操作的话，组函数处理的是整张表。<br>
例如`select avg(sal) from emp;`输出是整张表的所有 sal 的平均值。

但加入分组操作后<br>
`select avg(sal) from emp group by deptno;`<br>
该语句会将 deptno 相同的行归为一组，然后分别求每个组的 sal 的平均值。

##### 步骤
```
SELECT column, group_function
FROM table
[WHERE condition] 
[GROUP BY group_by_expression] 
[ORDER BY column];
[having condition]
```
使用 group by 子句将表分成小组<br>
结果集**隐式**按**降序**排列，如果需要改变排序方式可以使用 order by 子句




- **创建分组**
	- group by 子句。
		- `group by arg1`<br>
			按照 arg1 进行分组，arg1 相同的为一组
	- group by 子句可以包含任意数目的列。
		- `group by arg1 , arg2`<br>
			按照 arg1 和 arg2 进行分组，arg1 相同并且 arg2 也相同的为一组
		-  除组函数语句外，select 语句中的每个列都必须在 group by 子句中给出。
	- 如果分组列中具有 null 值，则 null 将作为一个分组返回。如果列中有多行 null 值，他们将分为一组。 
	- group by 子句必须出现在 where 子句之后，order by 子句之前。 
- **过滤分组**（ having 子句) 
	- where 过滤行，having 过滤分组。 
	- having 支持所有 where 操作符。
- **分组和排序**
	- 一般在使用 group by 子句时，应该也给出 order by 子句。


##### 注意
- **出现在 select 列表中的字段，如果出现的位置不是在组函数中，那么必须出现在 group by 子句中**
	- `select deptno,avg(sal) from emp group by deptno`<br>
		该语句合法，select 列表中有两个字段：deptno 和 sal
			- deptno 字段出现在 group by 子句中
			- sal 出现在组函数 avg() 中
	- `select deptno,avg(sal),ename from emp group by deptno`<br>
		该语句不合法，无法执行。
		因为 ename 字段即不存在于 group by 子句中，也不存在于组函数中。
- **group by 列可以不在 select 列表中**
	- `select avg(sal) from emp group by deptno`<br>
		group by 子句中的 deptno 不在 select 列表中
- **不能在 where 子句中使用组函数。不能在 where 子句中限制组。使用 having 对分组进行限制。**
	- where 子句只能使用表中存在的数据。<br>
		组函数只是将取出的数据进行了一系列的处理，但是并没有写回数据库，所以 where 子句无法使用。<br>
		如果需要将组函数处理的结果作为判断依据，使用 having 子句。
	- 例如现在有语句`select avg(sal) from emp group by deptno;`<br>
		想要输出 avg(sal) > 1000 的分组
		- `select avg(sal) from emp group by deptno where avg(sal) > 1000`<br>
			该语句错误，where 子句无法使用组函数处理的结果
		- `select avg(sal) from emp group by deptno having avg(sal) > 1000`<br>
			该语句正确，使用 having 子句对分组进行限制。
	- where 子句和 having 子句都可用于执行判断操作。
		- where 子句只能使用表中存在的属性，而不能使用组函数。
		- having 子句可以使用组函数。
- **组函数仅在 _选择列表_ 和 _having_ 子句中有效。**

## select 子句顺序

| 子句     | 说明               | 是否必须使用           |
| -------- | ------------------ | ---------------------- |
| select   | 要返回的列或表达式 | 是                     |
| from     | 从中检索数据的表   | 仅在从表选择数据时使用 |
| where    | 行级过滤           | 否                     |
| group by | 分组说明           | 仅在按组计算聚集时使用 |
| having   | 组级过滤           | 否                     |
| order by | 输出排序顺序       | 否                     |

**Sql语句执行过程：**
1. 读取 **from** 子句中的基本表、视图的数据，\[执行笛卡尔积操作\]。
2. 选取满足 **where** 子句中给出的条件表达式的元组
3. 按 **group** 子句中指定列的值分组，同时提取满足 **having** 子句中组条件表达式的那些组
4. 按 **select** 子句中给出的列名戒列表达式求值输出
5. **order by** 子句对输出的目标表进行排序。