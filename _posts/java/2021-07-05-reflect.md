---
layout: post
title: Java 之——反射
categories: Java
description: Java 之——反射
keywords: Java, 反射
---

反射是 Java 最强大的技术之一，非常重要。

## 概述
JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；<br>
对于任意一个对象，都能够调用它的任意一个方法和属性；<br>
这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

要想解剖一个类,必须先要获取到该类的字节码文件对象。<br>
而解剖使用的就是Class类中的方法。<br>
所以先要获取到每一个字节码文件对应的Class类型的对象。


## 获取 Class 对象
1. 通过**完整路径**，**不导包**。<br>
	```java
	Class class1 = Class.forName("com.kky.entity.Emp");
	```
2. 通过**类名**，**导包**。<br>
	```java
	Class<Emp> class2 = Emp.class;
	```
3. 通过**对象**，**导包**，该方式需要创建对象**占用内存**，**不推荐**。<br>
	```java
	Class<? extends Emp> class3 = new Emp().getClass();
	```
4. 如果是基本数据类型，有两种方式
	1. 基本数据类型.class
		```java
		Class<Integer> class4 = int.class;
		```
	2. 包装类.Type
		```java
		Class<Integer> class5 = Integer.TYPE;
		```

## 通过 Class 对象获取

studentClass.getField();

获取成员变量


获取构造方法
- getDeclaredConstructor(类\<?>... parameterTypes) <br>
	返回值：Constructor\<T><br>
	查找带有指定形参表的构造方法
- getDeclaredConstructors() <br><br>
	返回值：Constructor\<?>[]
	查找返回所有的构造方法<br>
- 构造方法无法继承，所以无法查找父类的构造方法

| 方法 | 返回值 | 描述 | 是否包括父类 |
| ---- | ---- | ---- | ---- |
| getDeclaredConstructor(Class\<?>... parameterTypes) | Constructor\<T> | 查找指定名称的属性 | 是 |
| getDeclaredConstructors() | Field[] | 查找所有的属性 | 是 |


获取属性

| 方法 | 返回值 | 描述 | 是否包括父类 |
| ---- | ---- | ---- | ---- |
| getField(String name) | Field | 查找指定名称的属性 | 是 |
| getFields() | Field[] | 查找所有的属性 | 是 |
| getDeclaredField(String name)  | Field | 查找指定名称的属性 | 否 |
| getDeclaredFields() | Field[] | 查找所有的属性 | 否 | 


| 方法 | 返回值 | 描述 | 是否包括父类 |
| ---- | ---- | ---- | ---- |
| getMethod(String name, Class\<?>... parameterTypes)  | Method | 查找指定名称和参数列表的方法 | 是 |
| getMethods()  | Method[] | 查找所有的方法 | 是 |
| getDeclaredMethod(String name, Class\<?>... parameterTypes)  | Method | 查找指定名称和参数列表的方法 | 否 |
| getDeclaredMethods()  | Method[] | 查找所有的方法 | 否 |


- getField(String name) <br>
	返回值：Field<br>
	查找指定名称的属性，包括父类中的。
- getFields() <br>
	返回值：


| 返回值 | 方法和描述 |
| ---- | ---- |
| Constructor<T> | getDeclaredConstructor <br>(类<?>... parameterTypes)返回一个 Constructor对象，该对象反映 Constructor对象表示的类或接口的指定 类函数。 |
| Constructor<?>[] | getDeclaredConstructors() <br>返回一个反映 Constructor对象表示的类声明的所有 Constructor对象的数组 类 。 |
| Field | getDeclaredField(String name) <br>返回一个 Field对象，它反映此表示的类或接口的指定已声明字段 类对象。 |
| Field[] | getDeclaredFields() <br>返回的数组 Field对象反映此表示的类或接口声明的所有字段 类对象。 |
| 方法 | getDeclaredMethod(String name, 类<?>... parameterTypes) <br>返回一个 方法对象，它反映此表示的类或接口的指定声明的方法 类对象。 |
| 方法[] | getDeclaredMethods() <br>返回包含一个数组 方法对象反射的类或接口的所有声明的方法，通过此表示 类对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法。 |



### 常用方法

获取**公共**成员变量，包括父类
```java
Field[] fields = studentClass.getFields();
```

结果
```java
public java.lang.String com.kky.reflect.Student.className
public java.lang.String com.kky.reflect.Person.name
public int com.kky.reflect.Person.age
```

获取**所有**的成员变量，不包括父类
```java
Field address = studentClass.getDeclaredField("address");
Student student = studentClass.newInstance();
System.out.println(student.getAddress());
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```

写无参构造方法，某些框架的底层原理包含反射	
	
## 反射如何破坏封装性
```java
public class Student {
    private String address;

    public Student() {
        super();
    }

    private Student(String className) {
        this.className = className;
    }

    private void add(int a, int b) {
        System.out.println(a + b);
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", className='" + className + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}
```
	
## 源码链接
该文章源码链接 [Github](url)