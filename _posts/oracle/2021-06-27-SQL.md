---
layout: post
title: SQL 语言
categories: SQL
description: SQL 语言
keywords: SQL
---

SQL 语言

SQL 语言指的是结构化查询语言 (Structured Query Language)，具有定义、查询、更新和控制等多种功能，是关系数据库的标准语言。

SQL分类：
- DML 
	- Data Manipulation Language 数据操纵语言
	- 针对**数据**
	- 关键字
		- SELECT 
		- INSERT 
		- UPDATE 
		- DELETE
- DDL
	- Data definition language 数据定义语言 
	- 针对**表**
	- 关键字
		- CREATE 
		- ALTER 
		- DROP 
		- RENAME 
- DCL 
	- Data Control Language 数据控制语言
	- **权限、事务**
	- 关键字
		- GRANT 
		- REVOKE
- Transaction
	- commit 
	- rollback 
	- savepoint
	
## 查看表
- `Select * from tab;`<br>
	查看用户下的所有表
- `Select * from user_tables;`<br>
	详细查询当前用户下的所有表
- `desc 表名;` 或 `describe dept;`<br>
	查看表结构
- `select table_name from user_tables; `<br>
	查看所有表
- `comment on table emp is ‘雇员表';`<br>
	 为表添加注释
- `comment on column emp.Empno is '雇员工号';`<br>
	  为列添加注释

注释： --


▪ emp表雇员表(employee)
– Empno: 雇员工号 Ename: 雇员名字
– Job:工作。（秘书、销售、经理、分析员、保管）
– Mgr(manager):经理的工号 Hiredate:雇用日期
– Sal: 工资 Comm: 津贴 Deptno: 所属部门号
▪ dept表部门表（department） – Deptno:部门号 Dname:部门名字 Loc: 地址
▪ salgrade表一个公司是有等级制度，用此表表示一个工资的等级
▪ Grade:等级 losal:最低工资 hisal:最高工资
▪ bonus表 奖金表：表示一个雇员的工资及奖金。
– Ename:雇员名字， job:工作， 
– sal: 工资 comm:津贴
	
	
在 PL/SQL 中，有多种窗口。
但是某些语句只能在 Command Window 显示。
比如 desc emp
	
## SQL 语句
### SELECT 
- Select-from-where句型
	```
	SELECT [DISTINCT] {*,column alias,..}
	FROM table alias
	Where 条件表达式
	```
	- alias 指别名，我们可以更改表或列的名字，以方便我们操作
		- Column alias
		- Column "alias"
			- 当别名中带有空格时，必须使用引号
		- Column as alias
	- 检索单个列<br>
		  `select col from tableName;`
	- 检索多个列<br>
		  `select col1, col2,col3 from tableName;`
	- 检索所有列
		- `select * from tableName;`
		- \* 称为通配符
			- 优点<br>
				书写方便、可以检索未知列
			- 缺点<br>
				降低检索的性能
			- 当只检索固定列的数据时，不要使用 \* ，效率低
			- 表过大，越要避免使用 \* ，否则很容易卡死
	- 给检索出的列起个别名
		- `select job "gong zuo" from emp;`
		- `select job as "gong zuo" from emp;`
	- 表别名
		- `Select e.* from emp e;`
		- `Select e.empno,e.deptno from emp e;`
	- distinct
		- 可将检索结果去重。
		- 当检索多个列，有一个字段不一样都不会被去重。


#### where
- where 后面跟的是条件表达式
- 条件比较


##### ＝ , !＝ , <> , < , > , <= , >= , any , some , all
- != 和 <> 都表示不等于
- any , some , all 后面跟的是一堆数值
	- any 取其中任意一个<br>
	  `select sal from emp where sal > any(1000 , 1500 , 3000);`<br>
	  sal 只要大于 1000,1500,3000 中任意一个值即可。<br>
	  可以将 any 理解为**最小值**
	- some 和 any 一样，取**最小值**<br>
	  `select sal from emp where sal > some(1000 , 1500 , 3000);`
	- all 表示所有，即**最大值**<br>
	  `select sal from emp where sal > some(1000 , 1500 , 3000);`<br>
	  检索大于 3000 的 sal
	  
##### is null , is not null
- 在 SQL 语法中， null 表示一个特殊的含义，不能使用 = 和 != 进行比较
- 判断某字段是否为空，必须使用 is null 或 is not null


##### between x and y
- 找到**大于等于** x 的值和**小于等于** y 的值
- 包含 x 和 y 的值
- 以下语句等价
	- `select sal from emp where sal between 1500 and 3000;`
	- `select sal from emp where sal >= 1500 and sal <= 3000;`


##### in（list）, not in（list） 
- 需要进行某些值的等值判断的时候使用
- in 和 not in 会从后面的 list 列表中逐一比对
- `select * from emp where deptno in (10,20);`等价于<br>
   `select * from emp where deptno = 10 or deptno = 20;`
- `select * from emp where deptno not in (10,20);`等价于<br>
   `select * from emp where deptno != 10 or deptno != 20;`
   
   
##### exists（sub－query） 
- 相关子查询
- 现在要查询部门编号为10和20的员工，要求使用exists实现
	- 在 SQL 中，select 等同于一次循环，使用相关子查询等于使用双重循环
	- 在相关子查询中，要将外层循环和内层循环联系到一起，否则容易输出整张表
	- ```
		select *
			from emp e
			where exists (select deptno
							from dept d
							where (d.deptno = 10 or d.deptno = 20)
							and e.deptno = d.deptno)
	   ```
	- 同时使用 or 和 and，要用 () 把 or 语句括起来保证执行顺序。  


##### like , escape 
- **模糊查询**
- 在 like 的语句中，需要使用占位符或通配符
	- _ 占位符，可替换为**一个**任意字符
	- % 通配符，可替换为**无数个**任意字符
	- 不能过度使用通配符。如果其他操作符能达到目的，就不要使用通配符。
	- 确实需要使用通配符时，除非绝对必要，否则不要把通配符用到搜索模式最开始处，因为这样搜索起来是最慢的。
- 查询名字以 S 开头的用户<br>
	`select * from emp where ename like('S%');`
- 查询名字以 S 开头且倒数第二个字符为 T 的用户<br>
   `select * from emp where ename like('S%T_');`
- escape **自定义转义字符**<br>
  查询名字中带 % 的用户<br>
  `select * from emp where ename like ('%a%%') escape ('a') `<br>
  此时的 a 被定义为转义字符，等同于 Java 中的 '\'，'a%' 表示 '%' 这个符号，不再是通配符。
- 使用 like 时要注意，因为效率**比较低**。
- 使用 like 可以参考使用索引，但是要求不能以 % 开头，查询次数会爆炸。
  - 我现在要查询含有 “Java” 的文章。<br>
	如果使用 “%Java%”。<br>
	每篇文章程序都要从头读到尾进行匹配。<br>
	如果有一万篇文章，每篇一千字。<br>
	那么程序就要遍历整整一千万字。
- 涉及到大文本的检索的时候，可以使用某些框架。
  - luence
  - solr
  - elastic search
					  
#### order by
- 进行排序操作
- 按照单个列排序<br>
  `order by col`
- 升序排序<br>
  `order by col (asc)`<br>
  默认情况下升序，asc 可省略。
- 降序排序<br>
  `order by col desc`
- 按照多个列排序（优先级）<br>
  `order by col1 desc(asc), col2 desc(asc)`<br>
  先根据 col1 进行排序，当有数据 col1 字段相等时，再根据 col2 进行排序。<br>
  不同字段可以使用不同的排序顺序。
- 排序按照自然顺序进行
	- 如果是数字，比较数值
	- 如果是字符串，比较字典序
- 每次在执行 order by 的时候是做了全排序，效率很低，需要耗费大量的内存。<br>
  如果数据量很大，慎用 order by 。<br>
  可以在凌晨进行 order by 的操作，因此此时服务器访问量很低。<br>
  以前很多网站凌晨关闭，其一个目的就是整理数据。

## 注意
SQL 中关系运算符的优先级：not > and > or
当在同一条语句中使用不同的运算符时，最好用 () 括起来。
保证语句的执行顺序，减少出错概率。

## SQL 优化问题
- AND: 把检索结果较少的条件放到后面
- OR: 把检索结果较多的条件放到后面

## 源码链接
该文章源码链接 [Github](url)