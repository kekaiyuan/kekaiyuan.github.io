---
layout: post
title: Java 多线程与高并发之—— 各种锁
categories: Java 
description: some word here
keywords: Java 
mermaid: true
---

介绍 Java 中除了 synchronized 之外一些功能各异的锁。

# ReentrantLock 的优点
## 可响应外部消息
synchronized 在执行的时候是无法响应外部消息，所以如果某个线程在获得锁后陷入了死循环，那么所有其他线程都会被阻塞。

```java
public static void main(String[] args) throws InterruptedException {
        {
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    synchronized (this) {
                        System.out.println(Thread.currentThread().getName() + " start");
                        try {
                            Thread.sleep(Integer.MAX_VALUE);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            };
            new Thread(runnable, "t1").start();
            new Thread(runnable, "t2").start();
        }
    }
```
结果
```java
t1 start
```
因为 t1 拿到了锁以后进行了无限期的睡眠，所以 t2 永远拿不到锁。

但是 ReentrantLock 可以解决这个问题。

上锁时调用 lockInterruptibly() 方法，该方法会响应外部的 interrupt() 方法
```java
public static void main(String[] args) throws InterruptedException {
        Lock lock = new ReentrantLock();

        Thread t1 = new Thread(() -> {
            try {
                lock.lockInterruptibly();
                System.out.println("t1 start");
                Thread.sleep(Integer.MAX_VALUE);
                System.out.println("t1 end");
            } catch (InterruptedException e) {
                System.out.println("t1 interrupted!");
            } finally {
                lock.unlock();
            }
        });
        t1.start();

        Thread t2 = new Thread(() -> {
            try {
                lock.lockInterruptibly();
                System.out.println("t2 start");
                Thread.sleep(Integer.MAX_VALUE);
                System.out.println("t2 end");
            } catch (InterruptedException e) {
                System.out.println("t2 interrupted!");
            } finally {
                lock.unlock();
            }
        });
        t2.start();

        Thread.sleep(5000);

        t1.interrupt(); //打断线程 1 的等待
		
		Thread.sleep(5000);

        t2.interrupt(); //打断线程 2 的等待
    }
}
```
结果
```java
t1 start
t1 interrupted!
t2 start
t2 interrupted!
```
该程序 t1 线程使用 `lockInterruptibly()` 方法上锁，然后陷入无限期的睡眠。
然后创建 t2 线程，因为 t1 线程不释放锁，所以 t2 线程无法运行。

在等待 5s 后，调用 `t1.interrupt();` 打断 t1 线程：
1. t1 线程会捕获到 InterruptedException 异常
2. t1 线程执行 catch 代码块，输出异常信息
3. t1 线程执行 finally 代码块，释放锁

于是 t2 线程拿到了锁，开始执行。

同样的，在 5s 后使用 `t2.interrupt();` 打断 t2 线程的运行。

```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```

# CyclicBarrier
先翻译一下类名：循环栅栏。<br>
通过类名来感受这个类的作用：
1. 现在有一个**栅栏**，把线程们的路拦住了。
2. 线程到达栅栏后会被**阻塞**，无法继续前行。
3. 当栅栏前等待的线程达到**一定数量**后，栅栏会打开，所有线程继续运行。
4. 栅栏重新开闭，开启新一轮的**循环**。

所以这个类用于同步线程的运行状态


案例：
```java
public class T07_TestCyclicBarrier {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(20, () -> {
            System.out.println("已满 20，发车！");
        });

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```
Cyclic 有两个构造方法：
1. CyclicBarrier(int parties)
2. CyclicBarrier(int parties, Runnable barrierAction)

即第一个参数是栅栏的**大小**——当等待线程的数量达到多少时开放栅栏。<br>
第二个参数可选——栅栏开启时是否需要执行某些操作。

在本案例中，共有 100 个线程，栅栏大小为 20 ，开启栅栏时会打印一句话：“已满 20，发车！”<br>
所以运行结果为：
```java
已满 20，发车！
已满 20，发车！
已满 20，发车！
已满 20，发车！
已满 20，发车！
```

CyclicBarrier 用于同步多个线程的执行流程：
- 即某线程不能独自往前推进，它必须等待其他线程的运行结果
- 使用方法：<br>
	在需要等待的地方调用 `barrier.await();`



循环栅栏
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
# Phaser
CyclicBarrier 是循环栅栏，只有一道栅栏，通过栅栏的线程不会再被阻塞。

但如果需要使用**多栅栏模式**，线程们会先在第一道栅栏前集合，再在第二部栅栏前集合……

从现实生活中考虑，集体活动是不是如此？<br>
现有一集体活动：
```mermaid
graph LR;
A[在某地点集合] --> B[吃饭]
B --> C[大保健]
C --> D[喝酒] 
D --> E[解散]
```
每个人都是一个线程，各自运行。<br>
但是所有人必须一起行动。<br>
不能发生其他人还在吃饭，有一个人已经所有事都做完回家的情况发生。

使用 Phaser 类实现该情景：
```java
public class T08_TestPhaser1 {
    static Phaser phaser = new PartyPhaser();
    static int num = 3;

    public static void main(String[] args) {
        //注册数量
        phaser.bulkRegister(num);

        for (int i = 1; i <= num; i++) {
            new Thread(new Person(), "p" + i).start();
        }

    }

    static class PartyPhaser extends Phaser {
        /*
        返回值 false 代表 phaser 未结束
        返回值 true 代表 phaser 结束
         */
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch (phase) {
                case 0:
                    System.out.println(num + " 人到齐，开饭！\n");
                    return false;
                case 1:
                    System.out.println(num + " 人吃完，去做大保健！\n");
                    return false;
                case 2:
                    System.out.println(num + " 人做完大保健，去喝酒！\n");
                    return false;
                case 3:
                    System.out.println(num + " 人喝完酒，聚会结束！\n");
                    return true;
                default:
                    return true;
            }
        }
    }

    static class Person implements Runnable {
        public void arrive() {
            System.out.println(Thread.currentThread().getName() + " 到达现场！");
            phaser.arriveAndAwaitAdvance();
        }

        public void eat() {
            System.out.println(Thread.currentThread().getName() + " 吃完了！");
            phaser.arriveAndAwaitAdvance();
        }

        public void massage() {
            System.out.println(Thread.currentThread().getName() + " 做完大保健！");
            phaser.arriveAndAwaitAdvance();
        }

        public void drink() {
            System.out.println(Thread.currentThread().getName() + " 喝完了！");
            phaser.arriveAndAwaitAdvance();
        }

        @Override
        public void run() {
            arrive();
            eat();
            massage();
            drink();
        }
    }
}
```
关键：
1. 继承 Phaser 类，重写 onAdvance() 方法，该方法代表当所有人都到达某一阶段时应该采取的行动。<br>
	注意：
	- 在最后一个阶段前，返回值必须为 false ，代表流程还未结束。
	- 如果某阶段的返回值为 true ，在该阶段后，所有线程将各自运行，不再同步。
2. 每个线程完成阶段任务后，调用 `phaser.arriveAndAwaitAdvance();` 方法，表示<br>
	该线程已经完成任务，并且在等待其他线程完成任务。
3. 使用 `phaser.bulkRegister(num);` 设置注册数量，即栅栏大小。

结果：
```java
p1 到达现场！
p2 到达现场！
p3 到达现场！
3 人到齐，开饭！

p1 吃完了！
p3 吃完了！
p2 吃完了！
3 人吃完，去做大保健！

p2 做完大保健！
p3 做完大保健！
p1 做完大保健！
3 人做完大保健，去喝酒！

p1 喝完了！
p3 喝完了！
p2 喝完了！
3 人喝完酒，聚会结束！
```


----------

一个小拓展：<br>
在做大保健的时候，突然有人加入进来，并且在做完大保健后离开，如何实现？

关键：<br>
- `phaser.register()` 方法<br>
	注册数量 + 1 。
- `phaser.arriveAndAwaitAdvance()` 方法<br>
	注册数量 - 1 。
- 为了使新加入的人直接开始做大保健，而跳过集合和吃饭环节。<br>
	加入了 stage 变量，代表已经进行到哪个阶段的活动	

代码
```java
public class T09_TestPhaser2 {
    static Phaser phaser = new PartyPhaser();
    static int num = 3;

    public static void main(String[] args) {
        phaser.bulkRegister(num);

        for (int i = 1; i <= num; i++) {
            new Thread(new Person(), "p" + i).start();
        }

    }

    static class PartyPhaser extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {
            switch (phase) {
                case 0:
                    System.out.println(num + " 人到齐，开饭！\n");
                    return false;
                case 1:
                    System.out.println(num + " 人吃完，去做大保健！");
                    num++;
                    System.out.println("p" + num + " 也要去做大保健！\n");
                    return false;
                case 2:
                    System.out.println(num + " 人做完大保健，去喝酒！");
                    System.out.println("p" + num + " 不去喝酒！\n");
                    num--;
                    return false;
                case 3:
                    System.out.println(num + " 人喝完酒，解散！\n");
                    return true;
                default:
                    return true;
            }
        }
    }

    static class Person implements Runnable {
        int stage = 0;

        public Person() {
        }

        public Person(int stage) {
            this.stage = stage;
        }

        public void arrive() {
            System.out.println(Thread.currentThread().getName() + " 到达现场！");
            phaser.arriveAndAwaitAdvance();
        }

        public void eat() {
            System.out.println(Thread.currentThread().getName() + " 吃完了！");
            phaser.arriveAndAwaitAdvance();
        }

        public void massage() {
            System.out.println(Thread.currentThread().getName() + " 做完大保健！");
            if (phaser.getRegisteredParties() < num) {
                phaser.register();
                new Thread(new Person(2), "p" + num).start();
            }
            phaser.arriveAndAwaitAdvance();
        }

        public void drink() {
            if (Thread.currentThread().getName().equals("p" + (num + 1))) {
                phaser.arriveAndDeregister();
            } else {
                System.out.println(Thread.currentThread().getName() + " 在喝酒！");
                phaser.arriveAndAwaitAdvance();
            }
        }

        @Override
        public void run() {
            switch (stage) {
                case 0:
                    arrive();
                case 1:
                    eat();
                case 2:
                    massage();
                case 3:
                    drink();
            }
        }
    }
}
```
```java
p1 到达现场！
p3 到达现场！
p2 到达现场！
3 人到齐，开饭！

p3 吃完了！
p1 吃完了！
p2 吃完了！
3 人吃完，去做大保健！
p4 也要去做大保健！

p2 做完大保健！
p1 做完大保健！
p3 做完大保健！
p4 做完大保健！
4 人做完大保健，去喝酒！
p4 不去喝酒！

p2 在喝酒！
p1 在喝酒！
p3 在喝酒！
3 人喝完酒，解散！
```

# Semaphore
Semaphore 类可用于控制**最多**有多少个线程可**同时运行**。

Semaphore 类可用于限流。

举个栗子：
某超市有 5 个收银台。
- 如果有 20 人等待结账，同一时刻只有 5 个人正在结账。
- 如果有 100 人等待结账，同一时刻也只有 5 个人正在结账。

如何使用？
- 创建 Semaphore 对象，在创建时指定同时运行的线程的**最大数量**。
- 使用 acquire() 方法申请锁
- 使用 release() 方法释放锁（请将该方法写入 finally 代码块，确保锁的释放）

案例：
```java
public class T11_TestSemaphore {
    public static void main(String[] args) {
        //可控制同时最多有几个线程运行
        Semaphore s = new Semaphore(1);

        for (int i = 0; i < 4; i++) {
            new Thread(() -> {
                try {
                    s.acquire();
                    System.out.println(Thread.currentThread().getName() + " running");
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    System.out.println(Thread.currentThread().getName() + " end");
                    s.release();
                }
            }, "T" + i).start();
        }
    }
}
```
该程序限制最大同时运行线程数为 1 。

结果：
```java
T0 running
T0 end
T2 running
T2 end
T1 running
T1 end
T3 running
T3 end
```
在一个线程结束前，没有线程可以运行。

尝试修改最大同时运行线程数为 4 。
```java
……（其他代码不变）
Semaphore s = new Semaphore(4);
……（其他代码不变）
```
结果
```java
T0 running
T3 running
T2 running
T1 running
T3 end
T1 end
T0 end
T2 end
```
可以看到，同一时刻有 4 个线程在运行。

Semaphore 共有两个构造方法：
- Semaphore(int permits) <br>
	Creates a Semaphore with the given number of permits and **nonfair** fairness setting.
- Semaphore(int permits, boolean fair) <br>
	Creates a Semaphore with the given number of permits and the given fairness setting.

即 Semaphore 默认是**非公平**的：<br>
创建一个新线程后，它会试图直接去拿锁，拿不到后才会进入等待队列。<br>
即会发生后面来的线程比前面来的线程先拿到锁的情况，即**插队**。

之前 `Semaphore s = new Semaphore(1);` 的例子的结果：
```java
T0 running
T0 end
T2 running
T2 end
T1 running
T1 end
T3 running
T3 end
```
T2 线程比 T1 线程先抢到了锁。

如果指定 Semaphore 为**公平**的：<br>
无论现在锁是什么状态，我直接进入队列中进行排队等待。<br>
即**先进先出**（FIFO）。
```java
……（其他代码不变）
Semaphore s = new Semaphore(1, true);
……（其他代码不变）
```
结果
```java
T0 running
T0 end
T1 running
T1 end
T2 running
T2 end
T3 running
T3 end
```
满足线程创建的顺序。

# Exchanger
Exchanger 是一个用于交换线程信息的类。

如何使用？
- 创建一个 Exchanger 对象。
- 调用 exchange(Object o) 方法交换数据。 

案例
```java
public class T12_TestExchanger {

    static Exchanger<String> exchanger = new Exchanger<>();

    public static void main(String[] args) {
        new Thread(new TestRunnable("a"), "A").start();
        new Thread(new TestRunnable("b"), "B").start();
    }

    static class TestRunnable implements Runnable {
        String message = null;

        public TestRunnable(String message) {
            this.message = message;
        }

        @Override
        public void run() {
            try {
                message = exchanger.exchange(message);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " " + message);
        }
    }
}
```
结果
```java
A b
B a
```

**注意：**<br>
当某线程调用了 exchange(Object o) 方法后，在另一个线程也调用该方法交换数据前。<br>
该线程会一直**阻塞**。


```java
```
```java
```
```java
```
```java
```
```java
```


# 源码链接
该文章源码链接 [Github](url)