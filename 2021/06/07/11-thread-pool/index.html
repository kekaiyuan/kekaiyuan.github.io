<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java 学习笔记之 11 —— 线程池 &mdash; 菜鸟日记</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://kekaiyuan.github.io//2021/06/07/11-thread-pool/"><link rel="alternate" type="application/atom+xml" title="菜鸟日记" href="https://kekaiyuan.github.io//feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/favicon.ico"><meta property="og:title" content="Java 学习笔记之 11 —— 线程池"><meta name="keywords" content="Java"><meta name="og:keywords" content="Java"><meta name="description" content="序言在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。"><meta name="og:description" content="序言在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。"><meta property="og:url" content="https://kekaiyuan.github.io//2021/06/07/11-thread-pool/"><meta property="og:site_name" content="菜鸟日记"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-06-07"> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://kekaiyuan.github.io//" title="菜鸟日记"><span class="octicon octicon-mark-github"></span> 菜鸟日记</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://kekaiyuan.github.io//" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://kekaiyuan.github.io//categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://kekaiyuan.github.io//archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://kekaiyuan.github.io//wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://kekaiyuan.github.io//links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://kekaiyuan.github.io//about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java 学习笔记之 11 —"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java 学习笔记之 11 —— 线程池</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/06/07 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://kekaiyuan.github.io//categories/#Java" title="Java">Java</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 3238 字，约 10 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/images/qrcode.jpg" alt="闷骚的程序员" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="序言">序言</h1><p>在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。</p><p>于是有了线程池的概念：<br /> 把所有线程都放到一个“池”中，当需要并发执行任务时，就从线程池中拿出一个线程使用。</p><ul><li>原来：<br /> 创建一个新的线程。</li><li>现在：<br /> 从线程池中取出一个线程。<br /> 使用完后将线程放回线程池中。</li></ul><p>线程主要有两个好处：</p><ol><li>使用线程池可以重复利用已有的线程继续执行任务，避免线程在创建和销毁时造成的消耗，提高系统响应速度。</li><li>通过线程池可以对线程进行合理的管理，避免许多问题。</li></ol><h1 id="线程池的创建">线程池的创建</h1><p>使用如下代码创建线程池：</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ThreadPoolExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(...);</span>
</code></pre></div></div><p>其构造方法有五个必选参数，两个可选参数。</p><table><thead><tr><th style="text-align: center">参数</th><th style="text-align: center">说明</th></tr></thead><tbody><tr><td style="text-align: center">corePoolSize</td><td style="text-align: center">核心线程池的大小</td></tr><tr><td style="text-align: center">maximumPoolSize</td><td style="text-align: center">线程池能创建线程的最大个数</td></tr><tr><td style="text-align: center">keepAliveTime</td><td style="text-align: center">空闲线程存活时间</td></tr><tr><td style="text-align: center">unit</td><td style="text-align: center">keepAliveTime 的时间单位</td></tr><tr><td style="text-align: center">workQueue</td><td style="text-align: center">保存任务的阻塞队列</td></tr><tr><td style="text-align: center">threadFactory</td><td style="text-align: center">创建线程的工厂类</td></tr><tr><td style="text-align: center">handler</td><td style="text-align: center">饱和策略（拒绝策略）</td></tr></tbody></table><p>简单解释一下七个参数：<br /> 线程池的概念很简单：<br /> 用一个“池子”存储所有的线程，当某任务需要线程时，从池中取出一个线程，任务执行结束后，将线程放回池子中。</p><ul><li>核心线程池<br /> 线程池线程数量的初始值。<br /> 这些线程是不会被销毁的，即使它们是空闲的。<ul><li>线程池刚创建时核心线程池为空，随着任务的增多而不断开辟线程。</li><li>如果设置了 <code class="language-plaintext highlighter-rouge">allowCoreThreadTimeOut=true</code>，那么核心线程池的线程会被超时销毁。</li><li>如果线程运行时发生异常，该线程会被销毁，并立刻创建一个新的线程替代。</li></ul></li><li>线程池的最大容量<br /> 当阻塞队列满了，此时如果又有新的任务，就需要创建新的线程为其服务。<br /> 无限制地创建线程会带来很严重的问题，所以应该设置一个上限。</li><li>空闲线程存活时间<br /> 核心线程池之外的线程在被创建后，如果一段时间内都为空闲状态，会被销毁。<br /> 当该时间设置为 0 时，则是无限期的。</li><li>存活时间的时间单位<br /> 毫秒、秒、分钟……</li><li>阻塞队列<br /> 当核心线程池已满，新的任务会被存入某个队列中等待空闲线程的调用。</li><li>threadFactory<br /> 可以使用 <a href="https://kekaiyuan.github.io//2021/06/04/factory/">工厂模式</a> 来创建线程。</li><li>饱和策略<br /> 当线程池达到最大容量时，使用某种策略处理新的任务。</li></ul><h1 id="工作原理">工作原理</h1><p><img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/java/javase/11-threadpool/theory2.png" alt="image" /></p><p>当有新的任务时：</p><ul><li>如果核心线程池<strong>未满</strong>，则直接开辟新线程。</li><li>如果核心线程池<strong>已满</strong>，放入阻塞队列等待空闲线程。</li><li>如果阻塞队列<strong>已满</strong>，直接开辟新线程。</li><li>如果线程池达到最大容量，则根据饱和策略处理新任务。</li></ul><h2 id="执行方法">执行方法</h2><p>启动线程使用的是 <code class="language-plaintext highlighter-rouge">start()</code> 方法。</p><p>而线程中启动线程用的是 <code class="language-plaintext highlighter-rouge">executor()</code> 和 <code class="language-plaintext highlighter-rouge">submit()</code></p><ul><li><code class="language-plaintext highlighter-rouge">executor()</code> 只能接受 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口</li><li><p><code class="language-plaintext highlighter-rouge">submit()</code> 能接受 <code class="language-plaintext highlighter-rouge">Runnable</code> 接口和 <code class="language-plaintext highlighter-rouge">Callable</code> 接口</p></li><li><code class="language-plaintext highlighter-rouge">Runnable</code> 接口的 <code class="language-plaintext highlighter-rouge">run()</code> 方法无返回值。</li><li><code class="language-plaintext highlighter-rouge">Callable</code> 接口的 <code class="language-plaintext highlighter-rouge">call()</code> 方法有返回值，可以通过 <code class="language-plaintext highlighter-rouge">Future</code> 对象获取返回值。</li></ul><h1 id="线程池的生命周期">线程池的生命周期</h1><p>线程池有两种状态，三种过渡状态</p><div class="mermaid"> graph LR; A(Running) --"shutdown()"--&gt; B1(SHUTDOWN); A --"shutdownNow()"--&gt; B2(STOP); B1 --"阻塞队列为空，线程池中的工作线程数量为 0"--&gt; C(TIDYING); B2 --"线程池中的工作线程数量为 0"--&gt; C; C --"terminated()"--&gt; D(TERMINATED);</div><table><thead><tr><th style="text-align: center">线程的生命周期</th><th style="text-align: left">说明</th></tr></thead><tbody><tr><td style="text-align: center">RUNNING</td><td style="text-align: left">能接受新提交的任务，并且也能处理阻塞队列中的任务</td></tr><tr><td style="text-align: center">SHUTDOWN</td><td style="text-align: left">关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td></tr><tr><td style="text-align: center">STOP</td><td style="text-align: left">不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</td></tr><tr><td style="text-align: center">TIDYING</td><td style="text-align: left">如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用terminated() 方法进入TERMINATED 状态。</td></tr><tr><td style="text-align: center">TERMINATED</td><td style="text-align: left">在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。</td></tr></tbody></table><h2 id="线程池的关闭">线程池的关闭</h2><ul><li><code class="language-plaintext highlighter-rouge">shutdown()</code><br /> 将线程池状态设为 SHUTDOWN，然后中断所有没有正在执行任务的线程。</li><li><code class="language-plaintext highlighter-rouge">shutdownNow()</code><br /> 将线程池状态设为 STOP，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表。</li></ul><h1 id="线程池的分类">线程池的分类</h1><p><img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/java/javase/11-threadpool/category.png" alt="image" /></p><ul><li>newCachedThreadPool<ul><li>线程池的大小不是固定的，最大可达到 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>。</li><li>线程池中的线程存活时间很短，只有 60 秒。</li><li>当线程池中没有可用线程时就创建新线程。</li></ul></li><li>newFixedThreadPool<ul><li>固定大小。</li><li>除非被显式关闭，否则池中的线程一直存在。</li><li>多余的线程将在 LinkedBlockingQueue 中等待。</li></ul></li><li>newSingleThreadExecutor<ul><li>只有一个工作线程。</li><li>LinkedBlockingQueue</li></ul></li><li>newScheduledThreadPool<ul><li>线程池中的线程数量有一个初始值。<br /> 任意时间都不会低于初始值，即使线程是空闲的。</li><li>可定时或延迟地执行线程活动。</li></ul></li><li>newWorkStealingPool<ul><li>创建一个带并行级别的线程池，并行级别决定了同一时刻最多有多少个线程在执行。<br /> 默认情况下并行级别为当前系统的 CPU 个数。</li></ul></li></ul><p>尽管 JDK 中定义了许多线程池，但还是建议使用</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ThreadPoolExecutor</span> <span class="n">executor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(...);</span>
</code></pre></div></div><p>手写参数来生成线程池，能够更好地理解该线程池的细节。</p><h1 id="阻塞队列">阻塞队列</h1><ul><li>ArrayBlockingQueue<ul><li>基于数组实现。<br /> 用一个定长数组维护队列中的数据对象。<br /> 还保存了两个整形变量标识着队列的头部和尾部在数组中的位置。</li><li>只有一个锁。<br /> 生产者和消费者无法真正并行运行。</li><li>在构造时也选择公平锁或非公平锁。</li></ul></li><li>LinkedBlockingQueue<ul><li>基于链表实现。</li><li>生产者一般不会被阻塞，除非队列已满（默认为 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>）。</li><li>生产者和消费者用的是两把锁，并发度更高。</li></ul></li><li>DelayQueue<ul><li>一般很特殊的队列，使用场景较少。</li><li>队列中的元素只有当其指定的延迟时间到了，才能被取出。</li><li>没有大小限制。<br /> 生产者永远不会被阻塞。<br /> 只有消费者会被阻塞。</li></ul></li><li>PriorityBlockingQueue<ul><li>基于优先级（通过构造函数传入的 Comparator 对象决定）的阻塞队列。</li><li>不会阻塞生产者，只会阻塞消费者。<br /> 所以要注意生产速度，否则会耗尽堆空间。</li><li>使用公平锁。</li></ul></li><li>SynchronousQueue<ul><li>与之前的阻塞队列不同，它没有缓冲区。<br /> 所以生产者和消费者很容易被阻塞（不能把数据丢进缓冲区就跑），必须找到对应的对象进行“交易”。</li><li>吞吐量会降低，但响应速度可以会变快。</li><li>公平模式：<ul><li>使用公平锁和 FIFO 队列维护生产者和消费者。</li></ul></li><li>非公平模式：<ul><li>使用非公平锁和 LIFO 队列维护生产者和消费者。</li><li>会发生“饿死”（某些生产者或消费者永远等不到处理）。</li></ul></li></ul></li><li>面试常问：ArrayBlockingQueue 和 LinkedBlockingQueue 的区别：<ul><li>ArrayBlockingQueue 的消费者和生产者共有同一个锁。<br /> LinkedBlockingQueue 的消费者和生产者使用分离锁。</li><li>ArrayBlockingQueue 必须指定大小（因为是数组）。<br /> LinkedBlockingQueue 可以不指定队列大小，默认下 <code class="language-plaintext highlighter-rouge">Integer.MAX_VALUE</code>。</li></ul></li></ul><h1 id="拒绝策略">拒绝策略</h1><ul><li>ThreadPoolExecutor.AbortPolicy<ul><li>丢弃任务并抛出RejectedExecutionException异常。</li></ul></li><li>ThreadPoolExecutor.DiscardPolicy<ul><li>丢弃任务，但是不抛出异常。</li></ul></li><li>ThreadPoolExecutor.DiscardOldestPolicy<ul><li>丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）.</li></ul></li><li>ThreadPoolExecutor.CallerRunsPolicy<ul><li>由调用线程处理该任务</li></ul></li></ul><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://kekaiyuan.github.io/" target="_blank">Kaiyuan Ke</a></li><li>本文链接：<a href="https://kekaiyuan.github.io//2021/06/07/11-thread-pool/" target="_blank">https://kekaiyuan.github.io//2021/06/07/11-thread-pool/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/06/07/11-thread-pool/', clientID: '', clientSecret: '', repo: '', owner: '', admin: [''], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:350px" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:16px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://kekaiyuan.github.io//assets/search_data.json?v=1646200237', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Kaiyuan Ke">Kaiyuan Ke</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/kekaiyuan/kekaiyuan.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://kekaiyuan.github.io//" title="首页" target="">首页</a></li><li> <a href="https://kekaiyuan.github.io//categories/" title="分类" target="">分类</a></li><li> <a href="https://kekaiyuan.github.io//archives/" title="归档" target="">归档</a></li><li> <a href="https://kekaiyuan.github.io//wiki/" title="维基" target="">维基</a></li><li> <a href="https://kekaiyuan.github.io//links/" title="链接" target="">链接</a></li><li> <a href="https://kekaiyuan.github.io//about/" title="关于" target="">关于</a></li><li><a href="https://kekaiyuan.github.io//feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script> {\% if page.mermaid \%} <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/7.1.0/mermaid.min.js"></script> <script> var config = { startOnLoad:true, flowchart:{ useMaxWidth:false, htmlLabels:true } }; mermaid.initialize(config); $(function(){ var elements = document.getElementsByClassName("language-mermaid"); for (var i = elements.length; i--;) { element = elements[i]; var graphDefinition = element.innerText; if (graphDefinition) { var svg = mermaid.render('ha_mermaid_' + i, graphDefinition, function(svg){}); if (svg) { var svgElement = document.createElement('div'); preNode = element.parentNode; svgElement.innerHTML = svg; svgElement.setAttribute('class', 'mermaid'); svgElement.setAttribute('data-processed', 'true'); preNode.parentNode.replaceChild(svgElement, preNode); } } } }); </script> {\% endif \%}<div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
