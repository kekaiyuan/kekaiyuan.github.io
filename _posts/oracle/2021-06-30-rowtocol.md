---
layout: post
title: Oracle 之——行转列
categories: [cate1, cate2]
description: Oracle 之——行转列
keywords: keyword1, keyword2
---

Oracle 之——行转列

在实际开发中，行转列是一个非常常用的技术点。

因为在存储了必要数据之后，数据库实际上越小越好，便于管理、成本低、备份快、查询快……

除了数据库中存储的表之外，我们有时更多地需要使用一些自定义的表。

此时就需要行转列。

## 例1：中国移动sql面试题
```
create table test(
   id number(10) primary key,
   type number(10) ,
   t_id number(10),
   value varchar2(5)
);
insert into test values(100,1,1,'张三');
insert into test values(200,2,1,'男');
insert into test values(300,3,1,'50');

insert into test values(101,1,2,'刘二');
insert into test values(201,2,2,'男');
insert into test values(301,3,2,'30');

insert into test values(102,1,3,'刘三');
insert into test values(202,2,3,'女');
insert into test values(302,3,3,'10');
请写出一条查询语句结果如下：

姓名      性别     年龄
--------- -------- ----
张三       男        50
```

该数据表：

 | ID | TYPE | T_ID | VALUE |
| ---- | -------- | ------ | ---------- |
 | 100 | 1 | 1 | 张三 |
 | 200 | 2 | 1 | 男 |
 | 300 | 3 | 1 | 50 |
 | 101 | 1 | 2 | 刘二 |
 | 201 | 2 | 2 | 男 |
 | 301 | 3 | 2 | 30 |
 | 102 | 1 | 3 | 刘三 |
 | 202 | 2 | 3 | 女 |
 | 302 | 3 | 3 | 10 |

需要生成的数据表：

| 姓名 | 性别 | 年龄 |
| ----- | ------ | ----- |
| 张三 | 男 | 50 |
| 刘二 | 男 | 30 |
| 刘三 | 女 | 10 |

解答：
1. 先**筛选**出需要的数据<br>
	```
	select decode(type, 1, value) as 姓名,
		   decode(type, 2, value) as 性别,
		   decode(type, 3, value) as 年龄
	  from test;
	```

	| 姓名 | 性别 | 年龄 |
	| ----- | ----- | ----- |
	| 张三 | | |
	| | 男 |
	| | | 50 |
	| 刘二 | | |
	| | 男 |
	| | | 30 |
	| 刘三 | | |
	| | 女 |
	| | | 10 |
	
2. 使用**聚合**函数完成**行转列**<br>
	```
	select max(decode(type, 1, value)) as 姓名,
		   max(decode(type, 2, value)) as 性别,
		   max(decode(type, 3, value)) as 年龄
	  from test group by T_ID;
	```

	| 姓名 | 性别 | 年龄 |
	| ----- | ------ | ----- |
	| 张三 | 男 | 50 |
	| 刘二 | 男 | 30 |
	| 刘三 | 女 | 10 |

## 例2
```
表内容：
2005-05-09 胜
2005-05-09 胜
2005-05-09 负
2005-05-09 负
2005-05-10 胜
2005-05-10 负
2005-05-10 负

如果要生成下列结果, 该如何写sql语句?

          胜 负
2005-05-09 2 2
2005-05-10 1 2
------------------------------------------
create table tmp(rq varchar2(10),shengfu varchar2(5));

insert into tmp values('2005-05-09','胜');
insert into tmp values('2005-05-09','胜');
insert into tmp values('2005-05-09','负');
insert into tmp values('2005-05-09','负');
insert into tmp values('2005-05-10','胜');
insert into tmp values('2005-05-10','负');
insert into tmp values('2005-05-10','负');
```

该表：

| RQ | SHENGFU |
| ---------- | ------- | 
| 2005-05-09 | 胜 |
| 2005-05-09 | 胜 |
| 2005-05-09 | 负 |
| 2005-05-09 | 负 |
| 2005-05-10 | 胜 |
| 2005-05-10 | 负 |
| 2005-05-10 | 负 |

解答：
1. 筛选<br>
	```
	select rq,
		   decode(shengfu, '胜', 1) as "胜",
		   decode(shengfu, '负', 1) as "负"
	  from tmp;
	```

	| RQ | 胜 | 负 |
	| ---- | --- | ---- |
	| 2005-05-09 | 1 |    |
	| 2005-05-09 | 1 |    |
	| 2005-05-09 |    | 1 |
	| 2005-05-09 |    | 1 |
	| 2005-05-10 | 1 |    |
	| 2005-05-10 |    | 1 |
	| 2005-05-10 |    | 1 |

```
select rq,
       sum(decode(shengfu, '胜', 1)) as "胜",
       sum(decode(shengfu, '负', 1)) as "负"
  from tmp
 group by rq
 order by rq;
```

| RQ | 胜 | 负 |
| ---------- | ---------- | ---------- |
| 2005-05-09 | 2 | 2 |
| 2005-05-10 | 1 | 2 |


## 源码链接
该文章源码链接 [](url)