---
layout: post
title: Mysql 之——索引
categories: [cate1, cate2]
description: Mysql 之——索引
keywords: keyword1, keyword2
mermaid: true
---

索引是任何数据库中都十分**重要**的一个技术点。

- 索引是帮助 MySQL 高效获取数据的数据结构。
- 索引存储在文件系统中，是持久化的数据，在使用时才加载到内存加快速度。
- 索引的文件存储形式与存储引擎有关。

索引是放在磁盘的，是持久化的数据。<br>
只是在使用的时候为了加快速度加载到内存。

## 索引文件的结构
从数据结构的层面上来说，以下四种数据结构都能作为索引文件的结构：
- hash
- 二叉树
- B树
- B+树

但是实际中，大多数索引都是使用 B+ 树的结构。

这是因为其他数据结构都存在着着或多或少的问题。

### Hash 表
- hash 表适用于等值查询，而业务中更多的是范围查询。
- hash 表在使用的时候需要把全部的数据加载到内存，比较耗费内存空间。

### 二叉树
#### 普通二叉树
普通的二叉树适用于二分查找，但是存在左右子树不平衡的情况。<br>
严重时二叉树会变成类似于链表的结构（只有左子树没有右子树或者只有右子树没有左子树）。<br>
![enter description here](/images/posts/database/mysql/index/binary-tree2.png)


#### AVL 树
AVL树是一颗严格意义上的平衡树，最高子树跟最低子树高度之差不能超过1。

但是为了维护 AVL 树的平衡，在进行元素插入时经常会需要进行 1 到 N 次的旋转，严重影响插入的性能。

![enter description here](/images/posts/database/mysql/index/avl-tree2.png)

#### 红黑树
红黑树是基于AVL树的一个升级，损失了部分查询的性能，来提升插入的性能。<br>
在红黑树中最低子树跟最高子树高度之差不超过 2 倍即可。<br>
在插入的时候，不需要进行 N 多次的旋转操作。<br>
而且还加入了变色的特性，来满足插入和查询性能的平衡。

![enter description here](/images/posts/database/mysql/index/red-black-tree2.png)

#### 总结
二叉树及其 N 多的变种都**不能**支撑索引。<br>
原因是树的深度无法控制或者插入数据的性能比较低。

### B树 聚簇索引
B树特点：
1. 所有键值分布在整颗树中。
2. 搜索有可能在非叶子结点结束，在关键字全集内做一次查找，性能逼近二分查找。
3. 每个节点最多拥有 m 个子树。
4. 根节点至少有 2 个子树。
5. 分支节点至少拥有 m/2 颗子树（除根节点和叶子节点外都是分支节点）。
6. 所有叶子节点都在同一层，每个节点最多可以有 m-1 个key，并且以升序排列。

![enter description here](/images/posts/database/mysql/index/b-tree2.png)

实例图说明：<br>
每个节点占用一个磁盘块，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。<br>
两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。<br>
以根节点为例，关键字为 16 和 34，P1 指针指向的子树的数据范围为小于 16，P2 指针指向的子树的数据范围为 16~34，P3 指针指向的子树的数据范围为大于 34。 <br>

查找关键字 28 过程：
1. 根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】
2. 比较关键字 28 在区间（16,34），找到磁盘块 1 的指针 P2。
3. 根据 P2 指针找到磁盘块 3，读入内存。【磁盘 I/O 操作第 2 次】
4. 比较关键字 28 在区间（25,31），找到磁盘块 3 的指针 P2。
5. 根据 P2 指针找到磁盘块 8，读入内存。【磁盘 I/O 操作第 3 次】
6. 在磁盘块 8 中的关键字列表中找到关键字 28。 


缺点：
每个节点不仅存储 key 值，还存储数据 data ，会造成以下的情况：
```mermaid
graph LR;
A[data 越大] --> B[key 数量越少]
B --> C[树越深]
C --> D[索引性能越差]
```

B 树的**节点的索引数量**和**总索引数量**是**指数级**的关系：
假设每个节点能够存储 9 个键值和 10 个指向子节点的指针。
第一层：9 个键值，10 个指针
第二层：99 个键值，100 个指针
第三层：999 个键值，1000 个指针
...

在这种数学关系的面前，多一个键值少一个键值都能带来巨大的数量变化。

所以提出了 B+ 树：**非叶子节点不存储数据**。

### B+ 树 非聚簇索引
B+Tree是在BTree的基础之上做的一种优化，变化如下：
1. B+Tree每个节点可以包含更多的节点，这个做的原因有两个，第一个原因是为了降低树的高度，第二个原因是将数据范围变为多个区间，区间越多，数据检索越快。
2. 非叶子节点存储key，叶子节点存储key和数据。
3. 叶子节点两两指针相互连接（符合磁盘的预读特性），顺序查询性能更高。

![enter description here](/images/posts/database/mysql/index/b-plus-tree.png)


非聚簇索引
给普通列建索引，先查到主键。
再去查主键索引，查到数据。
要查两颗B+树，回表


## 索引的分类
mysql索引的五种类型：主键索引、唯一索引、普通索引和全文索引、组合索引。<br>
通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力。
###  主键索引

主键是一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键。<br>
主键往往使用自动递增的方式，为了保证并发下主键不会发生冲突，有一个自增锁。<br>
当我 insert 10 条 sql 数据失败了回滚，但是自增锁依然往后递增了 10 次<br>
自动递增时索引更新的花费最低（直接插到最右边）。<br>
如果不是自动递增，当主键值在中间时，会引起多个磁盘块的更新。<br>
不仅会造成页分裂，还会造成每个页都不满

如果你没有为你的表定义 PRIMARY KEY，MySQL 会选择第一个只有 NOT NULL 列的 UNIQUE 索引作为主键，InnoDB 使用它作为聚集索引。<br>
如果表中没有这样的索引，InnoDB 会在内部生成一个聚集索引，其中的行按照 InnoDB 分配给此类表中行的 rowID 进行排序。<br>
行 ID 是一个 6 字节的字段，随着插入新行而单调增加。<br>
因此，按行 ID 排序的行在物理上是按插入顺序排列的。

###  唯一索引
索引列的所有值都只能出现一次，即必须唯一，值可以为空。

### 普通索引

基本的索引类型，值可以为空，没有唯一性的限制。（覆盖索引） <br>
覆盖索引<br>
select * from test where name = 'xxx' 要回表
select id from test where name = 'xxx' 不需要回表

mysiam 没有回表

### 全文索引，MyISAM支持，Innodb在5.6之后支持
全文索引的索引类型为FULLTEXT。全文索引可以在varchar、char、text类型的列上创建<br>
倒排索引

真正的全文索引一般不使用数据库实现，使用 Lucene，Solr，ElasticSearch 等全文检索引擎实现

### 组合索引

多列值组成一个索引，专门用于组合搜索（最左匹配原则）

id，name，age，address

如果使用 name 和 age 组合索引
最左匹配就是先匹配 name，name符合了再去匹配 age


----------


**组合索引的顺序非常重要**

加入现在需要建立两个索引： (name ,age) 和 (age) 

如果组合索引的顺序是先 name 再 age
那么还要单独建一个 age 的索引
就需要建立两颗索引树

如果组合索引的顺序是先 age 再 name
那么不需要再单独建 age 的索引
就只需要建立一颗索引树

----------

现在需要建立三个索引：(name ,age ) ,(name) ,(age)

有两种实现方案：
1. 建立 (name ,age) 和 (name) 两颗索引树
2. 建立 (age,name) 和 (age) 两颗索引树

哪种更好？

第二种方案更好。<br>
因为 age 字段是 int 类型，name 字段是字符串类型，age 字段所占据的空间更小。<br>
第一种方案是 name\*2 + age\*1 ，而第二种方案是 name + age\*2。<br>
第二种方案所占据的空间更小。


----------

### 索引下推
现在有这样一张表 test

| id | name | age | sex |
| :--: | :--: | :--: | :--: |
| 1 | zhangsan | 10 | man |
| 2 | zhangsan | 20 | man |
| 3 | zhangsan | 30 | man |
| 4 | zhangsan | 40 | man |

建立了联合索引 (name ,age)

现在要执行语句 `select * from test where name = 'zhangsan' and age = 10;`

在 Mysql 5.6 之前，是没有索引下推的，也就是说尽管这是一颗联合索引树，但是在搜索引擎的眼里，age 字段是被忽略的

(name ,age)索引树

| id | name | age | 
| :--: | :--: | :--: |
| 1 | zhangsan | ~~10~~ |
| 2 | zhangsan | ~~20~~ |
| 3 | zhangsan | ~~30~~ |
| 4 | zhangsan | ~~40~~ |

此时会先从 (name ,age) 索引树中找出 `name = 'zhangsan'` 的 4 个 id 值，然后再去 (id) 索引树中检索`age = 10` 的数据。

但在 Mysql 5.6 之后，有了索引下推，此时进行搜索时，搜索引擎不会忽略 age 字段

| id | name | age |
| :--: | :--: | :--: |
| 1 | zhangsan | 10 |
| 2 | zhangsan | 20 |
| 3 | zhangsan | 30 |
| 4 | zhangsan | 40 |

此时 (name ,age) 索引树会返回符合`name = 'zhangsan' and age = 10`的 1 个 id 值，在 (id) 索引树中直接返回数据。


## 存储引擎

|  | InnoDB | MyISAM | Memory |
| :-: | :-: | :-: | :-: |
| 索引类型 | 聚簇索引<br>索引和数据放在一起 | 非聚簇索引<br>索引和数据分开存放 | 默认 hash 索引<br>支持 B 树索引 |
| 支持事务 | 是 | 否 | 否 |
| 支持表锁 | 是 | 是 | 是 |
| 支持行锁 | 是 | 否 | 否 |
| 支持外键 | 是 | 否 | 否 |
| auto_increment | 是 | 是 | 是（4.1.0后支持）|
| 支持全文索引 | 是（5.6后支持） | 是 |
| 适合操作类型 | 大量insert、delete、update | 大量select |
| 文件结构 | .frm 表结构 <br> .idb 数据和索引 | .frm 表结构<br>.myi 索引<br>.myd 数据 | .frm 表结构 |
| 优点 | 
| 缺点 | 读写效率相对MYISAM比较差。<br>占用的磁盘空间比较大。 |
| 使用场景 | 高并发，更新操作比较多的表。<br>需要使用事务的表。对自动灾难恢复有要求的表。 | | 速度要求快的，临时数据。<br>数据丢失后影响较小。 |

### 外键
使用外键可使两个表之间存在依赖关系。<br>
外键所在的表是子表，所依赖的表为父表，父表中被子表关联的字段必须为**主键**或**唯一键**。<br>

当父表中被关联的字段的值被**修改**或**删除**时，子表中对应的字段也会被**修改**或**删除**。<br>
当子表想要**插入**新数据时，其外键列的值必须是父表中**存在**的值。

### 自动增长列
InnoDB 和 MyISAM 都支持 auto_increament 列。

**注意：**
每张表中只能有一个 auto_increment 列，并且该列要么是**主键**要么是**唯一键**。<br>
也就是说，auto_increament 列**不允许重复**。

auto_increament 列的值默认从 1 开始，不能为空。<br>
如果在插入时**省略**了 auto_increament 列或者值为 **0** 或 **null**，那么会**自动**进行递增的操作。<br>
如果插入时声明了 auto_increament 列的值，合法且不重复。<br>
1. 该值比当前的值大，插入该值，并且**从该值开始递增**。
2. 该值比当前的值小，插入该值，**不影响递增**。


### InnoDB存储引擎

innodb存储引擎的mysql表提供了事务，回滚以及系统崩溃修复能力和多版本迸发控制的事务的安全。
innodb支持自增长列（auto_increment）,自增长列的值不能为空，如果在使用的时候为空的话则会进行自动存现有的值开始增值，如果有但是比现在的还大，则就保存这个值。
innodb存储引擎支持外键（foreign key） ,外键所在的表称为子表而所依赖的表称为父表。
innodb存储引擎最重要的是支持事务，以及事务相关联功能。
innodb存储引擎支持mvcc的行级锁。
innodb存储引擎索引使用的是B+Tree

2：InnoDB存储引擎
　　2.1：InnoDB具有事务，回滚，崩溃修复能力和多版本并发的事务安全

一般情况下找不到 .idb文件，因为 mysql 默认使用 innodb ，其中默认把所有的数据和索引存放在同一个文件中

打开 mysql 命令行，输入
```
show variables like 'innodb_file_per_table';
```
```
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | OFF   |
+-----------------------+-------+
```
这个参数的意思是要不要给innodb中的每一个表建立单独的文件，可以看到是 off ，也就是不

set global innodb_file_per_table=off;

　　　　

### MyISAM存储引擎

使得MyISAM引擎的MySQL可以提供高速存储和检索，以及全文搜索能力，适合数据仓库等查询频繁的应用
-适合做很多count 的计算； 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择； 没有事务。

3：MYISAM存储引擎：

　　3.2：MYISAM存储引擎的存储格式
　　3.2.1：静态型
　　　　表的所有列都是静态的（定长的）。这种情况下，维护和访问预定义格式存储的数据需要的开销很低。但是，需要的空间会更多，原因是，数据在存储的时候，使 用每个列的最大空间来存储，有浪费的空间。当然，磁盘这个都不是问题。

　　3.2.2：动态型
　　　　指标的列中有动态型的列（不定长的）。优点是：使用空间少。缺点是：更新数据时，需要移动数据，产生内部碎片的同时，也降低了维护和访问的效率。
对于这个问题，我们可以：（1）尽量的使用定长字段（2）使用optimize table语句，整理表中的碎片
　　3.2.3：压缩型：
　　　　针对应用程序的声明周期中，只读的数据表，我们可以通过：myisampack工具转化为MYISAM压缩表，以减少使用的磁盘空间
　　3.4：MYISAM存储引擎的优缺点：
　　　　优点：占用空间小，处理速度快（相对InnoDB来说）
　　　　确定：不支持事务的完整性和并发性

### Memory

Memory 会将表结构以 .frm 文件的格式存在磁盘中，所以 Memory 的表结构是持久化的。<br>
但是 Memory 的数据是存放在内存中，所以重启服务器后数据将丢失。

Meory 默认使用 Hash 索引，因为速度比较快，同时也支持 B 树索引。

不支持变长表列


## 如何切换存储引擎
1. 修改配置文件<br>
	打开 `C:\Program Files\MySQL\MySQL Server 5.5` 下的 `my.ini` 文件<br>
	修改其中的 `default-storage-engine` 的值
2. 通过命令行修改配置<br>
	```
	SET @@storage_engine = <Storage Engine>;
	```
3. 使用create table语句指定
	```
	CREATE TABLE t (i INT) ENGINE = <Storage Engine>;
	```
4. 使用 ALTER TABLE 更改存储引擎<br>
	```
	ALTER TABLE t ENGINE = <Storage Engine>;
	```

## 索引维护
索引在插入新的值的时候，为了维护索引的有序性，必须要维护。<br>
在维护索引的时候需要需要分以下几种情况：
1. 如果插入一个比较大的值，直接插入即可，几乎没有成本
2. 如果插入的是中间的某一个值，需要逻辑上移动后续的元素，空出位置
3. 如果需要插入的数据页满了，就需要单独申请一个新的数据页，然后移动部分数据过去，叫做页分裂。<br>
	此时性能会受影响同时空间的使用率也会降低。<br>
	除了页分裂之外还包含页合并


尽量使用自增主键作为索引


## 索引优化

索引越少越好，索引是需要持久化存储的，需要占用磁盘空间，使用时还需要加载到内存，占用内存空间。
更新数据时还要维护索引。

表太小不需要建索引，速度反而会慢
没索引：直接查
有索引：先查索引，再查表





## 源码链接
该文章源码链接 [Github](url)