---
layout: post
title: Java 多线程与高并发之——锁升级
categories: Java
description: some word here
keywords: Java
---

# 序言
现在很多技术中的锁并不是固定的，而是会根据需要不断升级锁的级别。

# 无锁状态
无锁状态很简单，就是资源没有被上锁。

# 偏向锁
经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁。<br>
也就是说，在一段时间，某个资源往往只有一个线程在使用。<br>
此时如果每一次访问都要上锁，会大大影响程序执行的效率。

所以提出了偏向锁。

某资源如果**第一次**被某线程访问，那么该资源会**偏向**这个线程，它会在对象头中记录该线程的 ID 。<br>
此时该线程访问这个资源是不需要进行上锁操作的，直接访问。

如果此时有**另一个线程**访问该资源，经过对比，发现该线程的 ID 和对象头中记录的 ID **不一致**。<br>
也就是，出现了**资源竞争**问题，所以需要**升级**为轻量级锁。

# 轻量级锁
轻量级锁又称自旋锁，由偏向锁升级而来。

现在锁已经被线程 1 持有，然后线程 2 也要竞争锁。<br>
线程 2 会进行以下等待：
```java
while(锁被持有){
	//什么都不做
}
```
也就是说，线程 2 会循环等待锁被释放。<br>
这个无限循环的过程，有人形象地称呼为**自旋锁**。

# 重量级锁
轻量级锁的**升级**是什么？<br>
是重量级锁，是 synchronized ，需要将线程从用户态切换到内核态，这个切换过程是需要时间的。

所以轻量级锁的**本质**是什么？<br>
用 CPU 的时间（自旋操作）换取状态切换的时间。

所以，轻量级锁的自旋次数不能太多，自选次数一旦过多，得不偿失。<br>
所以一般轻量级锁在自旋 **10** 次后会升级为重量级锁，即 synchronized 。<br>
切换到内核态，进入阻塞队列，等待操作系统的调度。

# 锁的细化与粗化
## 锁细化
我们在编程的时候，都会尽量把同步代码块写的很小。<br>
因为某线程在执行同步代码块的同时，其他线程是无法执行该代码的，会浪费大量的时间。

## 锁粗化
但是如果我们的程序是这样的：
```java
对 object 1 加锁
操作1
解锁
...
对 object 1 加锁
操作2
解锁
...
对 object 1 加锁
操作3
解锁
```

也就是说对**同一对象**反复的加锁解锁，那么实际上这样的写法是更好的。
```java
对 object 1 加锁
操作1
...
操作2
...
操作3
解锁
```

这就是锁粗化。

如果 JVM 虚拟机检测到对同一对象一连串的加锁解锁操作，就会自动进行锁粗化的操作。

# 三种锁的区别

| 锁       | 优点                                                         | 缺点                                                 | 适用场景                                             |
| :------- | :------------------------------------------------------------ | :---------------------------------------------------- | :---------------------------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，<br />和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，<br />会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景                     |
| 轻量级锁 | 竞争的线程不会阻塞<br />提高了程序的响应速度                 | 如果始终得不到索竞争的线程，<br />使用自旋会消耗CPU  | 追求响应速度<br />同步块执行速度非常快<br />线程数少 |
| 重量级锁 | 线程竞争不使用自旋，<br />不会消耗CPU                        | 线程阻塞，响应时间缓慢                               | 追求吞吐量<br />同步块执行速度较慢<br />线程数多     |