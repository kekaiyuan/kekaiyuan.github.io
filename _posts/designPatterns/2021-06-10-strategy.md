---
layout: post
title: Java设计模式（二）——策略模式
categories: DesignPatterns
description: Java设计模式（二）——策略模式
keywords: Java，设计模式
---

Java设计模式（二）——策略模式

# 概念

## 什么是策略模式？
策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。
- 对象有一个共同的行为，比如说每个人都要“交个人所得税”，这个行为就是共同的。
- 但是在不同的场景，行为会有差异。比如说“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。


## 组成
- 抽象策略角色： 策略类，通常由一个接口或者抽象类实现。
	- “交个人所得税”就是抽象策略角色，只声明方法，不定义其具体实现。
- 具体策略角色：包装了相关的算法和行为。
	- “在美国交个人所得税”和“在中国交个人所得税”就是具体策略角色，继承于“交个人所得税”。
- 环境角色：持有一个策略类的引用，最终给客户端调用。

## 应用场景：
- 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。
- 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。
- 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。

# 具体实现
- Context上下文
	- Context上下文角色，也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。
	  ```java
		public class Context {

			Strategy strategy;

			public Context(Strategy strategy) {
				this.strategy = strategy;
			}

			//上下文接口
			public void contextInterface() {
				strategy.algorithmInterface();
			}

		}
	  ```
- 策略角色
	- 抽象策略角色，是对策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。algorithm是“运算法则”的意思。
	  	  ```java
			public abstract class Strategy {

				//算法方法
				public abstract void algorithmInterface();

			}
	  ```
- 具体策略角色
	- 用于实现抽象策略中的操作，即实现具体的算法。
	  ```java
		public class ConcreteStrategyA extends Strategy {

			@Override
			public void algorithmInterface() {
				//策略A的具体算法
				...
			}

		}
	  ```
	- 有多少个策略，就编写多少个具体策略角色。

- Client客户端
	- 只需要在Context中传入不同的构造参数即可调用不同的策略
	  ```java
		public class Client {

			public static void main(String[] args) {
				Context context;

				context = new Context(new ConcreteStrategyA());
				context.contextInterface();

				context = new Context(new ConcreteStrategyB());
				context.contextInterface();

				context = new Context(new ConcreteStrategyC());
				context.contextInterface();
				
				...
			}

		}
	  ```
	  
	  
	  
	  ```java
	  ```
	  ```java
	  ```
	  ```java
	  ```
	  ```java
	  ```
	  ```java
	  ```
	  ```java
	  ```
	

@FunctionalInterface
jdk1.8后可以写default方法