---
layout: post
title: 设计模式之——代理Proxy
categories: DesignPatterns
description: 设计模式之——代理Proxy
keywords: Java，设计模式
---

设计模式之——代理Proxy

# 什么是代理模式

代理模式跟实际中的代理很像。

现实中，茅台工厂只负责生产茅台，代理商则负责设计包装，促销活动等。

代理商没有修改产品，只是增加了外部操作的。

在程序设计中，代理模式也是如此。

现在有一个类，里面有各种方法。

代理模式则是在不修改这个类的基础上，能够增加一些诸如计算运行时间、填写日志等的代理操作。

# 静态代理

# 动态代理
在静态代理中，代理类和被代理类属于同一个接口，代理类一定是针对被代理类而言的。
就像茅台代理商代理的一定是茅台，茅台代理商不能代理别的酒。
但是在动态代理中，可以出现代理多种物品的代理商，它不仅可以代理多种酒，甚至不是酒的他也能代理。

就像在静态代理中的日志代理只能填写关于Tank类的日志。
但是在动态代理中，日志代理可以填写所有类的日志。

动态代理是基于 JDK 中的

## 源码
```java
public class Tank implements Movable {

    /**
     * 模拟坦克移动了一段儿时间
     */
    @Override
    public void move() {
        System.out.println("Tank moving claclacla...");
        try {
            Thread.sleep(new Random().nextInt(10000));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        
        System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles","true");
        Tank tank = new Tank();

        Movable movable = (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader(),
                new Class[]{Movable.class}, 
                new TimeProxy(tank)
        );

        movable.move();

    }
}

class TimeProxy implements InvocationHandler {
    Object object;

    public TimeProxy(Object object) {
        this.object = object;
    }

    public void before() {
        System.out.println("method start..");
    }

    public void after() {
        System.out.println("method stop..");
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

        before();
        Object o = method.invoke(object, args);
        after();
        return o;
    }

}

interface Movable {
    void move();
}
```
<br>
结果
<br>
```java
method start..
Tank moving claclacla...
method stop..
```
仔细阅读源码会发现，明明没有调用 `TimeProxy `类，但是 `TimeProxy `类的 `invoke `方法却被调用了<br>
这就是动态代理。<br>
通过正确地使用Java自带的Proxy类，JVM会自动地帮我们把被代理类和代理类关联起来。<br>

## 原理

- Proxy.newProxyInstance
> 以下内容引用自JDK1.8 API<br>
> public static Object newProxyInstance(ClassLoader loader,<br>
>                                      	 						类\<?>[] interfaces,<br>
>                                       							InvocationHandler h)<br>
> 参数 <br>
> loader - 类加载器来定义代理类 <br>
> interfaces - 代理类实现的接口列表 <br>
> h - 调度方法调用的调用处理函数<br>

- 生成动态代理文件<br>
```java
System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");
```
该行代码很容易理解，英译汉就能够明白。<br>
系统.获得配置文件.设置("sun.misc.代理生成类.存储生成文件","true");<br>
像这种见名知意的代码都没有必要点进去看，这是让系统把我们代理中产生的文件保存下来。<br>

加入该行代码后，系统会生成一个com目录，目录下有一个 `$Proxy0.class` 文件，这个就是我们动态代理的动态二字含义。<br>
动态代理指的是，程序运行后会动态地生成一个.class文件，然后通过反射完成代理功能。<br>

![enter description here](/images/posts/designpatterns/proxy/proxyfile.png)

如果没有生成该目录，可能是路径名的原因。<br>
老版本用的是`System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");`比如 Jdk 1.8<br>
新版本用的是`System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles","true");`比如 Jdk 12<br>

如果不清楚，可以查找 `ProxyGenerator` 这个类，找到 `saveGeneratedFiles` 这个属性，看看他取的是哪个系统属性。<br>
```java
private static final boolean saveGeneratedFiles = (Boolean)AccessController.doPrivileged(new GetBooleanAction("sun.misc.ProxyGenerator.saveGeneratedFiles"));
```

而在阅读 `$Proxy0.class` 文件后会发现，在 `move()` 方法中会加入 `invoke()` 方法。<br>
这也就是为什么明明源码中没有调用代理类，却成功调用代理类的原因。<br>
# 代码链接
该文章源码链接[url](url)