---
layout: post
title: 数据库之——事务
categories: Database
description: 数据库之——事务
keywords: Database
---

数据库之——事务

所有关系型数据库的事务机制都是一样的。

## 事务
数据库是**持久化**的数据，是存储在硬盘中的。<br>
当我们使用某个数据库的时候，程序会帮我们从硬盘中复制一份数据库到缓存中，相当于建立一个副本。

在执行 SQL 语句时，并不是对硬盘中的数据库进行操作，而是对缓存中的副本进行操作。
当我们**提交**了事务后，这些操作才会同步到硬盘中的数据库。
同时结束事务，开启一个新的事务。

事务由事务开始和事务结束之间执行的全体操作组成。

事务（Transaction）是一个操作序列。<br>
这些操作要么都做，要么都不做，是一个不可分割的工作单位，是数据库环境中的逻辑工作单位。
- 事务是为了保证数据库的完整性
- 事务不能嵌套
- 事务共有两种操作：提交和回滚
	- 数据库是**持久化**的数据，所以是存储在硬盘的。<br>
		当我们使用某个数据库的时候，程序会帮我们从硬盘中复制一份数据库到内存，相当于建立一个副本。
		在执行 SQL 语句时，并不是对硬盘中的数据库进行操作，而是对内存中的副本进行操作。
	- 提交<br>
		修改硬盘中的数据库。
	- 回滚<br>
		还原内存中的副本。
- 在 oracle 中，没有事务开始的语句。<br>
	一个 Transaction **起始于**一条 DML ( Insert , Update , Delete ) 语句<br>
	**结束于**以下的几种情况：
	- 用户显式执行 Commit语句 提交操作或执行 Rollback语句 回退。
	- 当执行 DDL ( Create , Alter , Drop ) 语句事务自动提交。
	- 用户正常断开连接时， Transaction 自动提交。
	- 系统崩溃或断电时事务自动回退。
- 事务的结束：
	- 用户显式执行 Commit语句 提交操作或执行 Rollback语句 回退。
	- 自动提交，但是一般情况下要将自动提交进行关闭，效率太低。
	- 用户正常断开连接时， 自动提交事务。
	- 系统崩溃或断电时事务自动**回滚**。
增删改是数据库的常用操作，在进行操作的时候都需要 **事务** 的保证。<br>
也就是说每次在 PL/SQL 中执行 sql 语句之后都需要完成 commit 的操作。


事务的好处：
- 程序员们可以先使用副本试运行 SQL 语句查看结果是否正确。<br>
	当检查无误时，再修改硬盘中真正的数据库。
- 更重要的是，保持 **数据一致性**。

事务的关键性在于保持**数据一致性**。
如果同一份数据，在同一个时刻只能有一个人访问，就不会出现数据错乱的问题，但是在现在的项目中，更多的是并发访问。
并发访问很容易造成数据的不安全，即不一致。
如果要保证数据的安全，最主要的方式就是**加锁**的方式，例如MVCC
    
如果不保证事务的话，会造成**脏读**，**不可重复读**，**幻读**。	

事务的延申：
- 最基本的数据库事务
- 声明式事务
- 分布式事务




/*
增删改是数据库的常用操作，在进行操作的时候都需要《事务》的保证， 也就是说每次在pl/sql中执行sql语句之后都需要完成commit的操作
事务变得非常关键：
    最主要的目的是为了数据一致性
    如果同一份数据，在同一个时刻只能有一个人访问，就不会出现数据错乱的问题，但是在现在的项目中，更多的是并发访问
    并发访问的同时带来的就是数据的不安全，也就是不一致
    如果要保证数据的安全，最主要的方式就是加锁的方式，MVCC
    
    事务的延申：
        最基本的数据库事务
        声明式事务
        分布式事务
    为了提高效率，有可能多个操作会在同一个事务中执行，那么就有可能部分成功，部门失败，基于这样的情况就需要事务的控制。
    select * from emp where id = 7902 for update
    select * from emp where id = 7902 lock in share mode.
    
    如果不保证事务的话，会造成脏读，不可重复读，幻读。
*/


--事务：表示操作集合，不可分割，要么全部成功，要么全部失败

--事务的开始取决于一个DML语句
/*
事务的结束
  1、正常的commit（使数据修改生效）或者rollback（将数据恢复到上一个状态）
  2、自动提交，但是一般情况下要将自动提交进行关闭，效率太低
  3、用户关闭会话之后，会自动提交事务
  4、系统崩溃或者断电的时候回回滚事务，也就是将数据恢复到上一个状态
*/
insert into emp(empno,ename) values(2222,'zhangsan');
commit;
rollback;
select * from emp;

--savepoint  保存点
--当一个操作集合中包含多条SQL语句，但是只想让其中某部分成功，某部分失败，此时可以使用保存点
--此时如果需要回滚到某一个状态的话使用 rollback to sp1;
delete from emp where empno = 1111;
delete from emp where empno = 2222;
savepoint sp1;
delete from emp where empno = 1234;
rollback to sp1;
commit;
/*

## 事务的四个特性：ACID
事务有四个特性，ACID 是四个特性的首字母

### 原子性 Atomicity
事务不可分割，要么全部提交成功，要么全部失败回滚，不能只执行一部分操作。

### 一致性 **C**onsistency
事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。

简单的说，数据库中的数据是“正确的”，满足约束的。<br>
- 银行系统中 A 给 B 转账，A 少了 100 元，那么 B 就一定多了 100 元。<br>
	不能出现 A 少了 100 元，但是 B 没有加 100 元的情况。
- A 给 B 转账 300 元，但是 A 只有 298 元，那么 A 就只能转 298 元。<br>
	不能出现 A 变成 -2 元，而 B 加了 300 元的情况。

一致性是四个特性中**最关键**的特性，是最终的追求。

一致性是通过原子性、隔离性、持久性来保证的。


### 隔离性 **I**solation<br>
事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能不被其他事务干扰。

不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间。<br>
即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。

共有四个隔离级别：
- 读未提交
	- [x] 脏读<br>
		可以读取其他事务中尚未提交的数据。
	- [x] 不可重复读
	- [x] 幻读 
- 读已提交<br>
	只能读取已经提交的数据。
	- [ ] 脏读
	- [x] 不可重复读<br>
		**一个事务范围内，多次查询某个数据，却得到不同的结果。**
		事务A 读取了某数据后，其他事务提交修改了该数据。<br>
		事务A 再次读取该数据读到的是修改后的数据，两次数据不匹配<br>
		针对 **update** 和 **update**
	- [x] 幻读 
- 可重复读<br>
	保证事务处理的过程中，多次读取同一个数据时，其值都和事务开始时刻是一致的。
	- [ ] 脏读
	- [ ] 不可重复读
	- [x] 幻读 <br>
		事务 A 在开始时读到 3 条记录，然后其他事务插入了第 4 条数据。<br>
		此时事务 A 通过 select 依然只能读到 3 条记录。<br>
		但是如果使用 insert , update , delete 语句就会发现第4条语句的存在。<br>
		这就是 **幻读**。<br>
		针对 **insert** 
		- 原因？<br>
			**行锁**只能锁住行，即使把所有的行记录都上锁，也阻止不了新插入的记录。
		- 如何解决？<br>
			- 升级锁的级别，但是效率会大大下降，不推荐。
			- 加入**间隙锁**，与行锁配合。<br>
				将两行记录间的空隙加上锁，**阻止新记录的插入**，这个锁称为间隙锁。
- 序列化<br>
	- [ ] 脏读
	- [ ] 不可重复读
	- [ ] 幻读 
	是最严格的事务隔离级别，它要求所有事务被**串行执行**，即事务只能一个接一个的进行处理，不能并发执行。
- 隔离级别越高，效率越低。	

### 持久性 Durability
一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。

即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态。

常见的是**日志系统**，事务中的每一个操作都会即时写入日志中，当提交后，系统会把日志里的操作再同步到数据库中。



 ## 锁的机制
 为了解决在并发访问的时候，数据不一致的问题，需要给数据加锁
 
 加锁的同时需要考虑 **粒度** 的问题，即操作对象的单位
 - 数据库
 - 表
 - 行

即我可以选择锁住整个**数据库**，锁住整张**表**，或者仅仅锁住我操作的那一**行**数据。

上锁后其他事务无法访问被上锁的数据。

一般情况下，锁的粒度越小，效率越高，粒度越大，效率越低。

在实际的工作环境中，大部分的操作都是**行级锁**  。

*/

delete from emp where empno=7369;
savepoint p1;
delete from emp where empno=7499;
rollback to p1;

select * from emp;

## 源码链接
该文章源码链接 [Github](url)