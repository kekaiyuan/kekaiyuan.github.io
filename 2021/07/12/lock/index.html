<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>MySQL 之——锁机制 &mdash; 菜鸟日记</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://kekaiyuan.github.io//2021/07/12/lock/"><link rel="alternate" type="application/atom+xml" title="菜鸟日记" href="https://kekaiyuan.github.io//feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/favicon.ico"><meta property="og:title" content="MySQL 之——锁机制"><meta name="keywords" content="MySQL, 锁"><meta name="og:keywords" content="MySQL, 锁"><meta name="description" content="MySQL 之——锁机制"><meta name="og:description" content="MySQL 之——锁机制"><meta property="og:url" content="https://kekaiyuan.github.io//2021/07/12/lock/"><meta property="og:site_name" content="菜鸟日记"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-07-12"> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://kekaiyuan.github.io//" title="菜鸟日记"><span class="octicon octicon-mark-github"></span> 菜鸟日记</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://kekaiyuan.github.io//" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://kekaiyuan.github.io//categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://kekaiyuan.github.io//archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://kekaiyuan.github.io//wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://kekaiyuan.github.io//links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://kekaiyuan.github.io//about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="MySQL 之——锁机制"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">MySQL 之——锁机制</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/07/12 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://kekaiyuan.github.io//categories/#MySQL" title="MySQL">MySQL</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 7437 字，约 22 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/images/qrcode.jpg" alt="闷骚的程序员" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>MySQL 之——锁机制</p><hr /><p>layout: post title: MySQL 之——锁机制 categories: MySQL description: MySQL 之——锁机制 keywords: MySQL, 锁</p><hr /><p>MySQL 之——锁机制</p><h1 id="基本介绍">基本介绍</h1><p><strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。</strong></p><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。<br /> 如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。<br /> 从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><hr /><p>相对其他数据库而言，MySQL的锁机制比较简单。<br /> 其最显著的特点是不同的<strong>存储引擎</strong>支持不同的锁机制。<br /></p><ul><li><p>MyISAM 和 MEMORY</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />表级锁（table-level locking）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />行级锁（row-level locking）</li></ul></li><li><p>InnoDB</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />表级锁（table-level locking）</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" checked="checked" />行级锁（row-level locking）</li></ul><p>默认使用行级锁</p></li></ul><hr /><table><thead><tr><th style="text-align: center"> </th><th style="text-align: center">开销</th><th style="text-align: center">加锁速度</th><th style="text-align: center">死锁</th><th style="text-align: center">粒度</th><th style="text-align: center">发生锁冲突的概率</th><th style="text-align: center">并发度</th></tr></thead><tbody><tr><td style="text-align: center">表级锁</td><td style="text-align: center">小</td><td style="text-align: center">快</td><td style="text-align: center">不会</td><td style="text-align: center">大</td><td style="text-align: center">高</td><td style="text-align: center">低</td></tr><tr><td style="text-align: center">行级锁</td><td style="text-align: center">大</td><td style="text-align: center">慢</td><td style="text-align: center">会</td><td style="text-align: center">小</td><td style="text-align: center">低</td><td style="text-align: center">高</td></tr></tbody></table><hr /><p>锁没有优劣之分，要根据业务场景选择合适的锁：<br /></p><ul><li>表级锁<br /> 适合以查询为主，只有少量按索引条件更新数据的应用。<br /> 如 Web 应用。</li><li>行级锁<br /> 适合有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。<br /> 如在线事务处理（OLTP）系统：银行。</li></ul><h1 id="myisam-表锁">MyISAM 表锁</h1><p>MySQL的表级锁有两种模式：</p><ul><li><strong>表共享读锁（Table Read Lock）</strong></li><li><strong>表独占写锁（Table Write Lock）</strong></li></ul><p>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；MyISAM表的读操作与写操作之间，以及写操作之间是串行的！</p><p>建表语句：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nv">`mylock`</span> <span class="p">(</span>
  <span class="nv">`id`</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="n">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="nv">`NAME`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="k">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">)</span>
<span class="p">)</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">MyISAM</span> <span class="k">DEFAULT</span> <span class="n">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`mylock`</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">,</span> <span class="nv">`NAME`</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'1'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`mylock`</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">,</span> <span class="nv">`NAME`</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'2'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`mylock`</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">,</span> <span class="nv">`NAME`</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'3'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">);</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="nv">`mylock`</span> <span class="p">(</span><span class="nv">`id`</span><span class="p">,</span> <span class="nv">`NAME`</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">'4'</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">);</span>
</code></pre></div></div><p><strong>MyISAM写锁阻塞读的案例：</strong></p><p>​ 当一个线程获得对一个表的写锁之后，只有持有锁的线程可以对表进行更新操作。其他线程的读写操作都会等待，直到锁释放为止。</p><table><thead><tr><th style="text-align: left"> </th><th style="text-align: left">session1</th><th>session2</th><th> </th><th> </th></tr></thead><tbody><tr><td style="text-align: left"> </td><td style="text-align: left">获取表的write锁定<br />lock table mylock write;</td><td> </td><td> </td><td> </td></tr><tr><td style="text-align: left"> </td><td style="text-align: left">当前session对表的查询，插入，更新操作都可以执行<br />select * from mylock;<br />insert into mylock values(5,’e’);</td><td>当前session对表的查询会被阻塞<br />select * from mylock；</td><td> </td><td> </td></tr><tr><td style="text-align: left"> </td><td style="text-align: left">释放锁：<br />unlock tables；</td><td>当前session能够立刻执行，并返回对应结果</td><td> </td><td> </td></tr></tbody></table><p><strong>MyISAM读阻塞写的案例：</strong></p><p>​ 一个session使用lock table给表加读锁，这个session可以锁定表中的记录，但更新和访问其他表都会提示错误，同时，另一个session可以查询表中的记录，但更新就会出现锁等待。</p><table><thead><tr><th style="text-align: center">时刻</th><th style="text-align: left">session1</th><th>说明</th><th>session2</th><th> </th></tr></thead><tbody><tr><td style="text-align: center">T1</td><td style="text-align: left">lock table mylock read;</td><td>上锁</td><td> </td><td> </td></tr><tr><td style="text-align: center">T2</td><td style="text-align: left">select * from mylock;</td><td>执行成功<br />可以查询</td><td>select * from mylock;</td><td>执行成功<br />可以查询</td></tr><tr><td style="text-align: center"> </td><td style="text-align: left">select * from person;</td><td>执行失败<br />该 session 不能查询未上锁的表</td><td><br />select * from mylock<br />insert into person values(1,’zhangsan’);</td><td>该 session 可以查询或者更新未锁定的表</td></tr><tr><td style="text-align: center"> </td><td style="text-align: left">insert into mylock values(6,’f’);<br />update mylock set name=’aa’ where id = 1;</td><td>当前session插入或者更新表会提示错误</td><td><br />insert into mylock values(6,’f’);</td><td>阻塞<br />等待锁的释放</td></tr><tr><td style="text-align: center">T3</td><td style="text-align: left">unlock tables;</td><td>释放锁</td><td> </td><td>获得锁，更新立刻执行</td></tr></tbody></table><table><thead><tr><th> </th><th>写锁</th><th>读锁</th></tr></thead><tbody><tr><td>上锁线程</td><td>可读可写。<br />无法访问其他表。</td><td>可读不可写。<br />无法访问其他表。</td></tr><tr><td>其他线程</td><td>不可读写。<br />可以访问其他表。</td><td>可读不可写。<br />可以访问其他表。</td></tr></tbody></table><h2 id="注意">注意:</h2><p><strong>MyISAM在执行查询语句之前，会自动给涉及的所有表加读锁，在执行更新操作前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此用户一般不需要使用命令来显式加锁，上例中的加锁时为了演示效果。</strong></p><p><strong>MyISAM的并发插入问题</strong></p><p>MyISAM表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM也支持查询和插入操作的并发执行</p><p>MyISAM表的读和写是串行的，这是就总体而言的，在一定条件下，MyISAM也支持查询和插入操作的并发执行</p><p>MyISAM存储引擎有一个系统变量 concurrent_insert ，专门用来控制并发插入的行为，值分别为 0，1，2</p><ul><li><p>值为 0 时</p><p>不允许并发插入</p></li><li><p>值为 1 时</p><p>如果表中间没有被删除的行（空洞），MyISAM允许一个进程读表的同时，另一个进程从表尾插入记录</p></li><li><p>值为 2 时</p><p>无论表中有没有空洞，都允许在表尾并发插入记录</p></li></ul><table><thead><tr><th style="text-align: center">session1</th><th style="text-align: center">session2</th></tr></thead><tbody><tr><td style="text-align: center">获取表的read local锁定<br />lock table mylock read local</td><td style="text-align: center"> </td></tr><tr><td style="text-align: center">当前session不能对表进行更新或者插入操作<br />insert into mylock values(6,’f’)<br />Table ‘mylock’ was locked with a READ lock and can’t be updated<br />update mylock set name=’aa’ where id = 1;<br />Table ‘mylock’ was locked with a READ lock and can’t be updated</td><td style="text-align: center">其他session可以查询该表的记录<br />select* from mylock</td></tr><tr><td style="text-align: center">当前session不能查询没有锁定的表<br />select * from person<br />Table ‘person’ was not locked with LOCK TABLES</td><td style="text-align: center">其他session可以进行插入操作，但是更新会阻塞<br />update mylock set name = ‘aa’ where id = 1;</td></tr><tr><td style="text-align: center">当前session不能访问其他session插入的记录；</td><td style="text-align: center"> </td></tr><tr><td style="text-align: center">释放锁资源：unlock tables</td><td style="text-align: center">当前session获取锁，更新操作完成</td></tr><tr><td style="text-align: center">当前session可以查看其他session插入的记录</td><td style="text-align: center"> </td></tr></tbody></table><p>可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定争夺：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">status</span> <span class="k">like</span> <span class="s1">'table%'</span><span class="p">;</span>
<span class="o">+</span><span class="c1">-----------------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span>         <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-----------------------+-------+</span>
<span class="o">|</span> <span class="n">Table_locks_immediate</span> <span class="o">|</span> <span class="mi">352</span>   <span class="o">|</span>
<span class="o">|</span> <span class="n">Table_locks_waited</span>    <span class="o">|</span> <span class="mi">2</span>     <span class="o">|</span>
<span class="o">+</span><span class="c1">-----------------------+-------+</span>
<span class="c1">--如果Table_locks_waited的值比较高，则说明存在着较严重的表级锁争用情况。</span>
</code></pre></div></div><h1 id="innodb-锁">InnoDB 锁</h1><h2 id="事务及其acid属性">事务及其ACID属性</h2><p>事务是由一组SQL语句组成的逻辑处理单元，事务具有 4 g个属性，通常称为事务的 <strong>ACID</strong> 属性。</p><ul><li><p>原子性 <strong>A</strong>ctomicity</p><p>事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</p></li><li><p>一致性 <strong>C</strong>onsistent</p><p>在事务开始和完成时，数据都必须保持一致状态。</p></li><li><p>隔离性 <strong>I</strong>solation</p><p>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。</p></li><li><p>持久性 <strong>D</strong>urable</p><p>事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</p></li></ul><h2 id="并发事务带来的问题">并发事务带来的问题</h2><p>相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事务吞吐量，从而可以支持更多用户的并发操作，但与此同时，会带来一下问题：</p><p><strong>脏读</strong>： 一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”</p><p><strong>不可重复读</strong>：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。</p><p><strong>幻读</strong>： 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”</p><p>上述出现的问题都是数据库读一致性的问题，可以通过事务的隔离机制来进行保证。</p><p>数据库的事务隔离越严格，并发副作用就越小，但付出的代价也就越大，因为事务隔离本质上就是使事务在一定程度上串行化，需要根据具体的业务需求来决定使用哪种隔离级别</p><table><thead><tr><th style="text-align: center"> </th><th style="text-align: center">脏读</th><th style="text-align: center">不可重复读</th><th style="text-align: center">幻读</th></tr></thead><tbody><tr><td style="text-align: center">read uncommitted</td><td style="text-align: center">√</td><td style="text-align: center">√</td><td style="text-align: center">√</td></tr><tr><td style="text-align: center">read committed</td><td style="text-align: center"> </td><td style="text-align: center">√</td><td style="text-align: center">√</td></tr><tr><td style="text-align: center">repeatable read</td><td style="text-align: center"> </td><td style="text-align: center"> </td><td style="text-align: center">√</td></tr><tr><td style="text-align: center">serializable</td><td style="text-align: center"> </td><td style="text-align: center"> </td><td style="text-align: center"> </td></tr></tbody></table><p>默认 repeatable read</p><p>可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">show</span> <span class="n">status</span> <span class="k">like</span> <span class="s1">'innodb_row_lock%'</span><span class="p">;</span>
<span class="o">+</span><span class="c1">-------------------------------+-------+</span>
<span class="o">|</span> <span class="n">Variable_name</span>                 <span class="o">|</span> <span class="n">Value</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-------------------------------+-------+</span>
<span class="o">|</span> <span class="n">Innodb_row_lock_current_waits</span> <span class="o">|</span> <span class="mi">0</span>     <span class="o">|</span>
<span class="o">|</span> <span class="n">Innodb_row_lock_time</span>          <span class="o">|</span> <span class="mi">18702</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Innodb_row_lock_time_avg</span>      <span class="o">|</span> <span class="mi">18702</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Innodb_row_lock_time_max</span>      <span class="o">|</span> <span class="mi">18702</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Innodb_row_lock_waits</span>         <span class="o">|</span> <span class="mi">1</span>     <span class="o">|</span>
<span class="o">+</span><span class="c1">-------------------------------+-------+</span>
<span class="c1">--如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高</span>
</code></pre></div></div><h2 id="innodb-的行锁">InnoDB 的行锁</h2><p>InnoDB 一共有两种行锁：</p><ol><li><p>共享锁（简称 S 锁）</p><p>又称<strong>读锁</strong>。</p></li><li><p>排他锁（简称 X 锁）</p><p>又称<strong>写锁</strong>。</p></li></ol><h3 id="共享锁--读锁--s锁">共享锁 / 读锁 / S锁</h3><p><strong>共享锁</strong>（简称 <strong>S 锁</strong>），又称<strong>读锁</strong>。</p><p>允许一个事务去读一行，</p><p>mysql InnoDB引擎默认的修改数据语句：<strong>update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型</strong>， 注意： 有很多说法都说事务 T 给数据对象 A 上了 S 锁后，则事务 T 只能读 A 不能修改 A 。 经过测试，该说法是错误的。</p><p>共享锁： 只允许读，不允许写。 允许其他事务上共享锁，不允许上排他锁。</p><p>因为排他锁会覆盖共享锁。</p><p>​ <strong>共享锁（s）</strong>：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 ​ <strong>排他锁（x）</strong>：又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。</p><p>​ mysql InnoDB引擎默认的修改数据语句：<strong>update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型</strong>，如果加排他锁可以使用select …for update语句，加共享锁可以使用select … lock in share mode语句。<strong>所以加过排他锁的数据行在其他事务中是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。</strong></p><p><strong>InnoDB行锁实现方式</strong></p><p>​ InnoDB行锁是通过给<strong>索引</strong>上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，<strong>否则，InnoDB将使用表锁！</strong></p><p>1、在不通过索引条件查询的时候，innodb使用的是表锁而不是行锁</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="p">(</span><span class="n">id</span> <span class="nb">INT</span><span class="p">,</span> <span class="n">NAME</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="n">ENGINE</span> <span class="o">=</span> <span class="n">INNODB</span><span class="p">;</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">test</span> <span class="k">ADD</span> <span class="k">INDEX</span> <span class="n">index_id</span> <span class="p">(</span><span class="n">id</span><span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">test</span>
<span class="k">VALUES</span>
	<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">),</span>
	<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">),</span>
	<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">),</span>
	<span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">'4'</span><span class="p">),</span>
	<span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">'5'</span><span class="p">);</span>
</code></pre></div></div><p>打开两个 MySQL 命令行，分别为 session 1 和 session 2</p><table><thead><tr><th>时刻</th><th style="text-align: left">session1</th><th style="text-align: left">说明</th><th style="text-align: left">session2</th><th>说明</th></tr></thead><tbody><tr><td>T1</td><td style="text-align: left">set autocommit=0;</td><td style="text-align: left">关闭自动提交</td><td style="text-align: left">set autocommit=0;</td><td>关闭自动提交</td></tr><tr><td>T2</td><td style="text-align: left">select * from tab_no_index where id = 1 for update;</td><td style="text-align: left">成功</td><td style="text-align: left"> </td><td> </td></tr><tr><td>T3</td><td style="text-align: left"> </td><td style="text-align: left"> </td><td style="text-align: left">select * from tab_no_index where id = 2 for update;</td><td>成功</td></tr><tr><td>T4</td><td style="text-align: left">commit;</td><td style="text-align: left">提交事务</td><td style="text-align: left">commit;</td><td>提交事务</td></tr><tr><td>T5</td><td style="text-align: left">select * from tab_no_index where name = ‘1’ for update;</td><td style="text-align: left">成功</td><td style="text-align: left"> </td><td> </td></tr><tr><td>T6</td><td style="text-align: left"> </td><td style="text-align: left"> </td><td style="text-align: left">select * from tab_no_index where name = ‘2’ for update;</td><td>阻塞，超时后失败</td></tr><tr><td>T7</td><td style="text-align: left"> </td><td style="text-align: left"> </td><td style="text-align: left">select * from tab_no_index where id = 1 for update;</td><td>阻塞，超时后失败</td></tr></tbody></table><p>id 是主键，默认会生成<strong>主键索引</strong>。<br /> T2 时刻 session 1 加的是行锁，所以 T3 时刻 session 2 可以给其他行加行锁。</p><p>而 name 不是索引。<br /> T5 时刻 session 1 加的是表锁，所以 T6 和 T7 时刻 session 2 无法再给该表加锁。</p><p>2、创建带索引的表进行条件查询，innodb使用的是行锁</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">create</span> <span class="k">table</span> <span class="n">tab_with_index</span><span class="p">(</span><span class="n">id</span> <span class="nb">int</span><span class="p">,</span><span class="n">name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="n">engine</span><span class="o">=</span><span class="n">innodb</span><span class="p">;</span>
<span class="k">alter</span> <span class="k">table</span> <span class="nv">`tab_with_index`</span> <span class="k">add</span> <span class="k">index</span> <span class="n">id</span><span class="p">(</span><span class="nv">`id`</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">tab_with_index</span> <span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">'1'</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s1">'2'</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s1">'3'</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s1">'4'</span><span class="p">);</span>
</code></pre></div></div><table><thead><tr><th style="text-align: center">session1</th><th style="text-align: center">session2</th></tr></thead><tbody><tr><td style="text-align: center">set autocommit=0<br />select * from tab_with_indexwhere id = 1;</td><td style="text-align: center">set autocommit=0<br />select * from tab_with_indexwhere id =2</td></tr><tr><td style="text-align: center">select * from tab_with_index where id = 1 for update;</td><td style="text-align: center"> </td></tr><tr><td style="text-align: center"> </td><td style="text-align: center">select * from tab_with_index where id = 2 for update;</td></tr></tbody></table><p>3、由于mysql的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是依然无法访问到具体的数据</p><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">alter</span> <span class="k">table</span> <span class="n">tab_with_index</span> <span class="k">drop</span> <span class="k">index</span> <span class="n">id</span><span class="p">;</span> 
<span class="k">insert</span> <span class="k">into</span> <span class="n">tab_with_index</span>  <span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s1">'4'</span><span class="p">);</span>
</code></pre></div></div><table><thead><tr><th style="text-align: center">session1</th><th style="text-align: center">session2</th></tr></thead><tbody><tr><td style="text-align: center">set autocommit=0</td><td style="text-align: center">set autocommit=0</td></tr><tr><td style="text-align: center">select * from tab_with_index where id = 1 and name=’1’ for update</td><td style="text-align: center"> </td></tr><tr><td style="text-align: center"> </td><td style="text-align: center">select * from tab_with_index where id = 1 and name=’4’ for update;<br />虽然session2访问的是和session1不同的记录，但是因为使用了相同的索引，所以需要等待锁</td></tr></tbody></table><h3 id="总结">总结</h3><p><strong>对于MyISAM的表锁，主要讨论了以下几点：</strong> （1）共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的。<br /> （2）在一定条件下，MyISAM允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表查询和插入的锁争用问题。 （3）MyISAM默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置LOW_PRIORITY_UPDATES参数，或在INSERT、UPDATE、DELETE语句中指定LOW_PRIORITY选项来调节读写锁的争用。 （4）由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，MyISAM表可能会出现严重的锁等待，可以考虑采用InnoDB表来减少锁冲突。</p><p><strong>对于InnoDB表，本文主要讨论了以下几项内容：</strong> （1）InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会使用表锁。 （2）在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。</p><p>在了解InnoDB锁特性后，用户可以通过设计和SQL调整等措施减少锁冲突和死锁，包括：</p><ul><li>尽量使用较低的隔离级别； 精心设计索引，并尽量使用索引访问数据，使加锁更精确，从而减少锁冲突的机会；</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小；</li><li>给记录集显式加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁；</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会；</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响； 不要申请超过实际需要的锁级别；除非必须，查询时不要显示加锁；</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li></ul><h2 id="源码链接">源码链接</h2><p>该文章源码链接 <a href="url">Github</a></p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://kekaiyuan.github.io/" target="_blank">Kaiyuan Ke</a></li><li>本文链接：<a href="https://kekaiyuan.github.io//2021/07/12/lock/" target="_blank">https://kekaiyuan.github.io//2021/07/12/lock/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/07/12/lock/', clientID: '', clientSecret: '', repo: '', owner: '', admin: [''], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:350px" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:16px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://kekaiyuan.github.io//assets/search_data.json?v=1646200239', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Kaiyuan Ke">Kaiyuan Ke</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/kekaiyuan/kekaiyuan.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://kekaiyuan.github.io//" title="首页" target="">首页</a></li><li> <a href="https://kekaiyuan.github.io//categories/" title="分类" target="">分类</a></li><li> <a href="https://kekaiyuan.github.io//archives/" title="归档" target="">归档</a></li><li> <a href="https://kekaiyuan.github.io//wiki/" title="维基" target="">维基</a></li><li> <a href="https://kekaiyuan.github.io//links/" title="链接" target="">链接</a></li><li> <a href="https://kekaiyuan.github.io//about/" title="关于" target="">关于</a></li><li><a href="https://kekaiyuan.github.io//feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
