---
layout: post
title: Java 多线程与高并发之—— ReentrantLock
categories: Java 
description: some word here
keywords: Java 
mermaid: true
---


unlock 一定要写在 finally 里


# ReentrantLock 的优点
## 可响应外部消息
synchronized 在执行的时候是无法响应外部消息，所以如果某个线程在获得锁后陷入了死循环，那么所有其他线程都会被阻塞。

```java
public static void main(String[] args) throws InterruptedException {
        {
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    synchronized (this) {
                        System.out.println(Thread.currentThread().getName() + " start");
                        try {
                            Thread.sleep(Integer.MAX_VALUE);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            };
            new Thread(runnable, "t1").start();
            new Thread(runnable, "t2").start();
        }
    }
```
结果
```java
t1 start
```
因为 t1 拿到了锁以后进行了无限期的睡眠，所以 t2 永远拿不到锁。

但是 ReentrantLock 可以解决这个问题。

上锁时调用 lockInterruptibly() 方法，该方法会响应外部的 interrupt() 方法
```java
public static void main(String[] args) throws InterruptedException {
        Lock lock = new ReentrantLock();

        Thread t1 = new Thread(() -> {
            try {
                lock.lockInterruptibly();
                System.out.println("t1 start");
                Thread.sleep(Integer.MAX_VALUE);
                System.out.println("t1 end");
            } catch (InterruptedException e) {
                System.out.println("t1 interrupted!");
            } finally {
                lock.unlock();
            }
        });
        t1.start();

        Thread t2 = new Thread(() -> {
            try {
                lock.lockInterruptibly();
                System.out.println("t2 start");
                Thread.sleep(Integer.MAX_VALUE);
                System.out.println("t2 end");
            } catch (InterruptedException e) {
                System.out.println("t2 interrupted!");
            } finally {
                lock.unlock();
            }
        });
        t2.start();

        Thread.sleep(5000);

        t1.interrupt(); //打断线程 1 的等待
		
		Thread.sleep(5000);

        t2.interrupt(); //打断线程 2 的等待
    }
}
```
结果
```java
t1 start
t1 interrupted!
t2 start
t2 interrupted!
```
该程序 t1 线程使用 `lockInterruptibly()` 方法上锁，然后陷入无限期的睡眠。
然后创建 t2 线程，因为 t1 线程不释放锁，所以 t2 线程无法运行。

在等待 5s 后，调用 `t1.interrupt();` 打断 t1 线程：
1. t1 线程会捕获到 InterruptedException 异常
2. t1 线程执行 catch 代码块，输出异常信息
3. t1 线程执行 finally 代码块，释放锁

于是 t2 线程拿到了锁，开始执行。

同样的，在 5s 后使用 `t2.interrupt();` 打断 t2 线程的运行。

```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```

# CyclicBarrier
先翻译一下类名：循环栅栏。<br>
通过类名来感受这个类的作用：
1. 现在有一个**栅栏**，把线程们的路拦住了。
2. 线程到达栅栏后会被**阻塞**，无法继续前行。
3. 当栅栏前等待的线程达到**一定数量**后，栅栏会打开，所有线程继续运行。
4. 栅栏重新开闭，开启新一轮的**循环**。

所以这个类用于同步线程的运行状态


案例：
```java
public class T07_TestCyclicBarrier {
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(20, () -> {
            System.out.println("已满 20，发车！");
        });

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                try {
                    barrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```
Cyclic 有两个构造方法：
1. CyclicBarrier(int parties)
2. CyclicBarrier(int parties, Runnable barrierAction)

即第一个参数是栅栏的**大小**——当等待线程的数量达到多少时开放栅栏。<br>
第二个参数可选——栅栏开启时是否需要执行某些操作。

在本案例中，共有 100 个线程，栅栏大小为 20 ，开启栅栏时会打印一句话：“已满 20，发车！”<br>
所以运行结果为：
```java
已满 20，发车！
已满 20，发车！
已满 20，发车！
已满 20，发车！
已满 20，发车！
```

CyclicBarrier 用于同步多个线程的执行流程：
- 即某线程不能独自往前推进，它必须等待其他线程的运行结果
- 使用方法：<br>
	在需要等待的地方调用 `barrier.await();`



循环栅栏
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```
# Phaser
CyclicBarrier 是循环栅栏，只有一道栅栏，通过栅栏的线程不会再被阻塞。

但如果需要使用**多栅栏模式**，线程们会先在第一道栅栏前集合，再在第二部栅栏前集合……

从现实生活中考虑，集体活动是不是如此？<br>
现有一集体活动：
```mermaid
graph LR;
A[在某地点集合] --> B[吃饭]
B --> C[大保健]
C --> D[喝酒] 
D --> E[解散]
```
每个人

遗传算法

多栅栏
```java
```
```java
```
```java
```
```java
```
```java
```
```java
```

Guava RateLimiter

# Semaphore
Semaphore 类可用于控制**最多**有多少个线程可**同时运行**。

Semaphore 类可用于限流。

举个栗子：
某超市有 5 个收银台。
- 如果有 20 人等待结账，同一时刻只有 5 个人正在结账。
- 如果有 100 人等待结账，同一时刻也只有 5 个人正在结账。

如何使用？
- 创建 Semaphore 对象，在创建时指定同时运行的线程的**最大数量**。
- 使用 acquire() 方法申请锁
- 使用 release() 方法释放锁（请将该方法写入 finally 代码块，确保锁的释放）

案例：
```java
public class T11_TestSemaphore {
    public static void main(String[] args) {
        //可控制同时最多有几个线程运行
        Semaphore s = new Semaphore(1);

        for (int i = 0; i < 4; i++) {
            new Thread(() -> {
                try {
                    s.acquire();
                    System.out.println(Thread.currentThread().getName() + " running");
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    System.out.println(Thread.currentThread().getName() + " end");
                    s.release();
                }
            }, "T" + i).start();
        }
    }
}
```
该程序限制最大同时运行线程数为 1 。

结果：
```java
T0 running
T0 end
T2 running
T2 end
T1 running
T1 end
T3 running
T3 end
```
在一个线程结束前，没有线程可以运行。

尝试修改最大同时运行线程数为 4 。
```java
……（其他代码不变）
Semaphore s = new Semaphore(4);
……（其他代码不变）
```
结果
```java
T0 running
T3 running
T2 running
T1 running
T3 end
T1 end
T0 end
T2 end
```
可以看到，同一时刻有 4 个线程在运行。

Semaphore 共有两个构造方法：
- Semaphore(int permits) <br>
	Creates a Semaphore with the given number of permits and **nonfair** fairness setting.
- Semaphore(int permits, boolean fair) <br>
	Creates a Semaphore with the given number of permits and the given fairness setting.

即 Semaphore 默认是**非公平**的：<br>
创建一个新线程后，它会试图直接去拿锁，拿不到后才会进入等待队列。<br>
即会发生后面来的线程比前面来的线程先拿到锁的情况，即**插队**。

之前 `Semaphore s = new Semaphore(1);` 的例子的结果：
```java
T0 running
T0 end
T2 running
T2 end
T1 running
T1 end
T3 running
T3 end
```
T2 线程比 T1 线程先抢到了锁。

如果指定 Semaphore 为**公平**的：<br>
无论现在锁是什么状态，我直接进入队列中进行排队等待。<br>
即**先进先出**（FIFO）。
```java
……（其他代码不变）
Semaphore s = new Semaphore(1, true);
……（其他代码不变）
```
结果
```java
T0 running
T0 end
T1 running
T1 end
T2 running
T2 end
T3 running
T3 end
```
满足线程创建的顺序。

# Exchanger
Exchanger 是一个用于交换线程信息的类。

如何使用？
- 创建一个 Exchanger 对象。
- 调用 exchange(Object o) 方法交换数据。 

案例
```java
public class T12_TestExchanger {

    static Exchanger<String> exchanger = new Exchanger<>();

    public static void main(String[] args) {
        new Thread(new TestRunnable("a"), "A").start();
        new Thread(new TestRunnable("b"), "B").start();
    }

    static class TestRunnable implements Runnable {
        String message = null;

        public TestRunnable(String message) {
            this.message = message;
        }

        @Override
        public void run() {
            try {
                message = exchanger.exchange(message);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + " " + message);
        }
    }
}
```
结果
```java
A b
B a
```

**注意：**<br>
当某线程调用了 exchange(Object o) 方法后，在另一个线程也调用该方法交换数据前。<br>
该线程会一直**阻塞**。


```java
```
```java
```
```java
```
```java
```
```java
```


# 源码链接
该文章源码链接 [Github](url)