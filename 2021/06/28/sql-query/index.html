<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Oracle SQL 之——查询 &mdash; 菜鸟日记</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://kekaiyuan.github.io//2021/06/28/sql-query/"><link rel="alternate" type="application/atom+xml" title="菜鸟日记" href="https://kekaiyuan.github.io//feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/favicon.ico"><meta property="og:title" content="Oracle SQL 之——查询"><meta name="keywords" content="Oracle，SQL"><meta name="og:keywords" content="Oracle，SQL"><meta name="description" content="SQL 语言指的是结构化查询语言 (Structured Query Language)，具有定义、查询、更新和控制等多种功能，是关系数据库的标准语言。"><meta name="og:description" content="SQL 语言指的是结构化查询语言 (Structured Query Language)，具有定义、查询、更新和控制等多种功能，是关系数据库的标准语言。"><meta property="og:url" content="https://kekaiyuan.github.io//2021/06/28/sql-query/"><meta property="og:site_name" content="菜鸟日记"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-06-28"> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://kekaiyuan.github.io//" title="菜鸟日记"><span class="octicon octicon-mark-github"></span> 菜鸟日记</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://kekaiyuan.github.io//" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://kekaiyuan.github.io//categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://kekaiyuan.github.io//archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://kekaiyuan.github.io//wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://kekaiyuan.github.io//links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://kekaiyuan.github.io//about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Oracle SQL 之——查"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Oracle SQL 之——查询</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/06/28 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://kekaiyuan.github.io//categories/#Oracle" title="Oracle">Oracle</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 12085 字，约 35 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/images/qrcode.jpg" alt="闷骚的程序员" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>SQL 语言指的是结构化查询语言 (Structured Query Language)，具有定义、查询、更新和控制等多种功能，是关系数据库的标准语言。</p><h2 id="sql分类">SQL分类</h2><ul><li>DML<ul><li>Data Manipulation Language 数据操纵语言</li><li>针对<strong>数据</strong></li><li>关键字<ul><li>SELECT</li><li>INSERT</li><li>UPDATE</li><li>DELETE</li></ul></li></ul></li><li>DDL<ul><li>Data definition language 数据定义语言</li><li>针对<strong>表</strong></li><li>关键字<ul><li>CREATE</li><li>ALTER</li><li>DROP</li><li>RENAME</li></ul></li></ul></li><li>DCL<ul><li>Data Control Language 数据控制语言</li><li><strong>权限、事务</strong></li><li>关键字<ul><li>GRANT</li><li>REVOKE</li></ul></li></ul></li><li>Transaction<ul><li>commit</li><li>rollback</li><li>savepoint</li></ul></li></ul><h2 id="实验用数据表">实验用数据表</h2><p>本文使用的数据库为 oracle 11g 自带的 scott</p><p>其结构为：</p><ul><li>emp表——&gt;雇员表(employee)<ul><li>Empno: 雇员工号</li><li>Ename: 雇员名字</li><li>Job: 工作。（秘书、销售、经理、分析员、保管）</li><li>Mgr(manager): 经理的工号</li><li>Hiredate: 雇用日期</li><li>Sal: 工资</li><li>Comm: 津贴</li><li>Deptno: 所属部门号</li></ul></li><li>dept表——&gt;部门表（department）<ul><li>Deptno: 部门号</li><li>Dname: 部门名字</li><li>Loc: 地址</li></ul></li><li>salgrade表——&gt;一个公司是有等级制度的，用此表表示一个工资的等级<ul><li>Grade: 等级</li><li>losal: 最低工资</li><li>hisal: 最高工资</li></ul></li><li>bonus表——&gt; 奖金表：表示一个雇员的工资及奖金。<ul><li>Ename: 雇员名字</li><li>job: 工作</li><li>sal: 工资</li><li>comm: 津贴</li></ul></li></ul><h2 id="基本查询">基本查询</h2><h3 id="select">select</h3><ul><li>Select-from-where句型<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">SELECT</span> <span class="p">[</span><span class="k">DISTINCT</span><span class="p">]</span> <span class="err">{</span><span class="o">*</span><span class="p">,</span><span class="k">column</span> <span class="k">alias</span><span class="p">,..</span><span class="err">}</span>
  <span class="k">FROM</span> <span class="k">table</span> <span class="k">alias</span>
  <span class="k">Where</span> <span class="err">条件表达式</span>
</code></pre></div></div><ul><li>alias 指别名，我们可以更改表或列的名字，以方便我们操作<ul><li>Column alias</li><li>Column “alias”<ul><li>当别名中带有空格时，必须使用引号</li></ul></li><li>Column as alias</li><li><strong>别名</strong>可以是中文</li></ul></li><li>检索单个列<br /> <code class="language-plaintext highlighter-rouge">select col from tableName;</code></li><li>检索多个列<br /> <code class="language-plaintext highlighter-rouge">select col1, col2,col3 from tableName;</code></li><li>检索所有列<ul><li><code class="language-plaintext highlighter-rouge">select * from tableName;</code></li><li>* 称为通配符<ul><li>优点<br /> 书写方便、可以检索未知列</li><li>缺点<br /> 降低检索的性能</li><li>当只检索固定列的数据时，不要使用 * ，效率低</li><li>表过大，越要避免使用 * ，否则很容易卡死</li></ul></li></ul></li><li>给检索出的列起个别名<ul><li><code class="language-plaintext highlighter-rouge">select job "gong zuo" from emp;</code></li><li><code class="language-plaintext highlighter-rouge">select job as "gong zuo" from emp;</code></li></ul></li><li>表别名<ul><li><code class="language-plaintext highlighter-rouge">Select e.* from emp e;</code></li><li><code class="language-plaintext highlighter-rouge">Select e.empno,e.deptno from emp e;</code></li></ul></li><li>distinct<ul><li>可将检索结果去重。</li><li>当检索多个列，有一个字段不一样都不会被去重。</li></ul></li></ul></li></ul><h3 id="where">where</h3><ul><li>where 后面跟的是条件表达式</li><li>条件比较</li></ul><h4 id="--------------any--some--all">＝ , !＝ , &lt;&gt; , &lt; , &gt; , &lt;= , &gt;= , any , some , all</h4><ul><li>!= 和 &lt;&gt; 都表示不等于</li><li>any , some , all 后面跟的是一堆数值<ul><li>any 取其中任意一个<br /> <code class="language-plaintext highlighter-rouge">select sal from emp where sal &gt; any(1000 , 1500 , 3000);</code><br /> sal 只要大于 1000,1500,3000 中任意一个值即可。<br /> 可以将 any 理解为<strong>最小值</strong></li><li>some 和 any 一样，取<strong>最小值</strong><br /> <code class="language-plaintext highlighter-rouge">select sal from emp where sal &gt; some(1000 , 1500 , 3000);</code></li><li>all 表示所有，即<strong>最大值</strong><br /> <code class="language-plaintext highlighter-rouge">select sal from emp where sal &gt; some(1000 , 1500 , 3000);</code><br /> 检索大于 3000 的 sal</li></ul></li></ul><h4 id="is-null--is-not-null">is null , is not null</h4><ul><li>在 SQL 语法中， null 表示一个特殊的含义，不能使用 = 和 != 进行比较</li><li>判断某字段是否为空，必须使用 is null 或 is not null</li></ul><h4 id="between-x-and-y">between x and y</h4><ul><li>找到<strong>大于等于</strong> x 的值和<strong>小于等于</strong> y 的值</li><li>包含 x 和 y 的值</li><li>以下语句等价<ul><li><code class="language-plaintext highlighter-rouge">select sal from emp where sal between 1500 and 3000;</code></li><li><code class="language-plaintext highlighter-rouge">select sal from emp where sal &gt;= 1500 and sal &lt;= 3000;</code></li></ul></li></ul><h4 id="inlist-not-inlist">in（list）, not in（list）</h4><ul><li>需要进行某些值的等值判断的时候使用</li><li>in 和 not in 会从后面的 list 列表中逐一比对</li><li><code class="language-plaintext highlighter-rouge">select * from emp where deptno in (10,20);</code>等价于<br /> <code class="language-plaintext highlighter-rouge">select * from emp where deptno = 10 or deptno = 20;</code></li><li><code class="language-plaintext highlighter-rouge">select * from emp where deptno not in (10,20);</code>等价于<br /> <code class="language-plaintext highlighter-rouge">select * from emp where deptno != 10 or deptno != 20;</code></li></ul><h4 id="existssubquery">exists（sub－query）</h4><ul><li>相关子查询</li><li>现在要查询部门编号为10和20的员工，要求使用exists实现<ul><li>在 SQL 中，select 等同于一次循环，使用相关子查询等于使用双重循环</li><li>在相关子查询中，要将外层循环和内层循环联系到一起，否则容易输出整张表</li><li><div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">select</span> <span class="o">*</span>
      <span class="k">from</span> <span class="n">emp</span> <span class="n">e</span>
      <span class="k">where</span> <span class="k">exists</span> <span class="p">(</span><span class="k">select</span> <span class="n">deptno</span>
                      <span class="k">from</span> <span class="n">dept</span> <span class="n">d</span>
                      <span class="k">where</span> <span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">deptno</span> <span class="o">=</span> <span class="mi">10</span> <span class="k">or</span> <span class="n">d</span><span class="p">.</span><span class="n">deptno</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span>
                      <span class="k">and</span> <span class="n">e</span><span class="p">.</span><span class="n">deptno</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">deptno</span><span class="p">)</span>
</code></pre></div></div></li><li>exists 等同于逻辑判断<br /> 对于外层的 select 语句的每一个结果，exists 都会使用内层的语句进行一次判断：是否存在满足条件的语句<ul><li>若存在，则为 true ，外层 select 有效。</li><li>若不存在，则为 false ，外层 select 无效。<br /> 所以相关子查询必须把 外层select 和 内层select 联系起来，否则 内层select 的结果将恒定为固定值。</li></ul></li><li>同时使用 or 和 and，要用 () 把 or 语句括起来保证执行顺序。</li></ul></li></ul><h4 id="like--escape">like , escape</h4><ul><li><strong>模糊查询</strong></li><li>在 like 的语句中，需要使用占位符或通配符<ul><li>_ 占位符，可替换为<strong>一个</strong>任意字符</li><li>% 通配符，可替换为<strong>无数个</strong>任意字符</li><li>不能过度使用通配符。如果其他操作符能达到目的，就不要使用通配符。</li><li>确实需要使用通配符时，除非绝对必要，否则不要把通配符用到搜索模式最开始处，因为这样搜索起来是最慢的。</li></ul></li><li>查询名字以 S 开头的用户<br /> <code class="language-plaintext highlighter-rouge">select * from emp where ename like('S%');</code></li><li>查询名字以 S 开头且倒数第二个字符为 T 的用户<br /> <code class="language-plaintext highlighter-rouge">select * from emp where ename like('S%T_');</code></li><li>escape <strong>自定义转义字符</strong><br /> 查询名字中带 % 的用户<br /> <code class="language-plaintext highlighter-rouge">select * from emp where ename like ('%a%%') escape ('a') </code><br /> 此时的 a 被定义为转义字符，等同于 Java 中的 ‘'，’a%’ 表示 ‘%’ 这个符号，不再是通配符。</li><li>使用 like 时要注意，因为效率<strong>比较低</strong>。</li><li>使用 like 可以参考使用索引，但是要求不能以 % 开头，查询次数会爆炸。<ul><li>我现在要查询含有 “Java” 的文章。<br /> 如果使用 “%Java%”。<br /> 每篇文章程序都要从头读到尾进行匹配。<br /> 如果有一万篇文章，每篇一千字。<br /> 那么程序就要遍历整整一千万字。</li></ul></li><li>涉及到大文本的检索的时候，可以使用某些框架。<ul><li>luence</li><li>solr</li><li>elastic search</li></ul></li></ul><h3 id="order-by">order by</h3><ul><li>进行排序操作</li><li>按照单个列排序<br /> <code class="language-plaintext highlighter-rouge">select * from XXX where XXX order by col</code></li><li>升序排序<br /> <code class="language-plaintext highlighter-rouge">order by col (asc)</code><br /> 默认情况下升序，asc 可省略。</li><li>降序排序<br /> <code class="language-plaintext highlighter-rouge">order by col desc</code></li><li>按照多个列排序（优先级）<br /> <code class="language-plaintext highlighter-rouge">order by col1 desc(asc), col2 desc(asc)</code><br /> 先根据 col1 进行排序，当有数据 col1 字段相等时，再根据 col2 进行排序。<br /> 不同字段可以使用不同的排序顺序。</li><li>排序按照自然顺序进行<ul><li>如果是数字，比较数值</li><li>如果是字符串，比较字典序</li></ul></li><li>每次在执行 order by 的时候是做了全排序，效率很低，需要耗费大量的内存。<br /> 如果数据量很大，慎用 order by 。<br /> 可以在凌晨进行 order by 的操作，因此此时服务器访问量很低。<br /> 以前很多网站凌晨关闭，其一个目的就是整理数据。</li></ul><h3 id="使用计算字段">使用计算字段</h3><p>当我们需要对数据进行<strong>转换</strong>、<strong>计算</strong>或<strong>格式化</strong>时，往往直接在数据库检索时就完成这些操作。<br /> 而不是先检索出原始数据，然后在客户机应用程序中对数据进行操作。</p><p>比如数据库中存储了员工的月薪，现在需要检索年薪。<br /> 那么我们会直接在检索时就完成月薪 *12 的操作。<br /> 而不是先检索拿到月薪，然后在应用程序中完成 *12 。</p><ul><li>计算字段并不实际存在于数据库表，而是临时数据。</li><li>Sql 允许 select 子句中出现 + , - , * , / 以及列名和常数的表达式</li><li>拼接字段 || , concat()<ul><li>拼接字符串</li><li><code class="language-plaintext highlighter-rouge">select 'my name is ' || ename from emp;</code>等价于<br /> <code class="language-plaintext highlighter-rouge">select concat('my name is ',ename) from emp;</code><br /> 结果<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  'MYNAMEIS'||ENAME
  ---------------------
  my name is SMITH
  my name is ALLEN
  my name is WARD
  my name is JONES
  my name is MARTIN
</code></pre></div></div></li><li>首选 || ( MySQL 中 || 表示 or ，一般用 concat() )</li></ul></li><li>数学计算<ul><li>通过月薪计算年薪。 <code class="language-plaintext highlighter-rouge">select ename , sal*12 as "年薪" from emp;</code></li><li>做数学计算时一定要注意，100 + null 的结果是 <strong>null</strong></li></ul></li></ul><h3 id="通用函数-nvl">通用函数 nvl</h3><p>Sql 中允许列值为空，空值用保留字 NULL 表示。<br /> NULL 不同于 0 或者空格，它就是代表了一个不确定的内容。<br /> 任何含有 null 值的数学表达式最后的结果都为空值。</p><p>当进行数学计算时，我们希望能够把 null 视为 0 。<br /> 此时就需要使用 nvl 函数。</p><p>nvl ( arg1 , arg2 )</p><ul><li>如果 arg1 为 null ，返回 arg2 。</li><li>如果 arg1 不为 null，返回 arg1 。</li></ul><p>现有该语句：<br /> <code class="language-plaintext highlighter-rouge">select ename , (sal+comm) * 12 as "annual salary" from emp;</code><br /> ename 是员工名字，sal 是月薪，comm 是月度津贴，现需要计算年薪。<br /> 但是因为有部分员工的 comm 是 null，所以计算结果如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ENAME              年薪
---------- ----------
SMITH      
ALLEN           22800
WARD            21000
JONES      
MARTIN          31800
BLAKE      
</code></pre></div></div><p>此时我们想要将 null 视为 0 。<br /> <code class="language-plaintext highlighter-rouge">select ename , (sal + nvl(comm ,0)) * 12 as "annual salary" from emp;</code><br /> 结果正常</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ENAME      annual salary
---------- -------------
SMITH               9600
ALLEN              22800
WARD               21000
JONES              35700
MARTIN             31800
</code></pre></div></div><h3 id="并集全集交集差集">并集，全集，交集，差集</h3><p>在下文中使用 A , B 代指：</p><ul><li>A = <code class="language-plaintext highlighter-rouge">select * from table1 where 条件1</code></li><li>B = <code class="language-plaintext highlighter-rouge">select * from table2 where 条件2</code></li></ul><p>集合类型</p><ul><li>并集 <code class="language-plaintext highlighter-rouge">A union B;</code><br /> 将两个集合中的所有数据都进行显示，<strong>去重</strong></li><li>全集 <code class="language-plaintext highlighter-rouge">A union all B;</code><br /> 将两个集合的数据全部显示，<strong>不去重</strong></li><li>交集 <code class="language-plaintext highlighter-rouge">A intersect B;</code><br /> 两个集合中交叉的数据集，只显示一次</li><li>差集 <code class="language-plaintext highlighter-rouge">A minus B;</code><br /> 包含在A集合而不包含在B集合中的数据，跟A和B的集合顺序相关</li></ul><h3 id="查看表">查看表</h3><ul><li><code class="language-plaintext highlighter-rouge">Select * from tab;</code><br /> 查看用户下的所有表</li><li><code class="language-plaintext highlighter-rouge">Select * from user_tables;</code><br /> 详细查询当前用户下的所有表</li><li><code class="language-plaintext highlighter-rouge">desc 表名;</code> 或 <code class="language-plaintext highlighter-rouge">describe dept;</code><br /> 查看表结构</li><li><code class="language-plaintext highlighter-rouge">select table_name from user_tables; </code><br /> 查看所有表</li><li><code class="language-plaintext highlighter-rouge">comment on table emp is ‘雇员表';</code><br /> 为表添加注释</li><li><code class="language-plaintext highlighter-rouge">comment on column emp.Empno is '雇员工号';</code><br /> 为列添加注释</li></ul><h3 id="注意">注意</h3><p>SQL 中关系运算符的优先级：not &gt; and &gt; or<br /> 当在同一条语句中使用不同的运算符时，最好用 () 括起来。<br /> 保证语句的执行顺序，减少出错概率。</p><p>SQL 中的单行注释为 <code class="language-plaintext highlighter-rouge">--</code></p><h3 id="相关优化">相关优化</h3><ul><li>AND: 把检索结果较少的条件放到后面</li><li>OR: 把检索结果较多的条件放到后面</li></ul><h2 id="sql-函数">SQL 函数</h2><p>函数一般是在数据上执行的，它给数据的转换和处理提供了方便。<br /> 函数只是将取出的数据进行处理，不会改变数据库中的值。<br /> <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/function.png" alt="image" /></p><p>Sql函数可以分为组函数和单行函数。</p><ul><li>组函数又被称作聚合函数，用于对<strong>多行数据</strong>进行操作，并返回一个<strong>单一</strong>的结果<br /> 组函数仅可用于<strong>选择列表</strong>或查询的 <strong>having</strong> 子句</li><li>单行函数对<strong>单个数值</strong>进行操作，并返回一个值。 <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/functiontype.png" alt="image" /></li></ul><h3 id="oracle-函数大全">oracle 函数大全</h3><p><a href="https://github.com/kekaiyuan/resource/blob/main/API/oracle%E5%87%BD%E6%95%B0%E5%A4%A7%E5%85%A8.chm">oralce 函数大全</a></p><h3 id="单行函数">单行函数</h3><h4 id="分类">分类</h4><p><img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/singlefunction.png" alt="image" /></p><p>在oracle中存在数值的隐式转换和显式转换</p><p>隐式转换指的是字符串可以转换为数值或者日期</p><p>而显式转换则是使用 oracle 的转换函数</p><h4 id="单行函数的嵌套">单行函数的嵌套</h4><ul><li>单行函数可被嵌入到任何层</li><li>嵌套函数从最深层到最低层求值 <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/nest.png" alt="image" /></li></ul><h3 id="组函数">组函数</h3><p>组函数基于多行数据返回单个值</p><h4 id="常用的组函数">常用的组函数</h4><ul><li>avg()<br /> 返回某列的平均值</li><li>min()<br /> 返回某列的最小值</li><li>max()<br /> 返回某列的最大值</li><li>sum()<br /> 返回某列值的和</li><li>count()<br /> 返回某列的行数</li></ul><h4 id="用法">用法</h4><ul><li>AVG and SUM 适用于<strong>数字</strong>类型数据</li><li>MIN and MAX 适用于<strong>任何</strong>数据类型</li><li>COUNT 返回某列的行数，默认统计所有行，如果需要统计不重复的行，使用 distinct 关键字<br /> <code class="language-plaintext highlighter-rouge">select count(distinct deptno) from emp;</code></li><li>COUNT 一般用来获取表中的记录条数，获取条数的时候可以使用 * 或者某一个具体的列<br /> 甚至可以使用纯数字来代替，但是从运行效率的角度考虑，建议使用数字或者某一个具体的列，而不要使用 *<ul><li><del>count ( * )</del></li><li>count (1)</li><li>count (arg)<br /> 最好使用主键的列名，因为 count 会跳过空值，而主键是非空的。</li></ul></li><li>组函数一律<strong>跳过空值</strong>，如果需要将空值代入计算，使用 NVL 函数。</li></ul><h4 id="数据分组">数据分组</h4><p>组函数处理的是 “一组数据”，如果没有分组操作的话，组函数处理的是整张表。<br /> 例如<code class="language-plaintext highlighter-rouge">select avg(sal) from emp;</code>输出是整张表的所有 sal 的平均值。</p><p>但加入分组操作后<br /> <code class="language-plaintext highlighter-rouge">select avg(sal) from emp group by deptno;</code><br /> 该语句会将 deptno 相同的行归为一组，然后分别求每个组的 sal 的平均值。</p><h5 id="步骤">步骤</h5><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT column, group_function
FROM table
[WHERE condition] 
[GROUP BY group_by_expression] 
[ORDER BY column];
[having condition]
</code></pre></div></div><p>使用 group by 子句将表分成小组<br /> 结果集<strong>隐式</strong>按<strong>降序</strong>排列，如果需要改变排序方式可以使用 order by 子句</p><ul><li><strong>创建分组</strong><ul><li>group by 子句。<ul><li><code class="language-plaintext highlighter-rouge">group by arg1</code><br /> 按照 arg1 进行分组，arg1 相同的为一组</li></ul></li><li>group by 子句可以包含任意数目的列。<ul><li><code class="language-plaintext highlighter-rouge">group by arg1 , arg2</code><br /> 按照 arg1 和 arg2 进行分组，arg1 相同并且 arg2 也相同的为一组</li><li>除组函数语句外，select 语句中的每个列都必须在 group by 子句中给出。</li></ul></li><li>如果分组列中具有 null 值，则 null 将作为一个分组返回。如果列中有多行 null 值，他们将分为一组。</li><li>group by 子句必须出现在 where 子句之后，order by 子句之前。</li></ul></li><li><strong>过滤分组</strong>（ having 子句)<ul><li>where 过滤行，having 过滤分组。</li><li>having 支持所有 where 操作符。</li></ul></li><li><strong>分组和排序</strong><ul><li>一般在使用 group by 子句时，应该也给出 order by 子句。</li></ul></li></ul><h5 id="注意-1">注意</h5><ul><li><strong>出现在 select 列表中的字段，如果出现的位置不是在组函数中，那么必须出现在 group by 子句中</strong><ul><li><code class="language-plaintext highlighter-rouge">select deptno,avg(sal) from emp group by deptno</code><br /> 该语句合法，select 列表中有两个字段：deptno 和 sal - deptno 字段出现在 group by 子句中 - sal 出现在组函数 avg() 中</li><li><code class="language-plaintext highlighter-rouge">select deptno,avg(sal),ename from emp group by deptno</code><br /> 该语句不合法，无法执行。 因为 ename 字段即不存在于 group by 子句中，也不存在于组函数中。</li></ul></li><li><strong>group by 列可以不在 select 列表中</strong><ul><li><code class="language-plaintext highlighter-rouge">select avg(sal) from emp group by deptno</code><br /> group by 子句中的 deptno 不在 select 列表中</li></ul></li><li><strong>不能在 where 子句中使用组函数。不能在 where 子句中限制组。使用 having 对分组进行限制。</strong><ul><li>where 子句只能使用表中存在的数据。<br /> 组函数只是将取出的数据进行了一系列的处理，但是并没有写回数据库，所以 where 子句无法使用。<br /> 如果需要将组函数处理的结果作为判断依据，使用 having 子句。</li><li>例如现在有语句<code class="language-plaintext highlighter-rouge">select avg(sal) from emp group by deptno;</code><br /> 想要输出 avg(sal) &gt; 1000 的分组<ul><li><code class="language-plaintext highlighter-rouge">select avg(sal) from emp group by deptno where avg(sal) &gt; 1000</code><br /> 该语句错误，where 子句无法使用组函数处理的结果</li><li><code class="language-plaintext highlighter-rouge">select avg(sal) from emp group by deptno having avg(sal) &gt; 1000</code><br /> 该语句正确，使用 having 子句对分组进行限制。</li></ul></li><li>where 子句和 having 子句都可用于执行判断操作。<ul><li>where 子句只能使用表中存在的属性，而不能使用组函数。</li><li>having 子句可以使用组函数。</li></ul></li></ul></li><li><strong>组函数仅在 <em>选择列表</em> 和 <em>having</em> 子句中有效。</strong></li></ul><h2 id="select-子句顺序">select 子句顺序</h2><table><thead><tr><th>子句</th><th>说明</th><th>是否必须使用</th></tr></thead><tbody><tr><td>select</td><td>要返回的列或表达式</td><td>是</td></tr><tr><td>from</td><td>从中检索数据的表</td><td>仅在从表选择数据时使用</td></tr><tr><td>where</td><td>行级过滤</td><td>否</td></tr><tr><td>group by</td><td>分组说明</td><td>仅在按组计算聚集时使用</td></tr><tr><td>having</td><td>组级过滤</td><td>否</td></tr><tr><td>order by</td><td>输出排序顺序</td><td>否</td></tr></tbody></table><p><strong>Sql语句执行过程：</strong></p><ol><li>读取 <strong>from</strong> 子句中的基本表、视图的数据，[执行笛卡尔积操作]。</li><li>选取满足 <strong>where</strong> 子句中给出的条件表达式的元组</li><li>按 <strong>group</strong> 子句中指定列的值分组，同时提取满足 <strong>having</strong> 子句中组条件表达式的那些组</li><li>按 <strong>select</strong> 子句中给出的列名或列表达式求值输出</li><li><strong>order by</strong> 子句对输出的目标表进行排序。</li></ol><h2 id="多表查询">多表查询</h2><p>有时我们需要读取多个表中的数据</p><p>现有表 employee ，其中有雇员的ID，名字，部门ID<br /> <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/employee.png" alt="image" /></p><p>有表 department ，其中有部门的ID，名字，地点 <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/department.png" alt="image" /></p><p>现需查询雇员的ID以及雇员的部门名字。<br /> 这分别在两张表上。<br /> 此时需要将两张表合并。<br /> <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/employee-department.png" alt="image" /></p><h3 id="1992语法">1992语法</h3><p>92语法共有五种连接方式：</p><ul><li>等值连接</li><li>非等值连接</li><li>外连接</li><li>自连接</li><li>笛卡尔积</li></ul><p>下文将通过表A和表B说明五种连接的区别。</p><p>表 A</p><table><thead><tr><th>X</th><th>Y</th><th>S</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>2</td></tr><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>1</td><td>2</td><td>4</td></tr></tbody></table><p>表 B</p><table><thead><tr><th>S</th><th>Z</th></tr></thead><tbody><tr><td>3</td><td>3</td></tr><tr><td>4</td><td>4</td></tr><tr><td>5</td><td>5</td></tr></tbody></table><h4 id="等值连接">等值连接</h4><p>根据 <strong>where子句</strong> 中的等式连接两张表</p><p>例：<code class="language-plaintext highlighter-rouge">select * from A,B where A.S = B.S;</code></p><table><thead><tr><th>A.X</th><th>A.Y</th><th>A.S</th><th>B.S</th><th>B.Z</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td></tr><tr><td>1</td><td>2</td><td>4</td><td>4</td><td>4</td></tr></tbody></table><ul><li>语法规则：<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  SELECT table1.column, table2.column
  FROM table1, table2
  WHERE table1.column1 = table2.column2;
</code></pre></div></div><p>将 table1 中的 column1 与 table2 中的 column2 相等的记录连接到一起。</p></li><li>一般而言 column1 为 table1 的<strong>外键</strong>，column2 为 table2 的<strong>主键</strong>。</li></ul><h4 id="非等值连接">非等值连接</h4><p>使用 &lt; , &gt; , &lt;= , &gt;= , != , between and 等关系符号连接时称为非等值连接</p><p>例：<code class="language-plaintext highlighter-rouge">select * from A,B where A.S &gt; B.S;</code></p><table><thead><tr><th>A.X</th><th>A.Y</th><th>A.S</th><th>B.S</th><th>B.Z</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>4</td><td>3</td><td>3</td></tr></tbody></table><p>表A只有记录 (1,2,4) 中的S大于表B中记录 (3,3) 中的S</p><h4 id="外连接">外连接</h4><p>在前两种连接中，如果表中存在无法连接的记录，该记录会被舍弃。</p><p>为了在操作时能保持这些将被舍弃的元组，提出了外连接的概念，使用外连接可以看到不满足连接条件的记录。</p><ul><li>外连接运算符是 (+)</li><li>有左外连接和右外连接</li></ul><h5 id="左外连接">左外连接</h5><p>显示左表的全部数据<br /> 在<strong>右表</strong>添加 (+)</p><p><code class="language-plaintext highlighter-rouge">select * from A,B where A.S = B.S(+);</code></p><table><thead><tr><th>A.X</th><th>A.Y</th><th>A.S</th><th>B.S</th><th>B.Z</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>2</td><td> </td><td> </td></tr><tr><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td></tr><tr><td>1</td><td>2</td><td>4</td><td>4</td><td>4</td></tr></tbody></table><h5 id="右外连接">右外连接</h5><p>显示右表的全部数据<br /> 在<strong>左表</strong>添加 (+)</p><p><code class="language-plaintext highlighter-rouge">select * from A,B where A.S(+) = B.S;</code></p><table><thead><tr><th>A.X</th><th>A.Y</th><th>A.S</th><th>B.S</th><th>B.Z</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td></tr><tr><td>1</td><td>2</td><td>4</td><td>4</td><td>4</td></tr><tr><td> </td><td> </td><td> </td><td>5</td><td>5</td></tr></tbody></table><h4 id="自连接">自连接</h4><p>和自己进行连接</p><p><code class="language-plaintext highlighter-rouge">select * from A A1,A A2 where A1.Y = A2.S;</code></p><table><thead><tr><th>A1.X</th><th>A1.Y</th><th>A1.S</th><th>A2.X</th><th>A2.Y</th><th>A2.S</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>1</td><td>2</td><td>3</td><td>1</td><td>2</td><td>2</td></tr><tr><td>1</td><td>2</td><td>4</td><td>1</td><td>2</td><td>2</td></tr></tbody></table><h4 id="笛卡尔积">笛卡尔积</h4><p>当连接时不指定连接方式时，将默认进行笛卡尔积计算。</p><p>将左表的每一条记录和右表的每一条记录进行连接。</p><p>检索出的行的数目将是左表的行数<strong>乘以</strong>右表的行数<br /> 检索出的列的数目将是左表的列数<strong>加上</strong>右表的列数</p><p><code class="language-plaintext highlighter-rouge">select * from A,B;</code></p><table><thead><tr><th>A.X</th><th>A.Y</th><th>A.S</th><th>B.S</th><th>B.Z</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>2</td><td>3</td><td>3</td></tr><tr><td>1</td><td>2</td><td>2</td><td>4</td><td>4</td></tr><tr><td>1</td><td>2</td><td>2</td><td>5</td><td>5</td></tr><tr><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td></tr><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>4</td></tr><tr><td>1</td><td>2</td><td>3</td><td>5</td><td>5</td></tr><tr><td>1</td><td>2</td><td>4</td><td>3</td><td>3</td></tr><tr><td>1</td><td>2</td><td>4</td><td>4</td><td>4</td></tr><tr><td>1</td><td>2</td><td>4</td><td>5</td><td>5</td></tr></tbody></table><h4 id="注意-2">注意</h4><ul><li>连接时可以给表起别名，方便操作。<br /> 有时必须使用别名<ul><li>自连接</li><li>不同的表中有同名列</li></ul></li><li>可以连接两张以上的表，但是要注意设置连接条件。<br /> 多表连接几乎不使用笛卡尔积连接，因为生成的数据太多。<br /> 当有 n 张表进行连接时，至少需要 n-1 个条件，否则一定会发生笛卡尔积。</li></ul><h3 id="1999语法">1999语法</h3><p>在 92语法 中，多张表的连接条件放在 where子句 中，同时 where子句 需要对表进行条件过滤。</p><p>where子句 需要完成两个功能，这就使得 92语法 中的 where子句 格外的臃肿。</p><p>1999语法 解决了这个问题，并且提出了一些新的连接方式。</p><h4 id="语法规则">语法规则</h4><p>99语法 中共有<strong>八种</strong>连接方式，其中有部分连接原理等同于 92语法 。<br /> 只是为了方便书写，更改了书写方式。</p><ul><li>交叉连接</li><li>自然连接</li><li>on子句</li><li>using子句</li><li>左外连接</li><li>右外连接</li><li>全外连接</li><li>内连接</li></ul><p>使用三个表来说明 99语法 的连接方式。</p><p>表 A</p><table><thead><tr><th>X</th><th>Y</th><th>S</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>2</td></tr><tr><td>1</td><td>2</td><td>3</td></tr><tr><td>1</td><td>2</td><td>4</td></tr></tbody></table><p>表 B</p><table><thead><tr><th>S</th><th>Z</th></tr></thead><tbody><tr><td>3</td><td>3</td></tr><tr><td>4</td><td>4</td></tr><tr><td>5</td><td>5</td></tr></tbody></table><p>表 C</p><table><thead><tr><th>S</th><th>Y</th><th>Z</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>3</td></tr><tr><td>4</td><td>2</td><td>5</td></tr><tr><td>6</td><td>2</td><td>7</td></tr></tbody></table><h4 id="交叉连接">交叉连接</h4><p><code class="language-plaintext highlighter-rouge">select * from table1 cross join table2;</code><br /> 等同于 92语法 的笛卡尔积。 将左表的每一行和右表的每一行都进行连接。</p><h4 id="自然连接">自然连接</h4><p><code class="language-plaintext highlighter-rouge">select * from table1 natural join table2;</code></p><ul><li>NATURAL JOIN子句基于两个表中列名完全相同的列产生连接<ul><li>两个表有相同名字的列</li><li>数据类型相同</li><li>从两个表中选出连接列的值相等的所有行</li></ul></li><li>类似于 92语法 中的 <strong>等值连接</strong><br /> 但是 自然连接 会去除<strong>重复</strong>的列，而 等值连接 不会。</li><li><p>自然连接会将两张表中<strong>所有</strong>的同名列作为连接条件。<br /> 例：<code class="language-plaintext highlighter-rouge">select * from A natrual join C;</code></p><table><thead><tr><th>Y</th><th>S</th><th>A.X</th><th>C.Z</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>1</td><td>3</td></tr><tr><td>2</td><td>4</td><td>1</td><td>5</td></tr></tbody></table></li><li>当两张表中没有列名相同的列时，做<strong>笛卡尔积</strong>。</li></ul><h4 id="on-子句">on 子句</h4><ul><li>自然连接的条件是基于表中所有同名列的等值连接</li><li>为了设置任意的连接条件或者指定连接的列，需要使用ON子句</li><li>连接条件与其它的查询条件分开书写</li><li>使用ON 子句使查询语句更容易理解</li><li><p>包括等值连接和非等值连接</p></li><li><code class="language-plaintext highlighter-rouge">select * from table1 join table2 on table1.column1 = table2.column2;</code><br /> 等同于 92语法 的等值连接</li><li><code class="language-plaintext highlighter-rouge">select * from table1 join table2 on table1.column1 &gt; table2.column2;</code><br /> 等同于 92语法 的非等值连接</li></ul><h5 id="使用-on子句-实现两张以上的多表连接">使用 on子句 实现两张以上的多表连接</h5><p><code class="language-plaintext highlighter-rouge">select * from table1 join table2 on 连接条件1 join table3 on 连接条件2;</code></p><h4 id="using-子句">using 子句</h4><p>using子句 和 on子句 一样，都可以表示连接条件<br /> <code class="language-plaintext highlighter-rouge">select * from table1 join table2 using(column1);</code><br /> 等同于<code class="language-plaintext highlighter-rouge">select * from table1 join table2 on table1.column1 = table2.column1;</code><br /></p><h5 id="注意-3">注意</h5><ul><li>using子句 的连接条件是同名列，而且不能使用表名或别名进行修饰。<br /> <del><code class="language-plaintext highlighter-rouge">select * from table1 join table2 using(table1.column1);</code></del><br /> 该语句是错误的。</li><li>using子句 类似于自然连接，使用同名列进行连接，同样地会去除重复的同名列。<br /> 而 on子句 不会去除重复的同名列。</li><li><p>当两张表存在 n 个同名列时，自然连接会将所有的同名列进行连接。<br /> 而 using子句 则根据指定的同名列进行连接。<br /> 例：<code class="language-plaintext highlighter-rouge">select * from A join C using(S);</code></p><table><thead><tr><th>S</th><th>A.X</th><th>A.Y</th><th>C.Y</th><th>C.Z</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>2</td><td>2</td><td>3</td></tr><tr><td>4</td><td>1</td><td>2</td><td>2</td><td>5</td></tr></tbody></table><p><code class="language-plaintext highlighter-rouge">select * from A join C using(S,Y);</code></p><table><thead><tr><th>Y</th><th>S</th><th>A.X</th><th>C.Z</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>1</td><td>3</td></tr><tr><td>2</td><td>4</td><td>1</td><td>5</td></tr></tbody></table></li></ul><h4 id="外连接-1">外连接</h4><h5 id="左外连接-1">左外连接</h5><p><code class="language-plaintext highlighter-rouge">select * from table1 left outer join table2 on 连接条件;</code><br /> 等同于 92语法 的左外连接。<br /> 返回所有左边表中的行，即使在右边的表中没有可对应的列值。</p><h5 id="右外连接-1">右外连接</h5><p><code class="language-plaintext highlighter-rouge">select * from table1 right outer join table2 on 连接条件;</code><br /> 等同于 92语法 的右外连接。<br /> 返回所有右边表中的行，即使在左边的表中没有可对应的列值。</p><h5 id="全外连接">全外连接</h5><p>99语法 的新特性<br /> 能显示左表和右表的全部数据，兼顾了左外连接和右外连接。<br /></p><p><code class="language-plaintext highlighter-rouge">select * from table1 full outer join table2 on 连接条件;</code></p><p>例：<code class="language-plaintext highlighter-rouge">select * from A full outer join B on A.S = B.S;</code></p><table><thead><tr><th>A.X</th><th>A.Y</th><th>A.S</th><th>B.S</th><th>B.Z</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>3</td><td>3</td></tr><tr><td>1</td><td>2</td><td>4</td><td>4</td><td>4</td></tr><tr><td> </td><td> </td><td> </td><td>5</td><td>5</td></tr><tr><td>1</td><td>2</td><td>2</td><td> </td><td> </td></tr></tbody></table><h4 id="内连接">内连接</h4><p><code class="language-plaintext highlighter-rouge">select * from table1 inner join table2 on 连接条件;</code><br /> 等同于<code class="language-plaintext highlighter-rouge">select * from table1 join table2 on 连接条件;</code></p><p>没有什么特殊意义，on子句 默认就是内连接。</p><h3 id="总结">总结</h3><p>在实际开发中，92语法 和 99语法 都能够运行，并没有限制。</p><p>但是最好使用 <strong>99语法</strong> 。</p><p>因为 99语法 更美观，功能更强大。</p><h2 id="子查询">子查询</h2><p>嵌套在其他 sql 语句中的完整 sql 语句，可以称之为子查询。</p><p>理解子查询的关键在于把子查询当作一张表来看待。<br /> 外层的语句可以把内嵌的子查询返回的结果当成一张表使用。</p><ul><li>子查询要用括号括起来</li><li>将子查询放在比较运算符的右边（增强可读性）</li></ul><h3 id="子查询的种类">子查询的种类</h3><p>按照子查询返回的记录数，子查询可以分为单行子查询和多行子查询：</p><ul><li>单行子查询<br /> <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/single-subquery.png" alt="image" /></li><li>多行子查询<br /> <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/multi-subquery.png" alt="image" /></li></ul><h4 id="单行子查询">单行子查询</h4><ul><li>子查询返回一行记录</li><li>使用单行记录比较运算符 <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/single-subquery-operator.png" alt="image" /></li></ul><p>案例：<br /> 查询有哪些人的薪水是在整个雇员的平均薪水之上的：</p><ul><li>首先求所有雇员的平均薪水<br /> <code class="language-plaintext highlighter-rouge">select avg(sal + nvl(comm, 0)) from emp</code></li><li>然后求：<br /><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  select ename, empno, sal, sal + nvl(comm, 0)
    from emp
   where sal + nvl(comm, 0) &gt; (select avg(sal + nvl(comm, 0)) from emp);
</code></pre></div></div></li><li>此处嵌套的子查询在外层查询处理之前执行</li></ul><h4 id="多行子查询">多行子查询</h4><ul><li>子查询返回多行行记录</li><li>使用集合比较运算符 <img src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/images/posts/database/oracle/query/multi-subquery-operator.png" alt="image" /></li></ul><p>使用方法：</p><ul><li>在多行子查询中使用 <strong>in</strong><br /> <strong>例</strong>：我们要查在雇员中有哪些人是经理人<br /> 也就是说，有哪些人的empno号在mgr这个字段中出现过<br /> 这个时候，应当首先查询mgr中有哪些号码<br /> 然后再看看有哪些人的雇员号码在此出现：<br /> <code class="language-plaintext highlighter-rouge">select empno, ename from emp where empno in (select distinct mgr from emp);</code></li><li>在多行子查询中使用 <strong>some all</strong><br /> <strong>例</strong>：找出部门编号为20的所有员工中收入最高的职员<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  select *
    from emp
   where sal &gt;= all (select sal from emp where deptno = 20)
     and deptno = 20;
</code></pre></div></div></li><li>在 <strong>from子句</strong> 中使用子查询<br /> <strong>例</strong>：我们要求每个部门平均薪水的等级。<br /> 可以这样考虑，首先将每个部门的平均薪水求出来，然后把结果当成一张表。<br /> 再用这张结果表和salgrade表做连接，以此求得薪水等级。<ul><li>先求出每个部门平均薪水的表 t 。</li><li>将 t 和 salgrade 进行关联查询就可以了。</li><li><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select *
  from salgrade s,
       (select deptno, avg(sal) avg_sal from emp group by deptno) t
 where t.avg_sal between s.losal and s.hisal;

</code></pre></div></div></li></ul></li></ul><h2 id="限制输出">限制输出</h2><p>现在有这样一个问题：输出薪水最高的<strong>5个</strong>人，怎么做？</p><p>这就需要我们限制输出的数量。</p><p>在 MySQL 中，限制输出的关键字是 <strong>limit</strong> ，非常的见名知意，而且使用非常的<strong>简单方便</strong>。</p><p>但是在 oracle 中，限制输出的关键字是 <strong>rownum</strong> ，这个的使用比较<strong>繁琐</strong>。</p><p>rownum 指的是行号，在 oracle 中，每一条数据都有对应的行号，我们需要显式地使用行号来完成限制输出的功能。</p><p>注意：rownum 不能直接使用，需要<strong>嵌套</strong>使用。</p><h3 id="输出工资最高的5个人">输出工资最高的5个人</h3><p><code class="language-plaintext highlighter-rouge">select * from (select * from emp order by sal desc) where rownum &lt;= 5;</code></p><p>为什么说 rownum 必须<strong>嵌套</strong>使用？</p><ul><li>如果这样使用<br /> <code class="language-plaintext highlighter-rouge">select * from emp where rownum&lt;=5 order by sal desc;</code> 这条语句的执行顺序是：<strong>先查询</strong> emp 表中的前5条数据，<strong>然后排序</strong>。<br /> 这样显然是错的。</li><li>而<code class="language-plaintext highlighter-rouge">select * from (select * from emp order by sal desc) where rownum &lt;= 5;</code><br /> 的执行顺序是：先将 emp 表按照工资<strong>降序</strong>，然后<strong>输出</strong>前5条数据。<br /> 这样的结果才是正确的。</li><li>因为我们必须先将<strong>数据</strong>处理好，然后再限制<strong>输出</strong>。<br /> 如果不嵌套的话，那么结果是先限制<strong>输出</strong>，再处理<strong>数据</strong>。</li></ul><h3 id="输出工资最高的第6到10名的人">输出工资最高的第6到10名的人</h3><p>在 oracle 中，rownum 只能 &lt; 或 &lt;= 某个值，而不能 &gt; 或 &gt;= 某个值</p><p><code class="language-plaintext highlighter-rouge">select * from (select * from emp order by sal desc) where rownum &gt; 5;</code><br /> 的执行结果是<strong>空表</strong>。</p><p>这是因为 rownum 指的是行号，它是动态改变的。</p><p>我们使用<code class="language-plaintext highlighter-rouge">rownum &gt; 5</code>是为了去除前5条语句。 而 oracle 的原理是</p><p><code class="language-plaintext highlighter-rouge">rownum &gt; 5</code>的执行流程：</p><ul><li>去除前5条语句。</li><li><strong>更新</strong>语句的 rownum。<ul><li>类似于现实中的排队。<br /> 你排在第六位。<br /> 前五位走了，你就是第一位。</li></ul></li><li>重新执行。</li></ul><p>只有当 <code class="language-plaintext highlighter-rouge">rownum &gt;= 0</code> 时才不会输出空表，但是这毫无意义。</p><p>那么这个问题如何实现呢？</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>select *
  from (select e1.*, rownum rn from (select * from emp order by sal desc) e1)
 where rn &gt; 5
   and rn &lt;= 10;
</code></pre></div></div><p><strong>把 rownum 加入表中成为属性。</strong></p><p><strong>注意：</strong><br /> <code class="language-plaintext highlighter-rouge">select * , rownum rn</code>会报错<br /> 必须使用<code class="language-plaintext highlighter-rouge">select e1.*, rownum rn</code></p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://kekaiyuan.github.io/" target="_blank">Kaiyuan Ke</a></li><li>本文链接：<a href="https://kekaiyuan.github.io//2021/06/28/sql-query/" target="_blank">https://kekaiyuan.github.io//2021/06/28/sql-query/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/06/28/sql-query/', clientID: '', clientSecret: '', repo: '', owner: '', admin: [''], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:350px" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:16px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://kekaiyuan.github.io//assets/search_data.json?v=1646200238', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Kaiyuan Ke">Kaiyuan Ke</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/kekaiyuan/kekaiyuan.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://kekaiyuan.github.io//" title="首页" target="">首页</a></li><li> <a href="https://kekaiyuan.github.io//categories/" title="分类" target="">分类</a></li><li> <a href="https://kekaiyuan.github.io//archives/" title="归档" target="">归档</a></li><li> <a href="https://kekaiyuan.github.io//wiki/" title="维基" target="">维基</a></li><li> <a href="https://kekaiyuan.github.io//links/" title="链接" target="">链接</a></li><li> <a href="https://kekaiyuan.github.io//about/" title="关于" target="">关于</a></li><li><a href="https://kekaiyuan.github.io//feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
