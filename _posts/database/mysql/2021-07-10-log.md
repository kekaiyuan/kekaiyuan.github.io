---
layout: post
title: MySQL 之——日志
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermain: true
---




WAL技术（Write-Ahead Logging）。先写日志，再写磁盘。


## Redo Log
Redo Log 是 InnoDB 专有的日志文件。

当发生数据修改的时候，innodb引擎会先将记录写到 Redo Log中，并更新内存，此时更新就算是完成了，同时innodb引擎会在合适的时机将记录操作到磁盘中



有了 Redo Log之后，innodb就可以保证即使数据库发生异常重启，之前的记录也不会丢失，叫做crash-safe


### Redo Log 是如何保证事务持久化
一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。

即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态。

MySQL 通过 WAL(**W**rite **A**head **L**og) 技术来保证事务的持久性，即**先写日志**，**再写磁盘**。
1. 在修改数据之前，先把更新后的值写入 Redo Log 中。
2. Redo Log 写入完毕后，再去修改数据。
3. 当系统突然崩溃重启时，根据 Redo Log 中的值进行数据恢复。


----------

Q：Redo Log 在磁盘中，数据库也在磁盘中，为什么不直接更新数据库？

> 先讲个故事：
> 
> 小柯和小王都有一本书，叫 **《数据库》**。
> 有一天，他们想把 **《数据库》** 中所有的英文单词都变成大写。
> 
> 因为不知道哪一页哪一行有英文单词，所以他们需要把 **《数据库》** 从头到尾读一遍，找到存在的英文单词。
> 任务量也很大，有**很多**英文单词需要改。
> 
> 小王从早上改到下午，没改完，这时一个小伙伴约小王出去玩。
> 当小王玩到晚上回来后，小王把这件事忘得一干二净。
> 于是小王的是烂尾工程。
> 
> 小柯也遇到了和小王一样的问题。
> 但他有一本私人珍藏 **《日志》** 。
>  **《日志》** 也很厚，小柯不知道  **《日志》** 中哪一页哪一行有什么。
>  但他直接翻开  **《日志》** 的最后一页，在最后一行写下了：
>  “把所有英文单词改成大写。”
>  并在这句话后面打了个 × 。
> 
> 小柯从早上改到下午，没改完，这时也有一个小伙伴约小柯出去玩。
> 当小柯玩到晚上回来后，也把这件事忘得一干二净。
> 但是小柯有个好习惯，回家后先看  **《日志》** 。
> 他看到了：“把所有英文单词改成大写。”和这句话后面的 × 。
> 他想起来了，他白天没做完的事是什么。
> 于是他接着做，成功完成了任务。
 
现在把故事映射到计算机中：
随机 I/O :<br>
指读写操作时间连续，但访问地址不连续，随机分布在磁盘的地址空间中。<br>
就像小柯和小王的  **《数据库》** 中哪里都可能有英文单词一样，是随机分布的。

顺序 I/O :<br>
顺序 I/O 是指读写操作的访问地址连续。<br>
在故事中小柯只是写下了 1 条日志，但如果小柯要写 10 条日志也好，100 条日志也好，都只需要顺着往下写，前面的内容跟他没关系。

1. 修改数据是 随机 I/O ，写入日志是 顺序 I/O ，随机 I/O 比顺序 I/O 快得多。
	- 随机 I/O ：
		指读写操作时间连续，但访问地址**不连续**，**随机**分布在磁盘的地址空间中。<br>
		就像小柯和小王的  **《数据库》** 中哪里都可能有英文单词一样，是随机分布的。
	- 顺序 I/O ：
		顺序 I/O 是指读写操作的访问地址**连续**。
		在故事中小柯只是写下了 1 条日志，但如果小柯要写 10 条日志也好，100 条日志也好，都只需要顺着往下写，前面的内容跟他没关系。
2. 修改数据很可能需要修改大量的数据，但是写日志却只需要写入很少的数据就可以。
3. 这一点没有体现在故事中，那就是 Redo Log Buffer 和 Redo Log File 都是被划分为一个个 Redo Log Block 的。<br>
	多条 Redo Log 可以存入一个 Block 中，而一个 Block 的大小是 512 字节，刚好是一个扇区的大小。<br><br>
	而修改数据是以页为单位的，页由 2 的 n 次方个扇区组成。<br>
	常见的一页有 4k 大小，有 8 个扇区。<br><br>
	扇区是写入的最小单位，一旦写入，必定成功，不会存在写了一半没写一半的情况存在。<br>
	而页可能会出现只写了几个扇区，剩下几个扇区没写的错误。（理论上的错误，实际上几乎没有）


1. Redo Log 是顺序写的，而数据库是随机写，顺序写的速度要快得多。<br>
	比如说我现在有一本书，叫 **《数据库》**。<br>
	有一天，我想把 **《数据库》** 中所有的英文单词都变成大写。<br>
	我不知道哪一页哪一行有英文单词，所以我需要把整本书从头到尾读一遍，找到存在的英文单词。<br>
	任务量也很大，有**很多**英文单词需要改。<br>
	我从早上改到下午，没改完，这时一个小伙伴约我出去玩。<br>
	当我玩到晚上回来后，我忘了。<br>
	于是这项工作做到一半，是个烂尾工程。
	


----------


	
	另一本书叫 **“重做日志”**。<br>
	有一天，我先把 **“数据库”** 中的所有英文





### 文件结构




InnoDB 使用 ib_logfile 文件存储 Redo Log。

ib_logfile 的文件可以有多个，每一个都是同样的大小。

这些文件组成一个**环状**的结构。

![enter description here](/images/posts/database/mysql/framework-log/ib_logfile.png)



----------
**循环写**

write pos 是写指针，一边写一边向后移动。<br>
当写到最后一个文件的末尾时（例如 ib_logfile3 ），会移动到第一个文件 (ib_logfile0) 的开头。

采用循环写的方式能够控制文件大小，加快读取速度。

----------

**归档**

循环写的方式，就意味着文件大小是**固定**的。<br>
当有新内容写入时，就意味着有旧内容被擦除。<br>

这部分被擦除的内容不应该直接丢弃，毕竟每一份数据都有潜在的价值。<br>
在 MySQL 8.0.17 中添加了 Redo Log 的归档文件，用于保存所有的 Redo Log。

----------

**save point**

前文中已经阐述清楚了**循环写**和**归档**。<br>
为了保证循环写所擦除的内容已经被归档，设置了 save point 指针。

save point 后面的内容是已经归档的，前面的内容尚未归档。<br>
这也就意味着 write pos 永远不能超过 save point ，否则被擦除的内容将永久性地丢失。





疑惑

.既然要避免io，为什么写 Redo Log的时候不会造成io的问题？


----------


日志文件的写入过程<br>
![enter description here](/images/posts/database/mysql/framework-log/innodb.jpg)
在 InnoDB 中，每次 commit 事务后，记录会先写入 InnoDB 的 **Log Buffer** ，这个缓冲区位于内存中的**用户区**。<br>
然后记录会从 Log Buffer 写入 **OS Buffer** ，该缓冲区位于内存中的**内核区**。<br>
最终 OS Buffer 会使用 **fsync() 函数** **同步**内存中所有已修改的文件数据到储存设备。


----------

写入策略<br>
![enter description here](/images/posts/database/mysql/framework-log/buffer.jpg)
1. 每次 commit 直接写入 Log Buffer ，然后每秒写入 OS Buffer，并调用 fsync() 刷到磁盘。
2. 每次 commit 直接写入 OS Buffer ，并调用 fsync() 刷到磁盘。
3. 每次 commit 直接写入 OS Buffer ，然后每秒调用 fsync() 刷到磁盘。

第二种方式最稳定，花费最高。


----------


## Undo Log

Undo Log 实现了事务的原子性。<br>
在 MySQL 数据库 InnoDB 存储引擎中，还用 Undo Log 来实现多版本并发控制 (简称：**MVCC**)。

在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 Undo Log ），然后进行数据的修改。<br>
如果出现了**错误**或者用户执行了 **Rollback** 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。

注意：<br>
Undo Log 是逻辑日志，可以理解为：
- 当 **delete** 一条记录时，Undo Log 中会记录一条对应的 **insert** 记录
- 当 **insert** 一条记录时，Undo Log 中会记录一条对应的 **delete** 记录
- 当 **update** 一条记录时，它记录一条对应**相反**的 update 记录


## Bin Log

Bin Log 是 Server 层的日志，主要做 MySQL 功能层面的事情。

在 MySQL 中，Bin Log 默认是**不开启**的，需要手动开启。

与 Redo Log 的区别:
1. Redo Log 是 InnoDB **独有**的。 <br>
	Bin Log 因为是 Server 层的日志，所以是**所有**引擎都可以使用的。
2. Redo Log 是**物理**日志，记录的是在某个数据页上做了什么修改。<br>
	Bin Log 是**逻辑**日志，记录的是这个语句的原始逻辑。
3. Redo Log 是**循环写**的，空间会用完。<br>
	Bin Log 是**追加写**的，当 Bin Log 文件达到一定大小后写入新的文件，不会覆盖之前的日志信息。

## 备份系统
每个企业都必须实现属于的备份系统，用于用于恢复数据。

一般而言，备份系统会包含以下两个内容：
1. 整库备份
2. 存储一段时间内的所有 Bin Log

恢复数据的流程：
1. 找到最近一次的**全量备份**数据<br>
2. 从备份的时间点开始，将备份的 Bin Log 取出来，重放到要恢复的那个时刻。<br>

例：现在是 2021-7-11-12:38 ，我不小心把数据库删了，如何恢复？
1. 找到离 2021-7-11-12:38 这个时间点最近的备份，假设是 2021-7-11 凌晨 0 点的备份。
2. 从备份系统中取出 2021-7-11-0:00 到 2021-7-11-12:38 的 Bin Log 并执行。

在设计备份系统时，应该考量以下两点：
- 整库备份的周期<br>
	是一天一备还是一周一备？或是……
- 在备份系统中存储多长时间的所有 Bin Log
	- 如果存储的是一周内的所有 Bin Log，那么数据可以恢复到一周内的任意时刻。
	- 如果存储的是两周内的所有 Bin Log，那么数据可以恢复到两周内的任意时刻。
	- ……




## Redo Log 的两阶段提交

数据更新 DML 的流程
![enter description here](/images/posts/database/mysql/framework-log/process.png)

执行流程：
1. 执行器先从引擎中找到数据，如果在内存中直接返回，如果不在内存中，查询后返回。
2. 执行器拿到数据之后会先修改数据，然后调用引擎接口重新吸入数据。
3. 引擎将数据更新到内存，同时写数据到 Redo Log 中，此时的 Redo Log 的状态为 **prepare**，并通知执行器执行完成，随时可以操作。
4. 执行器生成这个操作的 Bin Log 。
5. 执行器调用引擎的事务提交接口，引擎把刚刚写完的 Redo Log 改成 **commit** 状态，更新完成。

----------


Redo Log 的两阶段提交

Redo Log 的提交分为 prepare 和 commit 两个阶段，所以称之为两阶段提交。

为什么必须有“两阶段提交”呢？
如果不使用两阶段提交，假设当前 ID=2 的行，字段 c 的值是 0，使用 update 语句修改该行的字段 c 的值为 1。<br>
当写完第一个日志后，还没有写第二个日志时，发生了 crash 。
1. 先写 Redo Log 后写 Bin Log <br>
	Redo Log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1 。<br>
	但是由于 Bin Log 没写完就 crash 了，所以 Bin Log 中并没有记录这个语句。<br>
	当使用 Bin Log 恢复临时库时，由于缺失了该语句，所以临时库中这一行 c 的值为 0 ，与原库不同。
2. 先写 Bin Log 后写 Redo Log<br>
	由于 Redo Log 还没写，所以崩溃恢复以后这个事务无效，这一行 c 的值是 0 。<br>
	而 Bin Log 中却记录了该语句，所以使用 Bin Log 来恢复时就会多一个事务，这一行 c 的值就是 1 ，与原库不同。
	
可以发现，如果不加入任何机制，单纯地写入 Redo Log 和 Bin Log 。<br>
如果在写入第一个日志后 crash ，两个 Log 恢复的数据库将**不同**。

有了两阶段提交的 **Crash Recovery**

| Bin Log | Redo Log | crash 情况 | 恢复操作 |
| :--: | :--: | :--: | :--: |
| 有记录 | commit | 正常完成的事务 | 不需要恢复 |
| 有记录 | prepare | 在 Bin Log 写完提交事务之前的 crash | 提交事务 |
| 无记录 | prepare | 在 Bin Log 写完之前的 crash | 回滚事务 |
| 无记录 | 无记录 | 在 Redo Log 写之前 crash | 回滚事务 |



----------


