---
layout: post
title: Mysql 之——日志
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermain: true
---

UndoLog 原子性
RedoLog 




Redo日志—innodb存储引擎的日志文件

.当发生数据修改的时候，innodb引擎会先将记录写到 Redo Log中，并更新内存，此时更新就算是完成了，同时innodb引擎会在合适的时机将记录操作到磁盘中

.Redo Log是固定大小的，是循环写的过程

.有了 Redo Log之后，innodb就可以保证即使数据库发生异常重启，之前的记录也不会丢失，叫做crash-safe


![enter description here](/images/posts/database/mysql/framework-log/ Redo log.png)

----------


疑惑

.既然要避免io，为什么写 Redo Log的时候不会造成io的问题？


----------


日志文件的写入过程
![enter description here](/images/posts/database/mysql/framework-log/innodb.jpg)
在 InnoDB 中，每次 commit 事务后，记录会先写入 InnoDB 的 **Log Buffer** ，这个缓冲区位于内存中的**用户区**。<br>
然后记录会从 Log Buffer 写入 **OS Buffer** ，该缓冲区位于内存中的**内核区**。<br>
最终 OS Buffer 会使用 **fsync() 函数** **同步**内存中所有已修改的文件数据到储存设备。


----------

写入策略
![enter description here](/images/posts/database/mysql/framework-log/buffer.jpg)
1. 每次 commit 直接写入 Log Buffer ，然后每秒写入 OS Buffer，并调用 fsync() 刷到磁盘。
2. 每次 commit 直接写入 OS Buffer ，并调用 fsync() 刷到磁盘。
3. 每次 commit 直接写入 OS Buffer ，然后每秒调用 fsync() 刷到磁盘。

第二种方式最稳定，花费最高。


----------


## Undo Log

.Undo Log是为了实现事务的原子性，在Mysql数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制(简称：MVCC)

.在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态

.注意：undo Log是逻辑日志，可以理解为：

–当delete一条记录时，Undo Log中会记录一条对应的insert记录

–当insert一条记录时，Undo Log中会记录一条对应的delete记录

–当update一条记录时，它记录一条对应相反的update记录


----------

## Bin Log



Bin Log 是 Server 层的日志，主要做 Mysql 功能层面的事情

与 Redo Log 的区别:
1. Redo Log 是 InnoDB **独有**的。 <br>
	Bin Log 因为是 Server 层的日志，所以是**所有**引擎都可以使用的。
2. Redo Log 是**物理**日志，记录的是在某个数据页上做了什么修改。<br>
	Bin Log 是**逻辑**日志，记录的是这个语句的原始逻辑。
3. Redo Log 是**循环写**的，空间会用完。<br>
	Bin Log 是**追加写**的，不会覆盖之前的日志信息。


一般在企业中数据库会有备份系统，可以定期执行备份，备份的周期可以自己设置<br>
恢复数据的过程：
1. 找到最近一次的全量备份数据
2. 从备份的时间点开始，将备份的 Bin Log 取出来，重放到要恢复的那个时刻

Bin Log 默认是不开启的，需要手动开启。


## Redo Log 的两阶段提交

数据更新 DML 的流程
![enter description here](/images/posts/database/mysql/framework-log/process.png)

执行流程：
1. 执行器先从引擎中找到数据，如果在内存中直接返回，如果不在内存中，查询后返回。
2. 执行器拿到数据之后会先修改数据，然后调用引擎接口重新吸入数据。
3. 引擎将数据更新到内存，同时写数据到 Redo Log 中，此时的 Redo Log 的状态为 **prepare**，并通知执行器执行完成，随时可以操作。
4. 执行器生成这个操作的 Bin Log 。
5. 执行器调用引擎的事务提交接口，引擎把刚刚写完的 Redo Log 改成 **commit** 状态，更新完成。

----------


Redo Log 的两阶段提交

Redo Log 的提交分为 prepare 和 commit 两个阶段，所以称之为两阶段提交。

为什么必须有“两阶段提交”呢？
如果不使用两阶段提交，假设当前 ID=2 的行，字段 c 的值是 0，使用 update 语句修改该行的字段 c 的值为 1。<br>
当写完第一个日志后，还没有写第二个日志时，发生了 crash 。
1. 先写 Redo Log 后写 Bin Log <br>
	Redo Log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1 。<br>
	但是由于 Bin Log 没写完就 crash 了，所以 Bin Log 中并没有记录这个语句。<br>
	当使用 Bin Log 恢复临时库时，由于缺失了该语句，所以临时库中这一行 c 的值为 0 ，与原库不同。
2. 先写 Bin Log 后写 Redo Log<br>
	由于 Redo Log 还没写，所以崩溃恢复以后这个事务无效，这一行 c 的值是 0 。<br>
	而 Bin Log 中却记录了该语句，所以使用 Bin Log 来恢复时就会多一个事务，这一行 c 的值就是 1 ，与原库不同。
	
可以发现，如果不加入任何机制，单纯地写入 Redo Log 和 Bin Log 。<br>
如果在写入第一个日志后 crash ，两个 Log 恢复的数据库将**不同**。

有了两阶段提交的 **Crash Recovery**

| Bin Log | Redo Log | crash 情况 | 恢复操作 |
| :--: | :--: | :--: | :--: |
| 有记录 | commit | 正常完成的事务 | 不需要恢复 |
| 有记录 | prepare | 在 Bin Log 写完提交事务之前的 crash | 提交事务 |
| 无记录 | prepare | 在 Bin Log 写完之前的 crash | 回滚事务 |
| 无记录 | 无记录 | 在 Redo Log 写之前 crash | 回滚事务 |



----------


WAL技术（Write-Ahead Logging）。先写日志，再写磁盘。