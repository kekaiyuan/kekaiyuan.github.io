---
layout: post
title: 设计模式之——代理Proxy
categories: DesignPatterns
description: 设计模式之——代理Proxy
keywords: Java，设计模式
---

设计模式之——代理Proxy

# 什么是代理模式

代理模式跟实际中的代理很像。

现实中，茅台工厂只负责生产茅台，代理商则负责设计包装，促销活动等。

代理商没有修改产品，只是增加了外部操作的。

在程序设计中，代理模式也是如此。

现在有一个类，里面有各种方法。

代理模式则是在不修改这个类的基础上，能够增加一些诸如计算运行时间、填写日志等的代理操作。

# 静态代理

# 动态代理
在静态代理中，代理类和被代理类属于同一个接口，代理类一定是针对被代理类而言的。
就像茅台代理商代理的一定是茅台，茅台代理商不能代理别的酒。
但是在动态代理中，可以出现代理多种物品的代理商，它不仅可以代理多种酒，甚至不是酒的他也能代理。

就像在静态代理中的日志代理只能填写关于Tank类的日志。
但是在动态代理中，日志代理可以填写所有类的日志。

动态代理是基于 JDK 中的

- 生成动态代理文件
```java
System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");
```
该行代码很容易理解，英译汉就能够明白
系统.获得配置文件.设置("sun.misc.代理生成类.存储生成文件","true");
像这种见名知意的代码都没有必要点进去看，这是让系统把我们代理中产生的文件保存下来。

加入该行代码后，系统会生成一个com目录，目录下有一个$Proxy0.class文件，这个就是我们动态代理的动态二字含义。
动态代理指的是，程序运行后会动态地生成一个.class文件，然后通过反射完成代理功能。

![enter description here](/images/posts/designpatterns/proxy/proxyfile.png)

如果没有生成该目录，可能是路径名的原因。
老版本用的是`System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");`比如 Jdk 1.8
新版本用的是`System.getProperties().put("jdk.proxy.ProxyGenerator.saveGeneratedFiles","true");`比如 Jdk 12

如果不清楚，可以查找 `ProxyGenerator` 这个类，找到 `saveGeneratedFiles` 这个属性，看看他取的是哪个系统属性。
```java
private static final boolean saveGeneratedFiles = (Boolean)AccessController.doPrivileged(new GetBooleanAction("sun.misc.ProxyGenerator.saveGeneratedFiles"));
```
# 代码链接
该文章源码链接[url](url)