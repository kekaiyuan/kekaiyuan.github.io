---
layout: post
title: Java lambda表达式
categories: Java
description: some word here
keywords: Java
---

# 代码进化之路
通过下文来一看为什么jdk8会有lambda表达式的诞生

现在有一个Student类
```java
public class Student {
    private String name;
    private int age;
    private int score;
	//无参构造方法、有参构造方法、对应的get和set方法省略
	...
}
```
我们现在需要将Student类的对象根据不同的要求输出，假设现在需要输出`age > 14`的对象和`score>75`的对象

- 基础版
	- `age > 14`
	 ```java
		public static void findByAge(ArrayList<Student> students) {
			ArrayList<Student> list = new ArrayList<>();
			for (Student stu : students) {
				if(stu.getAge() > 14) {
					list.add(stu);
				}
			}
			for (Student student : list) {
				System.out.println(student);
			}
		}
	  ```
	- `score>75`
		```java
		public static void findByScore(ArrayList<Student> students) {
			ArrayList<Student> list = new ArrayList<>();
			for (Student stu : students) {
				if(stu.getScore() > 75) {
					list.add(stu);
				}
			}
			for (Student student : list) {
				System.out.println(student);
			}
		}
		```
	- 直接编写对应的方法，这是最基础也最容易理解的。
		- 有多少个要求就编写多少个对应的方法，代码量大，程序臃肿
- 策略模式版
	- 引进策略模式，策略模式的连接[enter description here](阿斯蒂芬去玩儿)
	- 策略角色
		```java
		public interface StudentFilter {
			boolean compare(Student student);
		}
		```
	- 具体策略角色
		 ```java
		public class AgeFilter implements StudentFilter{
			@Override
			public boolean compare(Student student) {
				return student.getAge()>14;
			}
		}
		```
		```java
		public class ScoreFilter implements StudentFilter{
			@Override
			public boolean compare(Student student) {
				return student.getScore()>75;
			}
		}
		```
	- 如何调用
		```java
		public static void main(String[] args) {
			ArrayList<Student> list = new ArrayList<Student>();
			list.add(...);
			list.add(...);
			...
			getByFilter(list, new AgeFilter());
			getByFilter(list, new ScoreFilter());
		}
		public static void getByFilter(ArrayList<Student> students, StudentFilter filter) {
			ArrayList<Student> list = new ArrayList<>();
			for (Student student : students) {
				if (filter.compare(student)) {
					list.add(student);
				}
			}
			for (Student student : list) {
				System.out.println(student);
			}
		}
		```
		- 先编写一个通用的策略角色接口，里面声明了策略方法，然后根据要求编写具体的策略角色，实现具体的策略方法，最后根据要求调用不同的策略角色就可以。
			- 优点
				- 提高了代码复用性，简化了代码。
			- 缺点
				- 每种策略都是一个类，策略类数量会很多。