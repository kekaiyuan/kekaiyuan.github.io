---
layout: post
title: Java Io
categories: Java
description: asdfqwerfsadfasdf
keywords: Java, Io
---

# File类
- ![enter description here](/images/posts/java/study/io/fileclass.png)
- 常用方法
![enter description here](/images/posts/java/study/io/filemethods.png)


# 遍历文件
- 当需要遍历某目录以及子目录下的所有文件时，需要使用递归方式遍历
- 遍历时会报空指针错误，这是因为当前文件系统受保护，某些文件没有访问权限
- ```java
	public static void printFiles(File file) {
		if (file.isDirectory()) {
			File[] files = file.listFiles();
			for (File f : files) {
				printFiles(f);
			}
		} else {
			System.out.println(file.getAbsolutePath());
		}
	}
  ```




flush close

# 处理流
 - 字符流里有两个特殊的类：InputStreamReader和OutputStreamWriter，查看源码后可以发现，InputStreamReader必须使用InputStream类型的参数进行构造，类似地OutputStreamWriter必须使用OutputStream类型的参数进行构造。这意味着通过这两个类我们可以把字节流转化昵称字符流。
 - 好处
	 - 在网络通信中一切的数据流都是字节流，当我们收到字节流后需要转换成字符流就可以使用InputStreamReader
	 - 处理流比节点流的读写速度更快
		 - 本地实测，对长文本进行复制操作，使用缓冲区
			 - 28MB的纯英文txt
				 - 节点流111ms
				 - 处理流82ms
			 - 25MB的纯中文txt
				 - 节点流176ms
				 - 处理流144ms

# 一些小小的测试
- 通过程序复制文件测量不同类的速度
	- 字节流和字符流
		- 如果文件是视频、音乐...那么必须使用字节流，如果文件是含中文的文本，必须使用字符流。如果文件是纯英文的文本，字符流和字节流都可以，但是谁更快呢？
		- 文本大小：25MB纯英文txt
		- 测试次数：100次
		- 字节流
			- `FileInputStream`和`FileOutputStream`
			- 平均用时`163ms`
		- 字符流
			- `FileReader`和`FileWriter`
			- 平均用时`89ms`
		- 结论
			- 文本使用字符流处理更快
	- 节点流和处理流
		- 文本大小：25MB纯英文txt
		- 测试次数：100次
		- 节点流
			- `FileReader`和`FileWriter`
			- 平均用时`97ms`
		- 处理流
			- `InputStreamReader`和`OutputStreamWriter`
			- 平均用时`97ms`
		- 结论
			- 节点流和处理流在速度上区别不大
	- 使用缓冲区和不使用缓冲区
		- 使用 `FileReader`和`FileWriter`
		- 文本大小：25MB纯英文txt
		- 不使用缓冲区
			- 平均用时`1121ms`
		- 使用缓冲区
			- 平均用时`93ms`


## InputStream
### FileInputStream
- `abstract int read()`从输入流读取数据的下一个字节
- `int read(byte[] b)`从输入流读取一些字节数，并将它们存储到缓冲区 b
- `int read(byte[] b, int off, int len)`从输入流读取最多len字节的数据到一个字节数组，从`b[off]`到`b[off+len-1]`
- ``
- ``
- ``
- ``
- ``
- ``
- ``
- ``
		  
	 

# 语法
- 正常的写法
- 简化的写法
	- ```java
	  try(IO流1;
			  
			  )
	  ```
	- 

序列化

- IO流的关闭
	- 必须分别try...catch