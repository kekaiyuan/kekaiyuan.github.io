<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Java Spring 03——注解 &mdash; 菜鸟日记</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/github.css"><link rel="canonical" href="https://kekaiyuan.github.io//2021/07/29/03-annotation/"><link rel="alternate" type="application/atom+xml" title="菜鸟日记" href="https://kekaiyuan.github.io//feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/favicon.ico"><meta property="og:title" content="Java Spring 03——注解"><meta name="keywords" content="Java, Spring"><meta name="og:keywords" content="Java, Spring"><meta name="description" content="Java Spring 03——注解"><meta name="og:description" content="Java Spring 03——注解"><meta property="og:url" content="https://kekaiyuan.github.io//2021/07/29/03-annotation/"><meta property="og:site_name" content="菜鸟日记"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-07-29"> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://kekaiyuan.github.io//" title="菜鸟日记"><span class="octicon octicon-mark-github"></span> 菜鸟日记</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://kekaiyuan.github.io//" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://kekaiyuan.github.io//categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://kekaiyuan.github.io//archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://kekaiyuan.github.io//wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://kekaiyuan.github.io//links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://kekaiyuan.github.io//about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Java Spring 03—"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Java Spring 03——注解</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/07/29 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://kekaiyuan.github.io//categories/#Spring" title="Spring">Spring</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 9961 字，约 29 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/images/qrcode.jpg" alt="闷骚的程序员" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>Java Spring 03——注解</p><h1 id="序言">序言</h1><p>除了使用 xml 文件注册 bean 对象，还可以通过使用注解注册 bean 对象。</p><p>两种方式的应用场景都很多，在企业中，往往是将两种方式混合使用的。</p><h1 id="使用注解将-bean-对象添加到-ioc-容器中">使用注解将 bean 对象添加到 IOC 容器中</h1><h2 id="添加注解">添加注解</h2><p>给类添加注解，Spring 会自动把该类添加在 Spring IOC 容器中。</p><table><thead><tr><th style="text-align: center">注解</th><th style="text-align: center">含义</th><th style="text-align: center">使用场景</th></tr></thead><tbody><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">@Controller</code></td><td style="text-align: center">控制器</td><td style="text-align: center">推荐给 controller 层添加此注解</td></tr><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">@Service</code></td><td style="text-align: center">业务逻辑</td><td style="text-align: center">推荐给业务逻辑层添加此注解</td></tr><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">@Repository</code></td><td style="text-align: center">仓库管理</td><td style="text-align: center">推荐给数据访问层添加此注解</td></tr><tr><td style="text-align: center"><code class="language-plaintext highlighter-rouge">@Component</code></td><td style="text-align: center">普通组件</td><td style="text-align: center">给不属于以上基层的组件添加此注解</td></tr></tbody></table><p>实际上，Spring 并不会区分这四种注解，它只是单纯地将 bean 对象注册到 IOC 容器中。<br /> 我们甚至可以只使用一种注解来注册所有的 bean 对象。</p><p>但是为了提高代码的<strong>可阅读性</strong>，我们根据功能人为地把 bean 对象分成四种类型。</p><h3 id="其他注解">其他注解</h3><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>注意：当使用注解注册组件和使用配置文件注册组件是一样的，但是要注意：
	1、组件的id默认就是组件的类名首字符小写，如果非要改名字的话，直接在注解中添加即可
	2、组件默认情况下都是单例的,如果需要配置多例模式的话，可以在注解下添加@Scope注解
</code></pre></div></div><h2 id="添加自动扫描组件">添加自动扫描组件</h2><p>在给类添加注解后，我们还需要让 Spring 扫描这些被注解的类并添加到 IOC 容器中。<br /></p><hr /><p>1 . 导入 <code class="language-plaintext highlighter-rouge">context</code> 命名空间。</p><p>在 <code class="language-plaintext highlighter-rouge">&lt;beans&gt;&lt;/beans&gt;</code> 标签中添加 <code class="language-plaintext highlighter-rouge">xmlns:context="http://www.springframework.org/schema/context"</code></p><p>并在 <code class="language-plaintext highlighter-rouge">&lt;beans&gt;&lt;/beans&gt;</code> 标签的 <code class="language-plaintext highlighter-rouge">xsi:schemaLocation</code> 中添加</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context.xsd
</code></pre></div></div><hr /><p>2 . 使用 <code class="language-plaintext highlighter-rouge">context:component-scan</code> 标签指定要扫描的包。</p><hr /><p>案例：<br /> 以下代码正确地导入了 <code class="language-plaintext highlighter-rouge">context</code> 命名空间，<br /> 并将扫描 <code class="language-plaintext highlighter-rouge">com.kky</code> 包下的所有的类，把被注解的类加载到 IOC 容器中。</p><p>applicationContext.xml</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xmlns:context=</span><span class="s">"http://www.springframework.org/schema/context"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.kky"</span><span class="nt">&gt;&lt;/context:component-scan&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div><h3 id="排除不需要添加的对象">排除不需要添加的对象</h3><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
<span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.kky"</span><span class="nt">&gt;&lt;/context:component-scan&gt;</span>
...
</code></pre></div></div><p>以上方式会扫描 <code class="language-plaintext highlighter-rouge">com.kky</code> 包中的所有类，但如果此时我们需要排除某些对象应该怎么办？</p><p>使用 <code class="language-plaintext highlighter-rouge">context</code> 标签自带的过滤器 <code class="language-plaintext highlighter-rouge">exclude-filter</code></p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
<span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.kky"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;context:exclude-filter</span> <span class="na">type=</span><span class="s">""</span> <span class="na">expression=</span><span class="s">""</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/context:component-scan&gt;</span>
...
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">type</code> 表示过滤规则，<code class="language-plaintext highlighter-rouge">expression</code> 为表达式</p><h4 id="assignable">assignable</h4><p>排除某个具体的类，注意使用<strong>完全限定名（包括包名）</strong>，只能排除<strong>单个类</strong>。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
<span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.kky"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;context:exclude-filter</span> <span class="na">type=</span><span class="s">"assignable"</span> <span class="na">expression=</span><span class="s">"com.kky.bean.Student"</span><span class="nt">&gt;&lt;/context:exclude-filter&gt;</span>
<span class="nt">&lt;/context:component-scan&gt;</span>
...
</code></pre></div></div><p>包 <code class="language-plaintext highlighter-rouge">com.kky.bean</code> 下的 <code class="language-plaintext highlighter-rouge">Student</code> 类将不会被添加到 IOC 容器中。</p><h4 id="annotation">annotation</h4><p>排除注解，表达式必须是完全限定名。</p><p>前文提到过，有四种将对象注册到 IOC 容器的注解：</p><ul><li><code class="language-plaintext highlighter-rouge">@Controller</code></li><li><code class="language-plaintext highlighter-rouge">@Service</code></li><li><code class="language-plaintext highlighter-rouge">@Repository</code></li><li><code class="language-plaintext highlighter-rouge">@Component</code></li></ul><p>Spring 在扫描这些注解时<strong>一视同仁</strong>，全部都会加载到 IOC 容器中。</p><p>但是此时我们可以搞<strong>区别对待</strong>，排除某个注解，使它们无法被加载。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
<span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.kky"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;context:exclude-filter</span> <span class="na">type=</span><span class="s">"annotation"</span> <span class="na">expression=</span><span class="s">"org.springframework.stereotype.Controller"</span><span class="nt">&gt;&lt;/context:exclude-filter&gt;</span>
	<span class="nt">&lt;context:exclude-filter</span> <span class="na">type=</span><span class="s">"annotation"</span> <span class="na">expression=</span><span class="s">"org.springframework.stereotype.Service"</span><span class="nt">&gt;&lt;/context:exclude-filter&gt;</span>
	<span class="nt">&lt;context:exclude-filter</span> <span class="na">type=</span><span class="s">"annotation"</span> <span class="na">expression=</span><span class="s">"org.springframework.stereotype.Repository"</span><span class="nt">&gt;&lt;/context:exclude-filter&gt;</span>
	<span class="nt">&lt;context:exclude-filter</span> <span class="na">type=</span><span class="s">"annotation"</span> <span class="na">expression=</span><span class="s">"org.springframework.stereotype.Component"</span><span class="nt">&gt;&lt;/context:exclude-filter&gt;</span>
<span class="nt">&lt;/context:component-scan&gt;</span>
...
</code></pre></div></div><p>以上将四种注解都排除了。<br /> 实际中根据需要，排除对应的注解。</p><h4 id="regex">regex</h4><p>使用正则表达式，一般不用。</p><p>正则表达式是个非常复杂的东西，本文中不予讲述。</p><h4 id="aspectj">aspectj</h4><p>使用切面的方式，一般不用。</p><h4 id="custom">custom</h4><p>使用<strong>自定义</strong>的方式，可以自定义筛选规则，一般不用。</p><h3 id="指定需要添加的对象">指定需要添加的对象</h3><p>一般情况下，我们导入某个包中的所有对象，根据需要排除某些对象。</p><p>在 Spring 的语法中，提供了添加额外对象的功能，只不过这种方式<strong>很少使用</strong>。</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
<span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.kky"</span><span class="nt">&gt;</span>
	<span class="nt">&lt;context:include-filter</span> <span class="na">type=</span><span class="s">""</span> <span class="na">expression=</span><span class="s">""</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/context:component-scan&gt;</span>
...
</code></pre></div></div><p>把标签从 <code class="language-plaintext highlighter-rouge">exclude-filter</code> 改为 <code class="language-plaintext highlighter-rouge">include-filter</code>，<code class="language-plaintext highlighter-rouge">type</code> 依然是 <code class="language-plaintext highlighter-rouge">assignable</code> <code class="language-plaintext highlighter-rouge">annotation</code> <code class="language-plaintext highlighter-rouge">regex</code> <code class="language-plaintext highlighter-rouge">aspectj</code> <code class="language-plaintext highlighter-rouge">custom</code> 五种。</p><h2 id="使用方法">使用方法</h2><p>新建 PersonController 类并添加 <code class="language-plaintext highlighter-rouge">@Controller</code> 注解</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">com.kky.controller</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Controller</span><span class="o">;</span>

<span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonController</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>添加自动扫描组件</p><p>applicationContext.xml</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xmlns:context=</span><span class="s">"http://www.springframework.org/schema/context"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;context:component-scan</span> <span class="na">base-package=</span><span class="s">"com.kky"</span><span class="nt">&gt;&lt;/context:component-scan&gt;</span>
<span class="nt">&lt;/beans&gt;</span>
</code></pre></div></div><p>测试</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassPathXmlApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>
<span class="nc">PersonController</span> <span class="n">personController</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"personController"</span><span class="o">,</span> <span class="nc">PersonController</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">personController</span><span class="o">);</span>
</code></pre></div></div><p>结果</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div><h1 id="自动注入-autowired">自动注入 @Autowired</h1><h2 id="修饰成员变量">修饰成员变量</h2><p>用 <code class="language-plaintext highlighter-rouge">@Autowired</code> 修饰成员变量的效果是什么？</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"personservice"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonController</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">PersonService</span> <span class="n">personService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">personService</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>可以看到，PersonController 类中的某个成员是另一个类 PersonService 的对象。<br /> 并且会在 <code class="language-plaintext highlighter-rouge">save()</code> 方法调用该对象。</p><p>测试</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassPathXmlApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>
<span class="nc">PersonController</span> <span class="n">personController</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"personController"</span><span class="o">,</span> <span class="nc">PersonController</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">personController</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
</code></pre></div></div><p>结果：<strong>空指针</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">NullPointerException</span>
<span class="o">...</span>
</code></pre></div></div><p>这个异常很好理解，因为 <code class="language-plaintext highlighter-rouge">personController</code> 中的 <code class="language-plaintext highlighter-rouge">personService</code> 并<strong>没有初始化</strong>。</p><p>而通过自动注入，我们可以将成员变量成功赋值为某个 bean 对象。</p><h3 id="根据类型自动注入">根据类型自动注入</h3><p>而如果我们使用了自动注入，即 <code class="language-plaintext highlighter-rouge">@Autowired</code></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonController</span> <span class="o">{</span>

	<span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">PersonService</span> <span class="n">personService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">personService</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>测试</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassPathXmlApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>
<span class="nc">PersonController</span> <span class="n">personController</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"personController"</span><span class="o">,</span> <span class="nc">PersonController</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">personController</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
</code></pre></div></div><p>结果</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">personservice</span>
</code></pre></div></div><p>使用了 <code class="language-plaintext highlighter-rouge">@Autowired</code> 注解的对象，Spring 会进行<strong>自动装配</strong>——<strong>将该对象装配为 IOC 容器中的 bean 对象</strong>。<br /> 所以我们要装配的对象，<strong>必须通过某种方式加载到 IOC 容器中</strong>。</p><p>假如我们把 PersonService 类的 <code class="language-plaintext highlighter-rouge">@Service</code> 注解去掉。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"personservice"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>再次测试结果会报错。</p><hr /><p><code class="language-plaintext highlighter-rouge">@Autowired</code> 的<strong>规则</strong>是什么？</p><p>根据类型进行装配。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonController</span> <span class="o">{</span>

	<span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">PersonService</span> <span class="n">personService</span><span class="o">;</span>

<span class="o">}</span>
</code></pre></div></div><p>即 Spring 会去寻找 <code class="language-plaintext highlighter-rouge">PersonService</code> 类的对象并装配。</p><p>规则（以下的寻找是在 IOC 容器中寻找，所以请将对应的类加载到 IOC 容器中）：</p><ol><li>如果只存在一个对应类型的 bean 对象，直接进行赋值。</li><li>如果找不到对应类型，抛出异常。</li><li>当存在多个对应类型的 bean 对象<br /> （现有 A 类和 B 类，A 类是 B 类的<strong>父类</strong>，两者都加载到了 IOC 容器中，此时 <code class="language-plaintext highlighter-rouge">@Autowired</code> 修饰的是 A 类，则会同时寻找到两个 bean 对象） 会根据变量名继续匹配（即 <code class="language-plaintext highlighter-rouge">personService</code>）bean 对象的 <strong>id</strong>。<br /><ul><li>匹配成功，进行装配。</li><li>匹配失败，抛出异常。</li></ul></li></ol><h3 id="根据-id-自动注入">根据 id 自动注入</h3><p>Spring 提供了根据 id 自动注入对应 bean 对象的方式，实际中较少使用。<br /> 即 <code class="language-plaintext highlighter-rouge">@Qualifier()</code> 注解</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonController</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"personService"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">PersonService</span> <span class="n">personService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">personService</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>这样 Spring 会直接去寻找 id 为 <code class="language-plaintext highlighter-rouge">personService</code> 的 bean 对象。</p><ul><li>找到，成功装配。</li><li>找不到，抛出异常。</li></ul><h2 id="修饰方法">修饰方法</h2><p>用 <code class="language-plaintext highlighter-rouge">@Autowired</code> 修饰成员变量时将其自动赋值为 IOC 容器中的某个 bean 对象。</p><p>而使用 <code class="language-plaintext highlighter-rouge">@Autowired</code> 修饰的方法会怎么样呢？<br /> <strong>会在对象创建时自动调用该方法</strong>。</p><p>案例：<br /> 给 PersonController 类添加新的方法 <code class="language-plaintext highlighter-rouge">test()</code></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonController</span> <span class="o">{</span>

	<span class="o">...</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>测试</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassPathXmlApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>
<span class="nc">PersonController</span> <span class="n">personController</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"personController"</span><span class="o">,</span> <span class="nc">PersonController</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div><p>可以看到，只是创建了 PersonController 类对象，并没有调用任何方法。</p><p>结果</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span>
</code></pre></div></div><p>可以看到，<code class="language-plaintext highlighter-rouge">test()</code> 方法被<strong>自动调用</strong>了。</p><hr /><p>被 <code class="language-plaintext highlighter-rouge">@Autowired</code> 修饰的方法，其形参会被自动注入</p><p>新建 PersonDao 类</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonDao</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"persondao"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div><p>修改 PersonController 类</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonController</span> <span class="o">{</span>

	<span class="o">...</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nc">PersonDao</span> <span class="n">personDao</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
		<span class="n">personDao</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>我们在形参中添加了 PersonDao 对象并调用其 <code class="language-plaintext highlighter-rouge">save()</code> 方法。</p><p>测试</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassPathXmlApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>
<span class="nc">PersonController</span> <span class="n">personController</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"personController"</span><span class="o">,</span> <span class="nc">PersonController</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div><p>结果</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test</span>
<span class="n">persondao</span>
</code></pre></div></div><p>可以看到，并没有创建 PersonDao 对象，但是却成功调用了。<br /> 这说明 Spring 为形参执行了自动注入。</p><p>此时的形参是根据<strong>类型</strong>进行自动装配的，原理跟前文中<strong>一样</strong>。</p><p>同样可以根据 id 进行自动装配。</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PersonController</span> <span class="o">{</span>

	<span class="o">...</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">(</span><span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"personDao"</span><span class="o">)</span> <span class="nc">PersonDao</span> <span class="n">personDao123</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"test"</span><span class="o">);</span>
		<span class="n">personDao</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><h2 id="jdk-中的自动装配-resource">jdk 中的自动装配 @Resource</h2><p><code class="language-plaintext highlighter-rouge">@Autowired</code> 是 Spring 提供的自动装配的注解。</p><p>JDK 中也有实现装配的注解，那就是 <code class="language-plaintext highlighter-rouge">@Resource</code>。</p><p>在上文提到的案例中，把 <code class="language-plaintext highlighter-rouge">@Autowired</code> 替换成 <code class="language-plaintext highlighter-rouge">@Resource</code> 效果是一样的。</p><p>只不过使用 <code class="language-plaintext highlighter-rouge">@Resource</code> 需要导入一个包：<code class="language-plaintext highlighter-rouge">javax.annotation.Resource</code> 。</p><p>JDK1.8 自带这个包的，但是在某个版本之后被删除了（不确定是哪个版本，笔者使用的 JDK 12 是没有这个包的）。<br /> 此时需要外部导入这个包，其 Maven 依赖为：</p><div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
	<span class="nt">&lt;groupId&gt;</span>javax.annotation<span class="nt">&lt;/groupId&gt;</span>
	<span class="nt">&lt;artifactId&gt;</span>javax.annotation-api<span class="nt">&lt;/artifactId&gt;</span>
	<span class="nt">&lt;version&gt;</span>1.3.2<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">@Autowired</code> 和 <code class="language-plaintext highlighter-rouge">@Resource</code> 的异同：</p><ol><li><code class="language-plaintext highlighter-rouge">@Autowired</code> 是 Spring 中提供的注解。<br /> <code class="language-plaintext highlighter-rouge">@Resource</code> 是 JDK 中定义的注解，依靠的是 Java 的标准。</li><li><code class="language-plaintext highlighter-rouge">@Autowired</code> 默认按照类型进行装配，要求被依赖的对象必须存在。<br /> <code class="language-plaintext highlighter-rouge">@Resource</code> 默认按照变量名进行装配，可以使用 <code class="language-plaintext highlighter-rouge">@Qualifier()</code> 指定名称。</li><li><code class="language-plaintext highlighter-rouge">@Autowired</code> 只适合 Spring 框架，因为装配的是 IOC 容器中的 bean 对象。<br /> <code class="language-plaintext highlighter-rouge">@Resource</code> 是基于 Java 实现的，适用于多种框架，扩展性更好。</li></ol><h1 id="泛型依赖注入">泛型依赖注入</h1><p>如何在依赖注入中实现<strong>泛型</strong>？</p><p>如今的项目开发，一般把项目分为 Model, View, Controller，其中 Model 层分为</p><ul><li>entity 层<br /> 定义与数据库对应的实体类。</li><li>dao 层<br /> 调用 entity 层，实现增删改查</li><li>service 层<br /> 编程的重点，业务逻辑主要集中在这层。<br /> 在经过一系列逻辑处理后，调用 dao 层读写数据库。</li></ul><p>所以一般来说，数据库每多一张表，就会多出三个类。<br /></p><p>例如：现数据库有一张表 student。</p><p>entity 层</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>dao 层</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StudentDao</span> <span class="kd">extends</span> <span class="nc">BaseDao</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存学生"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>service 层</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StudentService</span><span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="nc">StudentDao</span> <span class="n">studentDao</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(){</span>
        <span class="n">studentDao</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>调用</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassPathXmlApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>
<span class="nc">StudentService</span> <span class="n">studentService</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"studentService"</span><span class="o">,</span> <span class="nc">StudentService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">studentService</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
</code></pre></div></div><p>结果</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>保存学生
</code></pre></div></div><p>如果现在数据库多了一张表 teacher，那么要编写与之对应的 entity、dao、service<br /> 然后又多了一张表…… ……</p><hr /><p>所以能不能通过<strong>泛型</strong>，简化代码？</p><p>entity 层</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Teacher</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p>dao 层</p><p>定义一个 BaseDao <strong>接口</strong>，并实现<strong>泛型</strong></p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">BaseDao</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>实现接口</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StudentDao</span> <span class="kd">extends</span> <span class="nc">BaseDao</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存学生"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TeacherDao</span> <span class="kd">extends</span> <span class="nc">BaseDao</span><span class="o">&lt;</span><span class="nc">Teacher</span><span class="o">&gt;{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"保存老师"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><hr /><p>serivce 层</p><p>在 dao 层实现泛型后，service 层可以减少代码量</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BaseService</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">BaseDao</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">baseDao</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">baseDao</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StudentService</span> <span class="kd">extends</span> <span class="nc">BaseService</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;{</span>
<span class="o">}</span>
</code></pre></div></div><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TeacherService</span> <span class="kd">extends</span> <span class="nc">BaseService</span><span class="o">&lt;</span><span class="nc">Teacher</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div><p>可以看到 StudentService 和 TeacherService 都是空方法。<br /> 因为到时候将通过泛型直接调用 BaseService 的方法。</p><hr /><p>调用</p><div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">ClassPathXmlApplicationContext</span> <span class="n">context</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassPathXmlApplicationContext</span><span class="o">(</span><span class="s">"applicationContext.xml"</span><span class="o">);</span>

<span class="nc">StudentService</span> <span class="n">studentService</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"studentService"</span><span class="o">,</span> <span class="nc">StudentService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">studentService</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>

<span class="nc">TeacherService</span> <span class="n">teacherService</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"teacherService"</span><span class="o">,</span> <span class="nc">TeacherService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">teacherService</span><span class="o">.</span><span class="na">save</span><span class="o">();</span>
</code></pre></div></div><p>结果</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>保存学生
保存老师
</code></pre></div></div><hr /><p>可以看到，在实现了泛型后，简化了 service 层的代码。</p><p>注意：<br /> 没有把握的情况下不要使用泛型编程，直接老实地实现每一张数据表的每一层。</p><h1 id="源码链接">源码链接</h1><p>该文章源码链接 <a href="https://github.com/kekaiyuan/java/tree/main/framework/spring/spring_annotation_study">Github</a></p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://kekaiyuan.github.io/" target="_blank">Kaiyuan Ke</a></li><li>本文链接：<a href="https://kekaiyuan.github.io//2021/07/29/03-annotation/" target="_blank">https://kekaiyuan.github.io//2021/07/29/03-annotation/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/07/29/03-annotation/', clientID: '', clientSecret: '', repo: '', owner: '', admin: [''], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:350px" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:16px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://kekaiyuan.github.io//assets/search_data.json?v=1646200239', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 10, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2015 <span title="Kaiyuan Ke">Kaiyuan Ke</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/kekaiyuan/kekaiyuan.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://kekaiyuan.github.io//" title="首页" target="">首页</a></li><li> <a href="https://kekaiyuan.github.io//categories/" title="分类" target="">分类</a></li><li> <a href="https://kekaiyuan.github.io//archives/" title="归档" target="">归档</a></li><li> <a href="https://kekaiyuan.github.io//wiki/" title="维基" target="">维基</a></li><li> <a href="https://kekaiyuan.github.io//links/" title="链接" target="">链接</a></li><li> <a href="https://kekaiyuan.github.io//about/" title="关于" target="">关于</a></li><li><a href="https://kekaiyuan.github.io//feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/kekaiyuan/kekaiyuan.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
