---
layout: post
title: 工厂模式Factory
categories: 工厂模式Factory
description: some word here
keywords: Java，设计模式
---

工厂模式Factory

# 定义
- 任何可以产生对象的方法或类，都可以称之为工厂
- 单例也是一种工厂
- 不可咬文嚼字，死扣概念
- 为什么有了new之后，还要有工厂？
	- 灵活控制生产过程
	- 权限、修饰、日志

# 举例
- 任意定制交通工具
	- 继承Vehicle
- 任意定制生产过程
	- XXXFactory.create
- 任意定制产品一族

单例 静态工厂
工厂方法

工厂系列
- 简单工厂
- 静态工厂
- 工厂方法 FactoryMethod
	- 产品维度扩展
- 抽象工厂
	- 产品一族进行扩展

IOC：inverse of control 控制反转
DI：dependency injection 依赖注入

# 抽象工厂
抽象工厂的目的是为了创建产品族。

什么是产品族？

比如现在我有三个类型的产品
- 载具
	- 汽车
	- 魔法扫帚
- 武器
	- AK47
	- 魔法棒
- 食物
	- 方便面
	- 魔法蘑菇

这六个产品很明显被分为了两类
- 一类是现代社会的东西：汽车、AK47、方便面
- 一类是魔法世界的东西：魔法扫帚、魔法棒、魔法蘑菇

这就是产品族，把多个产品归类到某个范畴之内。

于是我们就可以为这两个产品族建立两个抽象工厂
- 现代社会的抽象工厂专门生产 {汽车，AK47，方便面}
- 魔法世界的抽象工厂专门生产 {魔法扫帚，魔法棒，魔法蘑菇}

抽象工厂的目的主要有两个
- 维护产品族的内容
	- 我通过抽象工厂得到的产品族一定是唯一的。就像我通过上面的两个抽象工厂一定只能得到 {汽车，AK47，方便面} 和 {魔法扫帚，魔法棒，魔法蘑菇} 之中的一个产品族。我不可能得到 {汽车，魔法棒，魔法蘑菇} 这样的产品族。就像你不能去食品工厂生产电子产品，去电子工厂生产食品一样。
	- 抽象工厂保证了各个类之间的正确组合。
- 方便生产
	- 假如现在有六个工厂，分别生产上述六种东西的一种，那么我们可以很方便地得到其中一种：调用某个工厂得到某个产品。如果需要产品族，那么就调用三个工厂，得到三个产品。
	- 但是抽象工厂更方便，我只需要调用一个抽象工厂，就能得到一整套的产品族。

最常使用抽象工厂就是换皮肤。
- 无论是游戏内人物的皮肤，还是某款应用的界面，都非常适合用抽象工厂进行设计。
- 一套皮肤是由许多组件构成的，使用抽象工厂，就不会出现换皮肤后，一半是新皮肤，一半是旧皮肤的错误。
- 因为组件数量特别多，所以需要抽象工厂将组件集中到一起，实现“一键换皮”。

## 代码示例
抽象工厂需要定义非常多的抽象类，抽象工厂本身就是一个抽象类，每种产品又需要一个抽象类。
- Food
	- 抽象类
		```java
		public abstract class Food {
		
			public abstract void getName();
			
		}
		```
	- 方便面
		```java
		public class InstantNoodles extends Food{

			@Override
			public void getName() {
				System.out.println("方便面");
			}
			
		}
		```
	- 魔法蘑菇
		```java
		public class MushRoom extends Food{

			@Override
			public void getName() {
				System.out.println("魔法蘑菇");
			}

		}
		```
- 载具
	- 抽象类
		```java
		public abstract class Vehicle {

			public abstract void go();

		}
		```
	- 汽车
		```java
		public class Car extends Vehicle {

			@Override
			public void go() {
				System.out.println("开汽车");
			}

		}
		```
	- 魔法扫帚
		```java
		public class Broom extends Vehicle {

			@Override
			public void go() {
				System.out.println("骑扫帚");
			}

		}

		```
- 武器
	- 抽象类
		```java
		public abstract class Weapon {

			public abstract void shoot();

		}
		```
	- AK47
		```java
		public class AK47 extends Weapon{

			@Override
			public void shoot() {
				System.out.println("AK47");
			}

		}
		```
	- 魔法棒
		```java
		public class MagicStick extends Weapon{

			@Override
			public void shoot() {
				System.out.println("魔法棒");
			}

		}

		```
	
有了产品以后，就需要定义包装产品族的抽象工厂了。
- 抽象工厂
	- 抽象类
		```java
		public abstract class AbstractFactory {

			public abstract Food getFood();
			public abstract Vehicle getVehicle();
			public abstract Weapon getWeapon();

		}
		```
	- 现代工厂
		```java
		public class ModernFactory extends AbstractFactory{

			@Override
			public Food getFood() {
				return new InstantNoodles();
			}

			@Override
			public Vehicle getVehicle() {
				return new Car();
			}

			@Override
			public Weapon getWeapon() {
				return new AK47();
			}

		}
		```
	- 魔法工厂
		```java
		public class MagicFactory extends AbstractFactory{

			@Override
			public Food getFood() {
				return new MushRoom();
			}

			@Override
			public Vehicle getVehicle() {
				return new Broom();
			}

			@Override
			public Weapon getWeapon() {
				return new MagicStick();
			}

		}
		```
	
- 调用
	```java
	public class Main {

		public static void main(String[] args) {
			AbstractFactory abstractFactory1 = new MagicFactory();
			show(abstractFactory1);

			System.out.println("-------");

			AbstractFactory abstractFactory2 = new ModernFactory();
			show(abstractFactory2);

		}

		public static void show(AbstractFactory abstractFactory){
			abstractFactory.getFood().getName();
			abstractFactory.getVehicle().go();
			abstractFactory.getWeapon().shoot();
		}
	}
	```
- 输出
	```java
	魔法蘑菇
	骑扫帚
	魔法棒
	-------
	方便面
	开汽车
	AK47
	```
	
可以看到，使用了抽象工厂以后，产品族的搭配变得十分稳定，而且调用很简单。

# 代码链接
该文章源码链接[url](url)

```java

```
```java

```
```java

```
```java

```