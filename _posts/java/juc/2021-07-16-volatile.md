---
layout: post
title: Java 多线程与高并发之—— volatile 关键字
categories: [cate1, cate2]
description: some word here
keywords: keyword1, keyword2
mermaid: true
---

Java 多线程与高并发之—— volatile 关键字

# 序言
在定义某个类的成员变量时，我们可以使用 **volatile** 关键字来修饰该变量。

这个关键字在平时见不到，只有在多线程编程时才会用到。

它的作用有两个：
1. 保证线程可见性
2. 禁止指令重排

# 保证线程可见性
## 现代计算机的内存模型
首先要了解的是现代计算机的内存模型
```mermaid!
graph BT;
A[主内存] --- B[缓存一致性协议]
B --- C1[高速缓存]
B --- C2[高速缓存]
B --- C3[高速缓存]
C1 --- D1[处理器]
C2 --- D2[处理器]
C3 --- D3[处理器]
```

在计算机的早期时代，因为 CPU 的运行速度和内存的读写速度相差无几。<br>
所以当时是没有高速缓存的。<br>
CPU 直接从内存读取数据，进行计算，返回结果给内存。

但随着技术的发展，CPU 的速度越来越快，但是内存读写速度的发展却陷入了瓶颈。<br>
两者之间出现了几个数量级的差距。

于是不得不加入了读写速度能够与 CPU 匹配的高速缓存：<br>
将运算需要使用到的数据复制到缓存中，让运算能快速进行。
当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

但此时又有了新的问题：<br>
假如多个处理器从内存中取走了同一份数据，再经过各自的计算后，哪份数据才是真正需要写回内存的哪份？

于是提出了**缓存一致性协议**，用于同步多个缓存之间的数据。

## JMM
根据现代计算机的内存模型，Java 也提出了相似的内存模型（简称 JMM—— Java Memory Model）。

```mermaid!
graph BT;
A[主内存] --- B[Save 和 Load 操作]
B --- C1[工作内存]
B --- C2[工作内存]
B --- C3[工作内存]
C1 --- D1[Java 线程]
C2 --- D2[Java 线程]
C3 --- D3[Java 线程]
```

Java 内存模型规定了以下几点：
1. 所有的变量都存储在主内存中。
2. 每条线程都有自己的工作内存，保存了主内存中的数据拷贝。
3. 线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。
4. 线程间传递变量值需要在主内存中完成。

## 线程可见性
当线程修改了其工作内存的数据后，需要使得其他线程能够看到该数据，这就是线程可见性。

在一般情况下，线程间是不可见的。

需要通过某些方法，强制触发该流程：
1. 将工作内存的数据同步回内存。
2. 触发缓存一致性协议，将内存中的数据同步到所有线程的工作内存。
3. 请注意：

	volatile 不是实现线程可见性的唯一方法。
	只要能够触发该流程，就能实现线程间可见。
	
## 案例
现有一个小程序
```java?linenums
public class T01_VolatileTest {
    boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别
    void m() {
        System.out.println("m start");
        while(running) {
        }
        System.out.println("m end!");
    }

    public static void main(String[] args) throws InterruptedException {
        T01_VolatileTest t = new T01_VolatileTest();
        new Thread(t::m, "t1").start();

        //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中
        Thread.sleep(1000);

        t.running = false;
    }
}
```
该程序很简单。<br>
启动一个线程，当 `running = false` 时死循环，当 `running = ture` 时结束线程。

结果
```java
m start
```
并且该程序不会结束，一直处于运行状态。
说明程序一直在死循环。

这就是线程不可见：<br>
线程 t 一开始从主内存中复制的变量是 `running = true`。<br>
主线程在等待一段时间（确保线程 t 复制的是 `running = true` ）后将 `running` 改为 `false`。<br>
但是线程 t 中的 `running` 并没有修改，所以线程 t 死循环。

### 解决办法
#### volatile 关键字
```java
public class T01_VolatileTest {
    volatile boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别
    void m() {
        System.out.println("m start");
        while(running) {
        }
        System.out.println("m end!");
    }

    public static void main(String[] args) throws InterruptedException {
        T01_VolatileTest t = new T01_VolatileTest();
        new Thread(t::m, "t1").start();

        //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中
        Thread.sleep(1000);

		//修改 running 的值，尝试让线程 t 停下来
        t.running = false;
    }
}
```
结果
```java
m start
m end!
```

#### synchronized 关键字
synchronized 关键字也是能够保证线程可见性的。

```java
public class T01_VolatileTest {
    boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别
    void m() {
        System.out.println("m start");
        while(running) {
			synchronized(this){
			}
        }
        System.out.println("m end!");
    }

    public static void main(String[] args) throws InterruptedException {
        T01_VolatileTest t = new T01_VolatileTest();
        new Thread(t::m, "t1").start();

        //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中
        Thread.sleep(1000);

		//修改 running 的值，尝试让线程 t 停下来
        t.running = false;
    }
}
```

#### Thread.sleep() 
如果调用了 Thread.sleep() 方法，那么 JVM 会利用线程睡眠的这段时间进行数据的同步。
```java
public class T01_VolatileTest {
    boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别
    void m() {
        System.out.println("m start");
        while(running) {
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("m end!");
    }

    public static void main(String[] args) throws InterruptedException {
        T01_VolatileTest t = new T01_VolatileTest();
        new Thread(t::m, "t1").start();

        //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中
        Thread.sleep(1000);

		//修改 running 的值，尝试让线程 t 停下来
        t.running = false;
    }
}
```
结果
```java
m start
m end!
```

#### System.out.println()
如果线程调用了 System.out.println() 方法，**无论输出的是什么**，<br>
JVM 都会进行数据同步。
```java
public class T01_VolatileTest {
    boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别
    void m() {
        System.out.println("m start");
        while(running) {
			System.out.println("666");
        }
        System.out.println("m end!");
    }

    public static void main(String[] args) throws InterruptedException {
        T01_VolatileTest t = new T01_VolatileTest();
        new Thread(t::m, "t1").start();

        //睡眠一段时间是为了让线程 t 将 running = true 复制到工作内存中
        Thread.sleep(1000);

		//修改 running 的值，尝试让线程 t 停下来
        t.running = false;
    }
}
```
结果
```java
m start
666
……（省略 10000 个 666）
666
m end!
```

#### 总结
要实现线程间可见很简单，只要强制性地让 JVM 实现数据的同步就可以了。<br>
方法有很多，笔者找到了这四种，但应该还有很多方法能触发线程间可见。

# volatile 不能保证原子性
volatile 实现了线程可见性，使得多线程的数据能够同步，但是它并不能保证原子性。

什么是原子性？<br>
简单来说：保证指令序列是一体的，要么全部执行，要么全部不执行，不会发生执行到一半被打断的情况。

在 Java 中，使用 synchronized 关键字实现锁机制来保证原子性。

测试：
```java
```

```java
```

```java
```

```java
```

```java
```

```java
```

```java
```

```java
```

```java
```



保证线程可见性
MESI
缓存一致性协议

禁止指令重排序
流水线技术
DCL单例 double check lock
loadfence原语
storefence原语

INSTANCE = new Mgr06();
分三步：
1. 申请内存

	此时的成员变量都是默认值
2. 初始化成员变量（堆中）
3. INSTANCE （在栈中） 指向堆的地址

2，3换顺序
先指向，再赋值

第一个线程new一半，此时已经指向了，不是空值
第二个线程切进来拿去用


CAS 无锁优化 自旋

Compare And Set
cas（V）

ABA
版本号

## 源码链接
该文章源码链接 [Github](url)