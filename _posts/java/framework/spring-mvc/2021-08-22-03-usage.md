---
layout: post
title: Java Spring MVC 03——使用方法（三）
categories: SpringMVC
description: Java Spring MVC 03——使用方法（三）
keywords: Spring MVC, Java
mermaid: true
---

Java Spring MVC 03——使用方法（三）

# Spring MVC 返回 JSON 数据
## 准备工作
### 导入相关依赖
pom.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.mashibing</groupId>
    <artifactId>springmv_ajax</artifactId>
    <version>1.0-SNAPSHOT</version>
    <dependencies>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>5.2.3.RELEASE</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-web -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-web</artifactId>
            <version>5.2.3.RELEASE</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>5.2.3.RELEASE</version>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.5</version>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>jsp-api</artifactId>
            <version>2.0</version>
            <scope>provided</scope>
        </dependency>
        <!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-core</artifactId>
            <version>2.10.3</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.10.3</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-annotations</artifactId>
            <version>2.10.3</version>
        </dependency>
    </dependencies>
</project>
```
与 JSON 相关的有三个包：
1. `jackson-core`
2. `jackson-databind`
3. `jackson-annotations`

### Spring MVC 配置文件
springmvc.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"

       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <context:component-scan base-package="com.kky"></context:component-scan>

    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/WEB-INF/page/"></property>
        <property name="suffix" value=".jsp"></property>
    </bean>
    <mvc:default-servlet-handler></mvc:default-servlet-handler>
    <mvc:annotation-driven></mvc:annotation-driven>
</beans>
```

### web.xml
配置 DispatcherServlet
```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:springmvc.xml</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

## 正式使用
新建实体类 User
```java
public class User {

    private Integer id;
    private String name;
    private Integer age;
    private String gender;

    //省略无参构造器，getter/setter 方法，toString 方法
}
```


----------

先复习一下 Spring MVC 的一般形式
```java
@Controller
public class AController {
	
	@RequestMapping("/aRequest")
	public String aMethod(){
	    //业务逻辑
		return "要跳转的页面地址"
	}
}
```
即方法的返回值是 `String` ，然后 `return` 的是我们要跳转的页面地址。

但是在 JSON 中，我们使用另一种形式<br>
JsonController.java
```java
@Controller
public class JsonController {

    @ResponseBody
    @RequestMapping("/json")
    public List<User> json(){
        List<User> list = new ArrayList<User>();
        list.add(new User(1,"zhangsan",12,"男",new Date(),"1234@qq.com"));
        list.add(new User(2,"zhangsan2",12,"男",new Date(),"1234@qq.com"));
        list.add(new User(3,"zhangsan3",12,"男",new Date(),"1234@qq.com"));
        return list;
    }
}
```
在使用了 `@ResponseBody` 注解后，我们不再跳转到某个页面去。<br>
而是直接把内容返回到 `Http Response Body` 中，然后客户端会把内容直接显示。<br>
![picture](\images\posts\java\framework\spring-mvc\03\json.png)

即原来是
```mermaid
graph LR;
A[某页面] --发送请求--> B[服务器]
B --跳转--> C[另一个页面]
```
现在是
```mermaid
graph LR;
A[某页面] --发送请求--> B[服务器]
B --返回内容并显示--> A
```


除了 `List`，`@ResponseBody` 也可以返回**字符串**作为响应内容。

```java
@Controller
public class OtherController {
    @ResponseBody
    @RequestMapping("/testResponseBody")
    public String testResponseBody(){
        return "<h1>hello,JSON</h1>";
    }
}
```
![picture](\images\posts\java\framework\spring-mvc\03\json2.png)


### 通过 ajax 获取 JSON 数据
ajax.jsp
```jsp
<%@ page import="java.util.Date" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
    <script type="text/javascript" src="script/jquery-1.9.1.min.js"></script>
</head>
<%
    pageContext.setAttribute("ctp",request.getContextPath());
%>
<body>
<%=new Date()%>
<a href="${ctp}/json">获取用户信息</a>
<div>

</div>
<script type="text/javascript">
    $("a:first").click(function () {
        $.ajax({
            url:"${ctp}/json",
            type:"GET",
            success:function (data) {
                console.log(data)
                $.each(data,function() {
                    var user = this.id+"--"+this.name+"--"+this.age+"--"+this.gender;
                    $("div").append(user+'<br/>');
                })
            }
        });
        return false;
    });
</script>
</body>
</html>
```
这里引入了一个 [js](https://github.com/kekaiyuan/java/blob/main/framework/springmvc/springmvc_json/web/scripts/jquery-1.9.1.min.js)
```xml
<script type="text/javascript" src="script/jquery-1.9.1.min.js"></script>
```


----------

测试<br>
![picture](\images\posts\java\framework\spring-mvc\03\ajax.png)


----------


点击后<br>
![picture](\images\posts\java\framework\spring-mvc\03\ajax2.png)


# 使用 @RequestBody 获取请求体信息

/requestbody.jsp
```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<%
    pageContext.setAttribute("ctp",request.getContextPath());
%>
<body>
<form action="${ctp}/testRequestBody" method="post">
    <input name="username" value="zhangsan"><br>
    <input name="password" value="123456"><br>
    <input type="file" name="file"><br>
    <input type="submit" value="提交">
</form>
</body>
</html>
```

在 JsonController.java 添加方法
```java
@RequestMapping("/testRequestBody")
public void testRequestBody(@RequestBody String body){
	System.out.println(body);
}
```

----------

测试<br>
![picture](\images\posts\java\framework\spring-mvc\03\requestbody2.png)


随便选择某个文件，然后点击**提交**
```java
username=zhangsan&password=123456&file=20210715123128.png
```


----------

使用 `@RequestParam` 注解只能获取请求体中的**单个参数**
```java
@RequestMapping("/testRequestBody")
public void testRequestBody(@RequestParam("username") String username){
	System.out.println(username);
}
```
而使用 `@RequestBody` 可以获取**整个请求体**


----------


同时@RequestBody能够接受json格式的请求数据：

/requestbody2.jsp
```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<script src="scripts/jquery-1.9.1.min.js"></script>
<head>
    <title>Title</title>
</head>
<%
    pageContext.setAttribute("ctp", request.getContextPath());
%>
<body>
<a href="${ctp}/testRequestJson">发送 JSON 数据</a>
</body>
<script type="text/javascript">
    $("a:first").click(function () {
        var user = {id: "1", name: "zhangsan", age: "12", gender: "man"};
        var jsonuser = JSON.stringify(user);
        $.ajax({
            url: "${ctp}/testRequestJson",
            type: "post",
            data: jsonuser,
            contentType: "application/json",
            success: function (data) {
                alert(data)
            }
        });
        return false;
    })
</script>
</html>
```

在 JsonController 中添加方法
```java
@RequestMapping("/testRequestJson")
public void testRequestJson(@RequestBody User user){
	System.out.println(user);
}
```

测试<br>
![picture](\images\posts\java\framework\spring-mvc\03\requestbody3.png)

结果
```java
User{id=1, name='zhangsan', age=12, gender='man'}
```

# 使用 HttpEntity 对象获取请求对象
```java
@RequestMapping("/testHttpEntity")
public void test(HttpEntity<String> httpEntity){
	System.out.println(httpEntity);
}
```
即可获取 Http 请求的所有信息，无需添加注解

测试
```java
[host:"localhost:8080", connection:"keep-alive", sec-ch-ua:""Chromium";v="92", " Not A;Brand";v="99", "Google Chrome";v="92"", sec-ch-ua-mobile:"?0", upgrade-insecure-requests:"1", user-agent:"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36", accept:"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9", sec-fetch-site:"none", sec-fetch-mode:"navigate", sec-fetch-user:"?1", sec-fetch-dest:"document", accept-encoding:"gzip, deflate, br", accept-language:"zh-CN,zh;q=0.9,en;q=0.8", cookie:"name=zhangsan; JSESSIONID=7D7C9C05C14E005A5FC420CDB727B2C0; Idea-18645a00=2aaa6995-3701-4bf7-9c5b-f70fb70ac354; JSESSIONID=9F9DBC7950291B1AEB1E180C8D22A22C"]
```


# 使用 ResponseEntity 设置响应内容
```java
@RequestMapping("/testResponseEntity")
public ResponseEntity<String> testResponseEntity() {
	String str = "<h1>test response entity</h1>";
	HttpHeaders httpHeaders = new HttpHeaders();
	httpHeaders.add("Set-Cookie", "name=zhangsan");
	return new ResponseEntity<String>(str, httpHeaders, HttpStatus.OK);
}
```
测试<br>
![picture](\images\posts\java\framework\spring-mvc\03\testResponseEntity.png)<br>
可以看到，cookie 中成功设置了 `name=zhangsan`

# 文件下载
```java
@Controller
public class DownloadController {

    @RequestMapping("/download")
    public ResponseEntity<byte[]> download(HttpServletRequest request) throws Exception {

        //获取要下载的路径
        ServletContext servletContext = request.getServletContext();
        //将相对路径转换为真实路径
        String realPath = servletContext.getRealPath("/scripts/jquery-1.9.1.min.js");

        //通过io流对文件进行读写
        FileInputStream fileInputStream = new FileInputStream(realPath);
        byte[] bytes = new byte[fileInputStream.available()];
        fileInputStream.read(bytes);
        fileInputStream.close();

        //将下载内容设置到 ResponseEntity 中
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.set("Content-Disposition", "attachment;filename=jquery-1.9.1.min.js");
        return new ResponseEntity<byte[]>(bytes, httpHeaders, HttpStatus.OK);
    }
}
```

# 文件上传
文件上传时不要直接使用普通的 IO 流上传，很麻烦，而且效率低。<br>
使用 **Apache Commons FileUpload**，其 Maven 依赖为
```xml
<!-- https://mvnrepository.com/artifact/commons-io/commons-io -->
<dependency>
	<groupId>commons-io</groupId>
	<artifactId>commons-io</artifactId>
	<version>2.6</version>
</dependency>
<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->
<dependency>
	<groupId>commons-fileupload</groupId>
	<artifactId>commons-fileupload</artifactId>
	<version>1.4</version>
</dependency>
```

同样地，Spring MVC 也为文件上传提供了直接的支持，通过**即插即用**的 **MultipartResolver** 实现的。<br>
Spring 用 **Jakarta Commons FileUpload** 技术实现了一个 MultipartResolver 实现类：**CommonsMultipartResovler**。<br>
该功能需要手动地在 Spring MVC 配置文件中添加以下配置
```xml
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
	<property name="defaultEncoding" value="UTF-8"></property>
	<property name="maxUploadSize" value="1024000"></property>
</bean>
```
该 bean 对象可以配置很多属性，该案例设置了**默认编码格式**和**最大上传大小**。


----------


/upload.jsp
```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<%
    pageContext.setAttribute("ctp",request.getContextPath());
%>
<body>
<form action="${ctp}/upload" method="post" enctype="multipart/form-data">
    描述：<input type="text" name="desc"><br>
    文件：<input type="file" name="file"><br>
    <input type="submit" value="提交">
</form>
</body>
</html>
```


----------


UploadController.java
```java
@Controller
public class UploadController {

    @RequestMapping("/upload")
    public void upload(@RequestParam("file") MultipartFile/*[]*/ multipartFile, @RequestParam(value = "desc", required =
            false) String desc) throws Exception {

        //文件描述
        System.out.println(desc);
		
        //文件名称
        System.out.println(multipartFile.getOriginalFilename());
		
		//将文件传输到指定目录
        multipartFile.transferTo(new File("d:\\file\\" + multipartFile.getOriginalFilename()));
    }
}
```


----------

测试<br>
![picture](\images\posts\java\framework\spring-mvc\03\upload.png)


----------

提交后<br>
![picture](\images\posts\java\framework\spring-mvc\03\upload2.png)


### 多文件上传
直接在 jsp 页面的表单中添加多个 `<input>` 标签

/upload.jsp
```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<%
    pageContext.setAttribute("ctp",request.getContextPath());
%>
<body>
<form action="${ctp}/upload" method="post" enctype="multipart/form-data">
    描述：<input type="text" name="desc"><br>
    文件：<input type="file" name="file"><br>
    文件：<input type="file" name="file"><br>
    文件：<input type="file" name="file"><br>
    <input type="submit" value="提交">
</form>
</body>
</html>
```


----------

把处理方法的参数改为**数组**

UploadController.java
```java
@Controller
public class UploadController {

    @RequestMapping("/upload")
    public void upload(@RequestParam("file") MultipartFile[] multipartFile, @RequestParam(value = "desc", required =
            false) String desc) throws Exception {

        //文件描述
        System.out.println(desc);

        for (MultipartFile file : multipartFile) {
            if(!file.isEmpty()){
                //文件名称
                System.out.println(file.getOriginalFilename());
                //将文件传输到指定目录
                file.transferTo(new File("d:\\file\\" + file.getOriginalFilename()));
            }
        }
    }
}
```
记得加入**非空判断**。<br>
因为用户可以通过页面至多提交三个文件（不一定是三个）。

# Spring MVC 拦截器
Spring MVC 提供了拦截器的机制，其种类多种多样，最常用的是 **HandlerInterceptor** 接口。

顾名思义，**HandlerInterceptor** 拦截的是 **Handler**。<br>
什么是 **Handler**？<br>
平时用于处理请求的具体方法就是 **Handler**
```java
@Controller
public class AController {
	
	@RequestMapping("/aRequest")
	public String aMethod(){
        //业务逻辑
        return "要跳转的页面地址"
	}
}
```
这就是 **Handler**，只不过因为 **MVC** 架构，很多人在命名时都命名为 **Controller** 罢了。<br>
就像一个人有本名和外号一样，实际上指的是同一个。

**HandlerInterceptor** 接口有三个重要方法

| **method** | **说明** |
| :-- | :-- |
| `preHandle()` | 在 **Handler** 处理请求**前**调用。 |
| `postHandle()` | 在 **Handler** 处理请求**后**，<br> **DispatcherServlet** 向客户端**返回前**调用。|
| `afterCompletion()` | 在 **DispatcherServlet** **完全**处理完请求**后**被调用，<br>可以在该方法中进行一些**资源清理**的操作。|

`postHandle()` 和 `afterCompletion()` 是没有返回值的。<br>
但是 `preHandle()` 是有返回值的，而且这个返回值**很重要**！
- 该方法的返回值为 `boolean` 类型。
- 当返回值为 `false` 时，执行完该方法后
	- 不会执行其他拦截器
	- 不会执行该拦截器的其他方法。
- 拦截器是 [责任链模式](https://kekaiyuan.github.io//2021/06/07/chain-of-responsibility/)，一个拦截器连着另一个拦截器，组成一道链条。<br>
	当链条在某处被打断后，其剩余的部分将不会执行。


## 自定义拦截器

实现 **HandlerInterceptor** 接口，并简单实现三个重要方法。<br>
MyInterceptor.java
```java
public class MyInterceptor implements HandlerInterceptor {

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(this.getClass().getName()+"----preHandle");
        return true;
    }

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(this.getClass().getName()+"----postHandle");
    }

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(this.getClass().getName()+"----afterCompletion");
    }
}
```
此时 `preHandle()` 的返回值是 `true`。

在 Spring MVC 的配置文件中配置拦截器
```xml
<mvc:interceptors>
	<bean class="com.kky.interceptor.MyInterceptor"></bean>
</mvc:interceptors>
```

配置好以后，任何请求都会在控制台输出以下信息：
```java
com.kky.interceptor.MyInterceptor----preHandle
com.kky.interceptor.MyInterceptor----postHandle
com.kky.interceptor.MyInterceptor----afterCompletion
```

如果把 `preHandle()` 的返回值改为 `false`。
- 不会执行剩余的拦截器（如果有的话）
- 本拦截器的其他方法也不会执行

```java
com.kky.interceptor.MyInterceptor----preHandle
```

### 执行顺序

```mermaid
graph LR;
A["preHandle()"] --> B["某 Handler"]
B --"执行完毕，<br>但是还没有进行页面跳转"--> C["postHandle()"]
C --"页面跳转"--> D["afterCompletion()"]
```

如果在执行目标方法的过程中抛出了**异常**，依然会执行 `afterCompletion`

```mermaid
graph LR;
A["preHandle()"] --> B["某 Handler"]
B --"抛出异常"--> C["afterCompletion()"]
```

```mermaid
graph LR;
A[无锁状态] --> B[偏向锁]
B --> C["轻量级锁（自旋锁）"]
C --> D[重量级锁]
```

<div class="mermaid">
graph LR;
A["preHandle()"]-->偏向锁
</div>

## 多个拦截器的执行顺序
再添加一个拦截器
```java
public class SecondInterceptor implements HandlerInterceptor {

    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(this.getClass().getName() + "----preHandle");
        return true;
    }

    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(this.getClass().getName() + "----postHandle");

    }

    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println(this.getClass().getName() + "----afterCompletion");

    }
}
```

Spring MVC 配置文件
```xml
<mvc:interceptors>
	<bean class="com.kky.interceptor.MyInterceptor"></bean>
	<bean class="com.kky.interceptor.SecondInterceptor"></bean>
</mvc:interceptors>
```

随便发送某个请求，查看执行顺序：
```java
com.kky.interceptor.MyInterceptor----preHandle
com.kky.interceptor.SecondInterceptor----preHandle
com.kky.interceptor.SecondInterceptor----postHandle
com.kky.interceptor.MyInterceptor----postHandle
com.kky.interceptor.SecondInterceptor----afterCompletion
com.kky.interceptor.MyInterceptor----afterCompletion
```
可以看到

| 方法 | 执行顺序 |
| :-- | :-- |
| `perHandle` | 顺序 |
| `postHandle` | 逆序 |
| `afterCompletion` | 逆序 |

## 拦截器跟过滤器的区别

| 区别 | 过滤器 | 拦截器 |
| :-- | :-- | :-- |
| 原理 | 函数回调 | java 反射 |
| 是否依赖于 servlet 容器 | 是 | 否 |
| 作用于何种请求 | 所有请求 | action 请求 |
| 是否可以访问 action 的上下文 | 不可以 | 可以 |
| | 在 controller 的生命周期中，拦截器可以多次调用 | 而过滤器只能在web容器初始化的时候初始化一次，<br>后续匹配的所有请求都会经过过滤器来进行过滤 |


![image-20200313190146352](image\拦截器跟过滤器的执行流程.png)

![image-20200313190309273](image\拦截器和过滤器的包含关系.png)

### 9、SpringMVC的国际化操作

在日常工作中，如果你的网站需要给不同语言地区的人进行查看，此时就需要使用国际化的基本操作，springmvc的国际化操作比较容易。

index.jsp

```jsp
<%--  Created by IntelliJ IDEA.  User: root  Date: 2020/3/13  Time: 17:00  To change this template use File | Settings | File Templates.--%><%@ page contentType="text/html;charset=UTF-8" language="java" %><html>  <head>    <title>$Title$</title>  </head>  <body>  <a href="i18n">国际化页面登录</a>  </body></html>
```

login.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %><%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%><html><head>    <title>Title</title></head><body><h1><fmt:message key="welcomeinfo"/></h1><form action="login" method="post" >    <fmt:message key="username"/>: <input type="text" name="username"/><br><br>    <fmt:message key="password"/>: <input type="password" name="password"/><br><br>    <input type="submit" value="<fmt:message key="loginBtn"/>"/></form></body></html>
```

I18nController.java

```java
package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class I18nController {    @RequestMapping("i18n")    public String i18n(){        return "login";    }}
```

login_en_US.properties

```properties
welcomeinfo=welcome to mashibing.comusername=USERNAMEpassword=PASSWORDloginBtn=LOGIN
```

login_zh_CN.properties

```pro
welcomeinfo=欢迎进入马士兵教育username=用户名password=密码loginBtn=登录
```

springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:mvc="http://www.springframework.org/schema/mvc"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">    <mvc:default-servlet-handler></mvc:default-servlet-handler>    <mvc:annotation-driven></mvc:annotation-driven>    <context:component-scan base-package="com.mashibing"></context:component-scan>    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">        <property name="prefix" value="/WEB-INF/page/"></property>        <property name="suffix" value=".jsp"></property>    </bean>    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">        <property name="basename" value="login"></property>    </bean></beans>
```

其实SpringMVC中国际化的处理非常简单，就是按照浏览器所带来的语言信息决定的。

```java
Locale locale = request.getLocale();//获取浏览器的区域信息
```

在DispatcherServlet中会包含一个组件，用来专门获取区域信息

![image-20200313193757666](image\国际化1.png)

![image-20200313193823121](image\国际化2.png)

![image-20200313194137103](image\国际化3.png)

通过图片能够发现，默认调用的是org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver类

![image-20200313194436614](image\国际化4.png)

在程序中可以获取Locale的相关信息：

```java
package com.mashibing.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Locale;@Controllerpublic class I18nController {    @Autowired    private MessageSource messageSource;    @RequestMapping("i18n")    public String i18n(Locale locale){        System.out.println(locale);        String username = messageSource.getMessage("username", null, locale);        System.out.println(username);        return "login";    }}
```

### 10、通过超链接来切换国际化

login.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %><%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt"%><html><head>    <title>Title</title></head><body><h1><fmt:message key="welcomeinfo"/></h1><form action="login" method="post" >    <fmt:message key="username"/>: <input type="text" name="username"/><br><br>    <fmt:message key="password"/>: <input type="password" name="password"/><br><br>    <input type="submit" value="<fmt:message key="loginBtn"/>"/>    <a href="i18n?locale=zh_CN">中文</a><a href="i18n?locale=en_US">英文</a></form></body></html>
```

MyLocaleResolver.java

```java
package com.mashibing;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;public class MyLocaleResolver implements LocaleResolver {    /**     * 解析并返回locale     * @param request     * @return     */    @Override    public Locale resolveLocale(HttpServletRequest request) {        Locale locale = null;        String localeStr = request.getParameter("locale");        if(localeStr!=null && ! "".equals(localeStr)){            locale = new Locale(localeStr.split("_")[0],localeStr.split("_")[1]);        }else{            locale = request.getLocale();        }        return locale;    }    /**     * 不支持设置locale的信息     * @param request     * @param response     * @param locale     */    @Override    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {        throw new UnsupportedOperationException(                "Cannot change HTTP accept header - use a different locale resolution strategy");    }}
```

springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:mvc="http://www.springframework.org/schema/mvc"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd"><mvc:default-servlet-handler></mvc:default-servlet-handler><mvc:annotation-driven></mvc:annotation-driven><context:component-scan base-package="com.mashibing"></context:component-scan><bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">    <property name="prefix" value="/WEB-INF/page/"></property>    <property name="suffix" value=".jsp"></property></bean><bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">    <property name="basename" value="login"></property></bean>    <!--配置区域信息解析器-->    <bean id="localeResolver" class="com.mashibing.MyLocaleResolver"></bean></beans>
```

除了可以自定义区域信息解析器之外，我们还可以使用SpringMVC中自带的SessionLocaleResolver:

I18nController.java

```java
package com.mashibing.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.i18n.SessionLocaleResolver;import javax.servlet.http.HttpSession;import java.util.Locale;@Controllerpublic class I18nController {    @Autowired    private MessageSource messageSource;    @RequestMapping("i18n")    public String i18n(@RequestParam(value = "locale",defaultValue = "zh_CN") String localeStr,Locale locale, HttpSession session){        Locale l = null;        if(localeStr!=null && ! "".equals(localeStr)){            l = new Locale(localeStr.split("_")[0],localeStr.split("_")[1]);        }else{            l = locale;        }        session.setAttribute(SessionLocaleResolver.class.getName() + ".LOCALE",l);        return "login";    }}
```

springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:mvc="http://www.springframework.org/schema/mvc"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd"><mvc:default-servlet-handler></mvc:default-servlet-handler><mvc:annotation-driven></mvc:annotation-driven><context:component-scan base-package="com.mashibing"></context:component-scan><bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">    <property name="prefix" value="/WEB-INF/page/"></property>    <property name="suffix" value=".jsp"></property></bean><bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">    <property name="basename" value="login"></property></bean>    <!--配置区域信息解析器--><!--    <bean id="localeResolver" class="com.mashibing.MyLocaleResolver"></bean>-->    <bean id="localeResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver"></bean></beans>
```

使用LocaleChangeInterceptor来实现国际化：

springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:mvc="http://www.springframework.org/schema/mvc"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd"><mvc:default-servlet-handler></mvc:default-servlet-handler><mvc:annotation-driven></mvc:annotation-driven><context:component-scan base-package="com.mashibing"></context:component-scan><bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">    <property name="prefix" value="/WEB-INF/page/"></property>    <property name="suffix" value=".jsp"></property></bean><!--    <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">--><!--        <property name="defaultEncoding" value="UTF-8"></property>--><!--        <property name="maxUploadSize" value="1024000"></property>--><!--    </bean>--><!--    <mvc:interceptors>--><!--        <bean class="com.mashibing.interceptor.MySecondInterceptor"></bean>--><!--        <bean class="com.mashibing.interceptor.MyFirstInterceptor"></bean>--><!--    </mvc:interceptors>--><bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">    <property name="basename" value="login"></property></bean><!--配置区域信息解析器--><!--    <bean id="localeResolver" class="com.mashibing.MyLocaleResolver"></bean>--><bean id="localeResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver"></bean>    <mvc:interceptors>        <bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"></bean>    </mvc:interceptors></beans>
```

I18nController.java

```java
package com.mashibing.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.i18n.SessionLocaleResolver;

import javax.servlet.http.HttpSession;
import java.util.Locale;

@Controller
public class I18nController {

    @Autowired
    private MessageSource messageSource;

    @RequestMapping("i18n")
    public String i18n(@RequestParam(value = "locale",defaultValue = "zh_CN") String localeStr,Locale locale, HttpSession session){

//        Locale l = null;
//        if(localeStr!=null && ! "".equals(localeStr)){
//            l = new Locale(localeStr.split("_")[0],localeStr.split("_")[1]);
//        }else{
//            l = locale;
//        }
//        session.setAttribute(SessionLocaleResolver.class.getName() + ".LOCALE",l);
        return "login";
    }
}
```

### 11、SpringMVC异常处理机制

在SpringMVC中拥有一套非常强大的异常处理机制，SpringMVC通过HandlerExceptionResolver处理程序的异常，包括请求映射，数据绑定以及目标方法的执行时发生的异常。

![image-20200313204210754](image\异常处理实现的子类.png)

在容器启动好，进入DispatcherServlet之后，会对HandlerExceptionResolver进行初始化操作：

![image-20200313204557902](image\异常初始化.png)

会默认的从DispatcherServlet.properties中找到对应的异常处理类：

```properties
#默认的处理类org.springframework.web.servlet.HandlerExceptionResolver=#处理@ExceptionHandlerorg.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\#处理@ResponseStatus，给自定义异常使用org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\#判断是否是SpringMVC自带异常org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver
```

自己定义异常处理方式：

index.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %><html>  <head>    <title>$Title$</title>  </head>  <body><a href="exception1">自己处理异常</a>  </body></html>
```

ExceptionController.java

```java
package com.mashibing.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.jws.WebParam;

@Controller
public class ExceptionController {

    @RequestMapping("exception1")
    public String exception(){
        System.out.println("exception.......");
        System.out.println(10/0);
        return "success";
    }

    @ExceptionHandler(value = {ArithmeticException.class})
    public ModelAndView handlerException(Exception exception){
        ModelAndView mv = new ModelAndView();
        mv.setViewName("error");
        mv.addObject("ex",exception);
        return mv;
    }
}
```

error.jsp

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
我的出错页面：
错误信息：${ex}
</body>
</html>
```

在一个类中可能会包含多个异常的处理方法，在不同的方法上可以使用不同范围的异常，在查找的时候会优先调用范围小的异常处理；

```java
package com.mashibing.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.ModelAndView;

import javax.jws.WebParam;

@Controller
public class ExceptionController {

    @RequestMapping("exception1")
    public String exception(){
        System.out.println("exception.......");
        System.out.println(10/0);
        return "success";
    }

    @ExceptionHandler(value = {ArithmeticException.class})
    public ModelAndView handlerException1(Exception exception){
        System.out.println("handlerException1........");
        ModelAndView mv = new ModelAndView();
        mv.setViewName("error");
        mv.addObject("ex",exception);
        return mv;
    }

    @ExceptionHandler(value = {Exception.class})
    public ModelAndView handlerException2(Exception exception){
        System.out.println("handlerException2........");
        ModelAndView mv = new ModelAndView();
        mv.setViewName("error");
        mv.addObject("ex",exception);
        return mv;
    }
}
```

在不同的类中可能会包含不同的异常处理，因此我们需要定义一个全局的异常控制器,使用@ControllerAdvice注解标注，如果本类跟全局都有相关异常的处理，那么会优先使用本类的。

```java
package com.mashibing.controller;

import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.ModelAndView;

@ControllerAdvice
public class MyGlobalExceptionHandler {
    @ExceptionHandler(value = {ArithmeticException.class})
    public ModelAndView handlerException1(Exception exception){
        System.out.println("handlerException1........");
        ModelAndView mv = new ModelAndView();
        mv.setViewName("error");
        mv.addObject("ex",exception);
        return mv;
    }
}
```

@ResponseStatus的使用：

@ResponseStatus可以标注到方法上，但是标注在方法之后可能导致该方法无法被访问，因此更多的是在自定义类上

```java
package com.mashibing.controller;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.servlet.ModelAndView;

import javax.jws.WebParam;

@Controller
public class ExceptionController {

    @ResponseStatus(reason = "不知道什么原因，反正错误",value = HttpStatus.NOT_ACCEPTABLE)
    @RequestMapping("exception1")
    public String exception(){
        System.out.println("exception.......");
        return "success";
    }
}
```

@ResponseStatus作用在类上

UserNameException.java

```java
package com.mashibing.controller;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(reason = "名字不是admin",value = HttpStatus.NOT_ACCEPTABLE)
public class UserNameException extends RuntimeException {
}
```

ExceptionController.java

```java
package com.mashibing.controller;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.servlet.ModelAndView;

import javax.jws.WebParam;

@Controller
public class ExceptionController {
    @RequestMapping("exception1")
    public String exception(){
        System.out.println("exception.......");
        return "success";
    }
    @RequestMapping("exception2")
    public String exception2(String username){
        System.out.println("exception2222.......");
        if ("admin".equals(username)){
            return "success";
        }else{
            throw new UserNameException();
        }
    }
}
```

springmvc自定义的异常：

index.jsp

```jsp
<%--
  Created by IntelliJ IDEA.
  User: root
  Date: 2020/3/13
  Time: 17:00
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>$Title$</title>
  </head>
  <body>
<a href="exception1">自己处理异常</a>
<a href="exception2?username=zhangsan">自定义异常处理</a>
<a href="exception3">Springmvc自己异常处理</a>
  </body>
</html>
```

ExceptionController.java

```java
package com.mashibing.controller;

import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.servlet.ModelAndView;

import javax.jws.WebParam;

@Controller
public class ExceptionController {

    @RequestMapping("exception1")
    public String exception(){
        System.out.println("exception.......");
        return "success";
    }
    @RequestMapping("exception2")
    public String exception2(String username){
        System.out.println("exception2222.......");
        if ("admin".equals(username)){
            return "success";
        }else{
            throw new UserNameException();
        }
    }

    @RequestMapping(value = "exception3",method = RequestMethod.POST)
    public String exception3(String username){
        System.out.println("exception3.......");
            return "success";
    }
}
```

# 源码链接
该文章源码链接 [Github](url)